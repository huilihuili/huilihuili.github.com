[{"title":"总结：20180603~20180609","date":"2018-06-09T09:00:00.000Z","path":"2018/06/09/summary20180609/","text":"123456789101112java实现word转pdfjava编程思想 - ListIterator 相关操作 - set和存储顺序 - HashCode 方法指导 - bitset - 从内存输入 - 标准i/o重定向 - 进程控制 - 利用注解找到方法 - 利用注解创建sql建表语句 - 利用注解建立单元测试工具 java实现word转pdf如何将word转化为pdf（Java版）java实现word转pdf文件（高效不失真）java 实现word转pdf java编程思想ListIterator 相关操作12345678910111213141516171819202122232425262728293031323334353637383940@Testpublic void test1() &#123; List&lt;String&gt; a = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;); ListIterator&lt;String&gt; it = a.listIterator(); System.out.println(&quot;it.hasNext() = &quot; + it.hasNext()); System.out.println(&quot;it.hasPrevious() = &quot; + it.hasPrevious()); System.out.println(&quot;it.next() = &quot; + it.next()); System.out.println(&quot;it.nextIndex() = &quot; + it.nextIndex()); System.out.println(&quot;it.previous() = &quot; + it.previous()); System.out.println(&quot;it.previousIndex() = &quot; + it.previousIndex());&#125;it.hasNext() = trueit.hasPrevious() = falseit.next() = ait.nextIndex() = 1it.previous() = ait.previousIndex() = -1@Testpublic void test2() &#123; List&lt;String&gt; a = new ArrayList&lt;&gt;(Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)); ListIterator&lt;String&gt; it = a.listIterator(); it.add(&quot;47&quot;); System.out.println(a); it.next(); it.remove(); System.out.println(a); it.next(); it.set(&quot;47&quot;); System.out.println(a);&#125;[47, a, b, c, d][47, b, c, d][47, 47, c, d] set和存储顺序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889class SetType &#123; int i; public SetType(int i) &#123; this.i = i; &#125; public boolean equals(Object o) &#123; return o instanceof SetType &amp;&amp; (i == ((SetType) o).i); &#125; public String toString() &#123; return Integer.toString(i); &#125;&#125;class HashType extends SetType &#123; public HashType(int i) &#123; super(i); &#125; public int hashCode() &#123; return i; &#125;&#125;class TreeType extends SetType implements Comparable&lt;TreeType&gt; &#123; public TreeType(int i) &#123; super(i); &#125; @Override public int compareTo(TreeType arg) &#123; return (arg.i &lt; i ? -1 : (arg.i == i ? 0 : 1)); &#125;&#125;public static &lt;T&gt; Set&lt;T&gt; fill(Set&lt;T&gt; set, Class&lt;T&gt; type) &#123; try &#123; for (int i = 0; i &lt; 10; i++) &#123; set.add(type.getConstructor(int.class).newInstance(i)); &#125; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; return set;&#125;public static &lt;T&gt; void test(Set&lt;T&gt; set, Class&lt;T&gt; type) &#123; fill(set, type); fill(set, type); fill(set, type); System.out.println(set);&#125;@Testpublic void test1() &#123; test(new HashSet&lt;HashType&gt;(), HashType.class); test(new LinkedHashSet&lt;HashType&gt;(), HashType.class); test(new TreeSet&lt;TreeType&gt;(), TreeType.class); test(new HashSet&lt;SetType&gt;(), SetType.class); test(new HashSet&lt;TreeType&gt;(), TreeType.class); test(new LinkedHashSet&lt;SetType&gt;(), SetType.class); test(new LinkedHashSet&lt;TreeType&gt;(), TreeType.class); try &#123; test(new TreeSet&lt;SetType&gt;(), SetType.class); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; try &#123; test(new TreeSet&lt;HashType&gt;(), HashType.class); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125;&#125;[0, 1, 2, 3, 4, 5, 6, 7, 8, 9][0, 1, 2, 3, 4, 5, 6, 7, 8, 9][9, 8, 7, 6, 5, 4, 3, 2, 1, 0][6, 8, 5, 2, 1, 7, 0, 7, 2, 6, 7, 8, 1, 5, 9, 3, 4, 3, 5, 6, 0, 4, 9, 1, 3, 8, 2, 4, 0, 9][3, 3, 7, 0, 6, 2, 6, 4, 1, 5, 9, 0, 3, 7, 5, 1, 8, 8, 5, 4, 4, 2, 7, 8, 2, 9, 0, 6, 9, 1][0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9][0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]java.lang.ClassCastException: top.leagle.thinking.chpter17.SetType cannot be cast to java.lang.Comparablejava.lang.ClassCastException: top.leagle.thinking.chpter17.HashType cannot be cast to java.lang.Comparable可以发现HashSet的类必须实现hashcodeTreeType必须实现Comparable接口 HashCode 方法指导1.给int变量result赋予某个非零值常量，例如17 2.为对象内每个有意义的域f（即每个可以做equals()操作的域）计算一个int散列码c： 域类型 计算 boolean c = (f ? 0 : 1) byte、char、short或int c = (int) f long c = (int) (f^(f&gt;&gt;&gt;32)) float c = Float.floatToIntBits(f) double long l = Double.doubleToLongBits(f) c = (int)(l ^(l &gt;&gt;&gt; 32)) Object，其equals()调用这个域的equals() c = f.hashCode() 数组 对每个元素应用上述规则 3.合并计算得到的散列码result = 37 * result + c4.返回result5.检查hashCode()最后得到的结果，确保相同的对象有相同的散列码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class CountedString &#123; private static List&lt;String&gt; created = new ArrayList&lt;&gt;(); private String s; private int id = 0; public CountedString(String str) &#123; s = str; created.add(s); for (String s2 : created) &#123; if (s2.equals(s)) &#123; id++; &#125; &#125; &#125; @Override public String toString() &#123; return &quot;String: &quot; + s + &quot; id: &quot; + id + &quot; hashCode(): &quot; + hashCode(); &#125; @Override public int hashCode() &#123; int result = 17; result = 37 * result + s.hashCode(); result = 37 * result + id; return result; &#125; @Override public boolean equals(Object obj) &#123; return obj instanceof CountedString &amp;&amp; s.equals(((CountedString) obj).s) &amp;&amp; id == ((CountedString) obj).id; &#125;&#125;@Testpublic void test1() &#123; Map&lt;CountedString, Integer&gt; map = new HashMap&lt;&gt;(); CountedString[] cs = new CountedString[5]; for (int i = 0; i &lt; cs.length; i++) &#123; cs[i] = new CountedString(&quot;hi&quot;); map.put(cs[i], i); &#125; System.out.println(map); for (CountedString cstring : cs) &#123; System.out.println(&quot;Looking up &quot; + cstring); System.out.println(map.get(cstring)); &#125;&#125;&#123;String: hi id: 1 hashCode(): 146447=0, String: hi id: 2 hashCode(): 146448=1, String: hi id: 3 hashCode(): 146449=2, String: hi id: 4 hashCode(): 146450=3, String: hi id: 5 hashCode(): 146451=4&#125;Looking up String: hi id: 1 hashCode(): 1464470Looking up String: hi id: 2 hashCode(): 1464481Looking up String: hi id: 3 hashCode(): 1464492Looking up String: hi id: 4 hashCode(): 1464503Looking up String: hi id: 5 hashCode(): 1464514 bitset1234567891011121314151617@Testpublic void test1() &#123; BitSet bitSet = new BitSet(); bitSet.set(0); bitSet.set(1); System.out.println(bitSet); System.out.println(bitSet.size()); for (int i = 0; i &lt; bitSet.size(); i++) &#123; System.out.print(bitSet.get(i) ? &quot;1&quot; : &quot;0&quot;); &#125; System.out.println();&#125;&#123;0, 1&#125;641100000000000000000000000000000000000000000000000000000000000000 从内存输入1234567891011@Testpublic void memoryInputTest() throws IOException &#123; StringReader in = new StringReader(&quot;I&apos;m Leagle!&quot;); int c; while ((c = in.read()) != -1) &#123; System.out.print((char) c); &#125; System.out.println();&#125;I&apos;m Leagle! 标准i/o重定向123456789101112131415161718@Testpublic void redirectingTest() throws IOException &#123; PrintStream console = System.out; BufferedInputStream in = new BufferedInputStream(new FileInputStream(&quot;in.txt&quot;)); PrintStream out = new PrintStream(new BufferedOutputStream(new FileOutputStream(&quot;out.txt&quot;))); System.setIn(in); System.setOut(out); System.setErr(out); BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String string; while ((string = br.readLine()) != null) &#123; System.out.println(string); &#125; System.out.println(&quot;结束了&quot;); out.close(); System.setOut(console); System.out.println(&quot;结束了&quot;);&#125; 进程控制1234567891011121314151617181920212223242526272829303132public static boolean command(String command) &#123; boolean err = false; try &#123; Process process = new ProcessBuilder(command.split(&quot; &quot;)).start(); BufferedReader results = new BufferedReader( new InputStreamReader(process.getInputStream(), Charset.forName(&quot;GBK&quot;))); String s; while ((s = results.readLine()) != null) &#123; System.out.println(s); &#125; BufferedReader errors = new BufferedReader(new InputStreamReader(process.getErrorStream(), Charset.forName(&quot;GBK&quot;))); while ((s = errors.readLine()) != null) &#123; System.out.println(s); err = true; &#125; &#125; catch (Exception e) &#123; if (!command.equals(&quot;CMD /C&quot;)) &#123; command(&quot;CMD /C &quot; + command); &#125; else &#123; throw new RuntimeException(e); &#125; &#125; return err;&#125;@Testpublic void commandTest() &#123; System.out.println(command(&quot;ping www.baidu.com&quot;)); System.out.println(command(&quot;jjj&quot;)); System.out.println(command(&quot;python d:\\\\error.py&quot;));&#125; 利用注解找到方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface UseCase &#123; public int id(); public String description() default &quot;no description&quot;;&#125;public class PasswordUtils &#123; @UseCase(id = 47, description = &quot;Passwords must contain at least one numeric&quot;) public boolean validatePassword(String passsword) &#123; return (passsword.matches(&quot;\\\\w*\\\\d\\\\w*&quot;)); &#125; @UseCase(id = 48) public String encryptPassword(String password) &#123; return new StringBuilder(password).reverse().toString(); &#125; @UseCase(id = 49, description = &quot;New passwords can&apos;t equal previously used ones&quot;) public boolean checkForNewPassword(List&lt;String&gt; prevPasswords, String password) &#123; return !prevPasswords.contains(password); &#125;&#125;public class UseCaseTracker &#123; public static void trackUseCases(List&lt;Integer&gt; useCases, Class&lt;?&gt; cl) &#123; for (Method m : cl.getDeclaredMethods()) &#123; UseCase useCase = m.getAnnotation(UseCase.class); if (useCase != null) &#123; System.out.println(&quot;Found Use Case: &quot; + useCase.id() + &quot; &quot; + useCase.description()); useCases.remove(new Integer(useCase.id())); &#125; &#125; for (int i : useCases) &#123; System.out.println(&quot;Warning : Missing use case: &quot; + i); &#125; &#125; public static void main(String[] args) &#123; List&lt;Integer&gt; useCases = new ArrayList&lt;&gt;(); Collections.addAll(useCases, 47, 48, 49, 50); trackUseCases(useCases, PasswordUtils.class); &#125;&#125;Found Use Case: 47 Passwords must contain at least one numericFound Use Case: 48 no descriptionFound Use Case: 49 New passwords can&apos;t equal previously used onesWarning : Missing use case: 50 利用注解创建sql建表语句123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface DBTable &#123; public String name() default &quot;&quot;;&#125;@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface Constraints &#123; boolean primaryKey() default false; boolean allowNull() default true; boolean unique() default false;&#125;@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface SQLString &#123; int value() default 0; String name() default &quot;&quot;; Constraints constraints() default @Constraints;&#125;@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface SQLInteger &#123; String name() default &quot;&quot;; Constraints constraints() default @Constraints;&#125;@DBTable(name = &quot;MEMBER&quot;)public class Member &#123; @SQLString(30) private String firstName; @SQLString(50) private String lastName; @SQLInteger private Integer age; @SQLString(value = 30, constraints = @Constraints(primaryKey = true)) private String handle; static int memberCount; public String getFirstName() &#123; return firstName; &#125; public void setFirstName(String firstName) &#123; this.firstName = firstName; &#125; public String getLastName() &#123; return lastName; &#125; public void setLastName(String lastName) &#123; this.lastName = lastName; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getHandle() &#123; return handle; &#125; public void setHandle(String handle) &#123; this.handle = handle; &#125;&#125;public class TableCreator &#123; private static String getConstraints(Constraints con) &#123; String constraints = &quot;&quot;; if (!con.allowNull()) &#123; constraints += &quot; NOT NULL&quot;; &#125; if (con.primaryKey()) &#123; constraints += &quot; PRIMARY KEY&quot;; &#125; if (con.unique()) &#123; constraints += &quot; UNIQUE&quot;; &#125; return constraints; &#125; public static String createTableSql(Class&lt;?&gt; cl) &#123; DBTable dbTable = cl.getAnnotation(DBTable.class); if (dbTable == null) &#123; System.out.println(&quot;No DBTable annotations in class &quot; + cl.getSimpleName()); return null; &#125; String tableName = dbTable.name(); if (tableName.length() &lt; 1) &#123; tableName = cl.getSimpleName().toUpperCase(); &#125; List&lt;String&gt; columnDefs = new ArrayList&lt;&gt;(); for (Field field : cl.getDeclaredFields()) &#123; String columnName = null; Annotation[] annotations = field.getDeclaredAnnotations(); if (annotations.length &lt; 1) &#123; continue; &#125; if (annotations[0] instanceof SQLInteger) &#123; SQLInteger sqlInteger = (SQLInteger) annotations[0]; if (sqlInteger.name().length() &lt; 1) &#123; columnName = field.getName().toUpperCase(); &#125; else &#123; columnName = sqlInteger.name(); &#125; columnDefs.add(columnName + &quot; INT&quot; + getConstraints(sqlInteger.constraints())); &#125; if (annotations[0] instanceof SQLString) &#123; SQLString sqlString = (SQLString) annotations[0]; if (sqlString.name().length() &lt; 1) &#123; columnName = field.getName().toUpperCase(); &#125; else &#123; columnName = sqlString.name(); &#125; columnDefs.add( columnName + &quot; VARCHAR(&quot; + sqlString.value() + &quot;)&quot; + getConstraints(sqlString.constraints())); &#125; &#125; StringBuilder createCommand = new StringBuilder(&quot;CREATE TABLE &quot; + tableName + &quot;(&quot;); for (String columnDef : columnDefs) &#123; createCommand.append(&quot;\\n &quot; + columnDef + &quot;,&quot;); &#125; String tableCreate = createCommand.substring(0, createCommand.length() - 1) + &quot;\\n);&quot;; return tableCreate; &#125; public static void main(String[] args) &#123; System.out.println(createTableSql(Member.class)); &#125;&#125;CREATE TABLE MEMBER( FIRSTNAME VARCHAR(30), LASTNAME VARCHAR(50), AGE INT, HANDLE VARCHAR(30) PRIMARY KEY); 利用注解建立单元测试工具123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface Test &#123;&#125;@Target(&#123; ElementType.FIELD, ElementType.METHOD &#125;)@Retention(RetentionPolicy.RUNTIME)public @interface TestProperty &#123;&#125;@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface TestObjectCreate &#123;&#125;@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface TestObjectCleanup &#123;&#125;public class AtUnitExample5 &#123; private String text; public AtUnitExample5(String text) &#123; this.text = text; &#125; public String toString() &#123; return text; &#125; @TestProperty static PrintWriter output; @TestProperty static int counter; @TestObjectCreate static AtUnitExample5 create() &#123; String id = Integer.toString(counter++); try &#123; System.out.println(&quot;Test&quot; + id + &quot;.txt&quot;); output = new PrintWriter(&quot;Test&quot; + id + &quot;.txt&quot;); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; return new AtUnitExample5(id); &#125; @TestObjectCleanup static void cleanup(AtUnitExample5 tobj) &#123; System.out.println(&quot;Running cleanup&quot;); output.close(); &#125; @Test boolean test1() &#123; output.print(&quot;test1&quot;); return true; &#125; @Test boolean test2() &#123; output.print(&quot;test2&quot;); return true; &#125; @Test boolean test3() &#123; output.print(&quot;test3&quot;); return true; &#125;&#125;public class AtUnit &#123; static List&lt;String&gt; failedTests = new ArrayList&lt;&gt;(); static long testRun = 0; static long failures = 0; public static void unit(Class&lt;?&gt; testClass) &#123; TestMethods testMethods = new TestMethods(); Method creator = null; Method cleanup = null; for (Method m : testClass.getDeclaredMethods()) &#123; testMethods.addIfTestMethod(m); if (creator == null) &#123; creator = checkForCreatorMethod(m, testClass); &#125; if (cleanup == null) &#123; cleanup = checkForCleanupMethod(m, testClass); &#125; &#125; if (testMethods.size() &gt; 0) &#123; if (creator == null) &#123; try &#123; if (!Modifier.isPublic(testClass.getDeclaredConstructor().getModifiers())) &#123; System.out .println(&quot;Error: &quot; + testClass.getSimpleName() + &quot; default constructor must be public&quot;); return; &#125; &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(testClass.getSimpleName()); &#125; for (Method m : testMethods) &#123; System.out.println(&quot;\\n . &quot; + m.getName() + &quot; &quot;); try &#123; Object testObject = createTestObject(creator, testClass); boolean success = false; try &#123; if (m.getReturnType().equals(boolean.class)) &#123; success = (boolean) m.invoke(testObject); &#125; else &#123; m.invoke(testObject); success = true; &#125; &#125; catch (InvocationTargetException e) &#123; System.out.println(e.getCause()); &#125; System.out.print(success ? &quot;&quot; : &quot;(failed)\\n&quot;); testRun++; if (!success) &#123; failures++; failedTests.add(testClass.getSimpleName() + &quot;:&quot; + m.getName()); &#125; if (cleanup != null) &#123; cleanup.invoke(testObject, testObject); &#125; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; &#125; static class TestMethods extends ArrayList&lt;Method&gt; &#123; private static final long serialVersionUID = 1L; void addIfTestMethod(Method m) &#123; if (m.getAnnotation(Test.class) == null) &#123; return; &#125; if (!(m.getReturnType().equals(boolean.class) || m.getReturnType().equals(void.class))) &#123; throw new RuntimeException(&quot;@Test method must return boolean or void&quot;); &#125; m.setAccessible(true); add(m); &#125; &#125; private static Method checkForCreatorMethod(Method m, Class&lt;?&gt; testClass) &#123; if (m.getAnnotation(TestObjectCreate.class) == null) &#123; return null; &#125; if (!m.getReturnType().equals(testClass)) &#123; throw new RuntimeException(&quot;@TestObjectCreate must return instance of Class to be tested&quot;); &#125; if ((m.getModifiers() &amp; Modifier.STATIC) &lt; 1) &#123; throw new RuntimeException(&quot;@TestObjectCreate must be static&quot;); &#125; m.setAccessible(true); return m; &#125; private static Method checkForCleanupMethod(Method m, Class&lt;?&gt; testClass) &#123; if (m.getAnnotation(TestObjectCleanup.class) == null) &#123; return null; &#125; if (!m.getReturnType().equals(void.class)) &#123; throw new RuntimeException(&quot;@TestObjectCleanup method must return void&quot;); &#125; if ((m.getModifiers() &amp; Modifier.STATIC) &lt; 1) &#123; throw new RuntimeException(&quot;@TestObjectCleanup must be static&quot;); &#125; if (m.getParameterTypes().length == 0 || m.getParameterTypes()[0] != testClass) &#123; throw new RuntimeException(&quot;@TestObjectCleanup must take an argument of the tested type.&quot;); &#125; m.setAccessible(true); return m; &#125; private static Object createTestObject(Method creator, Class&lt;?&gt; testClass) &#123; if (creator != null) &#123; try &#123; return creator.invoke(testClass); &#125; catch (Exception e) &#123; throw new RuntimeException(&quot;Couldn&apos;t run @TestObject(creator) method&quot;); &#125; &#125; else &#123; try &#123; return testClass.newInstance(); &#125; catch (Exception e) &#123; throw new RuntimeException(&quot;Couldn&apos;t create a test object. try using a @TestObject method.&quot;); &#125; &#125; &#125; public static void main(String[] args) &#123; AtUnit.unit(AtUnitExample5.class); &#125;&#125;AtUnitExample5 . test1 Test0.txtRunning cleanup . test2 Test1.txtRunning cleanup . test3 Test2.txtRunning cleanup","tags":[{"name":"工作整理","slug":"工作整理","permalink":"http://yoursite.com/tags/工作整理/"},{"name":"java编程思想","slug":"java编程思想","permalink":"http://yoursite.com/tags/java编程思想/"},{"name":"容器","slug":"容器","permalink":"http://yoursite.com/tags/容器/"},{"name":"注解","slug":"注解","permalink":"http://yoursite.com/tags/注解/"}]},{"title":"总结：20180527~20180602","date":"2018-06-02T09:00:00.000Z","path":"2018/06/02/summary20180602/","text":"1234567891011非常漂亮js动态球型云标签特效代码用eclipse启动Tomcat和用startup.bat启动Tomcat产生的效果不一致Java编程思想 - 贪婪型和勉强型(正则表达式) - appendReplacement 和 appendTail - group （正则表达式） - class的创建的几种方法 - instanceof 与 class的等价性 - 泛型方法 - union intersection difference - 通配符(extend super) 非常漂亮js动态球型云标签特效代码这是链接 用eclipse启动Tomcat和用startup.bat启动Tomcat产生的效果不一致1234567word文件（xml格式）使用dom4j编辑的用eclipse启动Tomcat产生的word文档（xml格式）可以正常打开用startup.bat启动Tomcat产生的word文档（xml格式）不能正常打开，用文本工具打开后发现乱码，然后把xml编码格式换成GBK后，可以正常打开原因就是文档中的编码时gbk的，却用utf-8显示，就打不开解决方案：就是在往文档插入字符的时候，用utf-8编码插入 Java编程思想贪婪型和勉强型(正则表达式)123456789101112131415161718192021222324@Testpublic void test1() &#123; String s = &quot;Never give up! Never surrender!&quot;; System.out.println(&quot;--- 贪婪型 ---&quot;); Pattern p = Pattern.compile(&quot;Never.*!&quot;); Matcher m = p.matcher(s); while (m.find()) &#123; System.out.println(m.group()); &#125; System.out.println(&quot;--- 勉强型 ---&quot;); p = Pattern.compile(&quot;Never.*?!&quot;); m = p.matcher(s); while (m.find()) &#123; System.out.println(m.group()); &#125;&#125;--- 贪婪型 ---Never give up! Never surrender!--- 勉强型 ---Never give up!Never surrender! appendReplacement 和 appendTail123456789101112131415161718192021222324@Testpublic void test2() &#123; String s = &quot;I love study!&quot;; StringBuffer sbuf = new StringBuffer(); Pattern p = Pattern.compile(&quot;[aeiou]&quot;); Matcher m = p.matcher(s); while (m.find()) &#123; m.appendReplacement(sbuf, m.group().toUpperCase()); &#125; System.out.println(sbuf); sbuf = new StringBuffer(); p = Pattern.compile(&quot;[aeiou]&quot;); m = p.matcher(s); while (m.find()) &#123; m.appendReplacement(sbuf, m.group().toUpperCase()); &#125; m.appendTail(sbuf); System.out.println(sbuf);&#125;I lOvE stUI lOvE stUdy! group （正则表达式）1234567891011121314151617181920A(B(C))D有三个组 组0是ABCD，组1是BC，组2是Cgroup()是返回第0组，也就是整个匹配@Testpublic void test3() &#123; String s = &quot;58.27.82.161@02/10/2005&quot;; Pattern p = Pattern.compile(&quot;(\\\\d+[.]\\\\d+[.]\\\\d+[.]\\\\d+)@(\\\\d&#123;2&#125;/\\\\d&#123;2&#125;/\\\\d&#123;4&#125;)&quot;); Matcher m = p.matcher(s); while (m.find()) &#123; System.out.println(&quot;m.group() = &quot; + m.group()); System.out.println(&quot;m.group(1) = &quot; + m.group(1)); System.out.println(&quot;m.group(2) = &quot; + m.group(2)); &#125;&#125;m.group() = 58.27.82.161@02/10/2005m.group(1) = 58.27.82.161m.group(2) = 02/10/2005 class的创建的几种方法12345678910111213141516171819@Testpublic void test1() &#123; try &#123; Class&lt;?&gt; classStudy = Class.forName(&quot;top.leagle.thinking.chapter14.ClassStudy&quot;); System.out.println(&quot;Class.forName() : &quot; + classStudy.getSimpleName()); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; Class&lt;ClassStudy&gt; classStudy = ClassStudy.class; System.out.println(&quot;.class : &quot; + classStudy.getSimpleName()); Class&lt;?&gt; classStudy1 = new ClassStudy().getClass(); System.out.println(&quot;.classStudy1 : &quot; + classStudy1.getSimpleName());&#125;Class.forName() : ClassStudy.class : ClassStudy.classStudy1 : ClassStudy instanceof 与 class的等价性1234567891011121314151617181920212223242526272829303132333435363738394041class Base &#123;&#125;class Derived extends Base &#123;&#125;static void test(Object x) &#123; System.out.println(&quot;Testing x of type &quot; + x.getClass()); System.out.println(&quot;x instanceof Base &quot; + (x instanceof Base)); System.out.println(&quot;x instanceof Derived &quot; + (x instanceof Derived)); System.out.println(&quot;Base.isInstance(x) &quot; + Base.class.isInstance(x)); System.out.println(&quot;Derived.isInstance(x) &quot; + Derived.class.isInstance(x)); System.out.println(&quot;x.getClass() == Base.class &quot; + (x.getClass() == Base.class)); System.out.println(&quot;x.getClass() == Derived.class &quot; + (x.getClass() == Derived.class)); System.out.println(&quot;x.getClass().equals(Base.class)) &quot; + (x.getClass().equals(Base.class))); System.out.println(&quot;x.getClass().equals(Derived.class)) &quot; + (x.getClass().equals(Derived.class))); System.out.println();&#125;@Testpublic void test2() &#123; test(new Base()); test(new Derived());&#125;Testing x of type class top.leagle.thinking.chapter14.Basex instanceof Base truex instanceof Derived falseBase.isInstance(x) trueDerived.isInstance(x) falsex.getClass() == Base.class truex.getClass() == Derived.class falsex.getClass().equals(Base.class)) truex.getClass().equals(Derived.class)) falseTesting x of type class top.leagle.thinking.chapter14.Derivedx instanceof Base truex instanceof Derived trueBase.isInstance(x) trueDerived.isInstance(x) truex.getClass() == Base.class falsex.getClass() == Derived.class truex.getClass().equals(Base.class)) falsex.getClass().equals(Derived.class)) true 泛型方法1234567891011121314public &lt;T&gt; void f(T x) &#123; System.out.println(x.getClass().getName());&#125;@Testpublic void test1() &#123; GenericsStudy gm = new GenericsStudy(); gm.f(&quot;&quot;); gm.f(1); gm.f(1.0); gm.f(1.0F); gm.f(&apos;c&apos;); gm.f(gm);&#125; union intersection difference1234567891011121314151617181920212223242526272829303132333435363738class Sets &#123; public static &lt;E&gt; Set&lt;E&gt; union(Set&lt;E&gt; a, Set&lt;E&gt; b) &#123; Set&lt;E&gt; result = new HashSet&lt;&gt;(a); result.addAll(b); return result; &#125; public static &lt;E&gt; Set&lt;E&gt; intersection(Set&lt;E&gt; a, Set&lt;E&gt; b) &#123; Set&lt;E&gt; result = new HashSet&lt;&gt;(a); result.retainAll(b); return result; &#125; public static &lt;E&gt; Set&lt;E&gt; difference(Set&lt;E&gt; superset, Set&lt;E&gt; subset) &#123; Set&lt;E&gt; result = new HashSet&lt;&gt;(superset); result.removeAll(subset); return result; &#125; public static &lt;E&gt; Set&lt;E&gt; complement(Set&lt;E&gt; a, Set&lt;E&gt; b) &#123; return difference(union(a, b), intersection(a, b)); &#125;&#125;@Testpublic void test2() &#123; Set&lt;Integer&gt; a = new HashSet&lt;&gt;(Arrays.asList(1, 2, 3)); Set&lt;Integer&gt; b = new HashSet&lt;&gt;(Arrays.asList(2, 3, 4)); System.out.println(Sets.union(a, b)); System.out.println(Sets.intersection(a, b)); System.out.println(Sets.difference(a, b)); System.out.println(Sets.complement(a, b));&#125;[1, 2, 3, 4][2, 3][1][1, 4] 通配符(extend super)123456789101112131415161718192021222324252627282930313233class Fruit &#123;&#125;class Apple extends Fruit &#123;&#125;class Jonathan extends Apple &#123;&#125;class Orange extends Fruit &#123;&#125;@Testpublic void test3() &#123; // List&lt;Fruit&gt; fList = new ArrayList&lt;Apple&gt;(); // cannot convert from ArrayList&lt;Apple&gt; to List&lt;Fruit&gt; List&lt;? extends Fruit&gt; fList = new ArrayList&lt;Apple&gt;(); // fList.add(new Fruit()); // fList.add(new Apple()); // The method add(capture#2-of ? extends Fruit) in the type List&lt;capture#2-of ? // extends Fruit&gt; is not applicable for the arguments (Apple) System.out.println(fList); fList = Arrays.asList(new Apple(), new Jonathan()); System.out.println(fList);&#125;public void WriteTo(List&lt;? super Apple&gt; apples) &#123; apples.add(new Apple()); apples.add(new Jonathan()); // apples.add(new Fruit());&#125;@Testpublic void test4() &#123; List&lt;Apple&gt; fList = new ArrayList&lt;&gt;(); WriteTo(fList); System.out.println(fList);&#125;","tags":[{"name":"工作整理","slug":"工作整理","permalink":"http://yoursite.com/tags/工作整理/"},{"name":"java编程思想","slug":"java编程思想","permalink":"http://yoursite.com/tags/java编程思想/"},{"name":"球型云标签","slug":"球型云标签","permalink":"http://yoursite.com/tags/球型云标签/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://yoursite.com/tags/正则表达式/"},{"name":"泛型","slug":"泛型","permalink":"http://yoursite.com/tags/泛型/"}]},{"title":"总结：20180520~20180526","date":"2018-05-26T09:00:00.000Z","path":"2018/05/26/summary20180526/","text":"123456789101112重构教育大数据失败java编程思想 - 成员的初始化 - 对象的创建过程 - 访问权限修饰词 - 继承（字段不共享） - 构造器内部的多态方法 - 关于容器 - retun与finally - 异常轨迹 - 不可变String - &quot;+&quot; 和 StringBuilder 重构教育大数据1234重构前，想到了很多好用的点子，像继承，耦合等等。写了两天，实现了一两个功能，发现代码还可以。又继续写了几个功能块，发现代码还是挤在了一起，无法耦合。鉴于后面还有好多功能块都还没有实现，就放弃了。 java编程思想成员的初始化123456789101112131415161718192021222324252627282930313233343536373839404142class InitialValues &#123; boolean t; char c; byte b; short s; int i; long l; float f; double d; InitialValues reference; void printInitialValues() &#123; System.out.println(&quot;Data Type Initial Value&quot;); System.out.println(&quot;boolean &quot; + t); System.out.println(&quot;char [&quot; + c + &quot;]&quot;); System.out.println(&quot;byte &quot; + b); System.out.println(&quot;short &quot; + s); System.out.println(&quot;int &quot; + i); System.out.println(&quot;long &quot; + l); System.out.println(&quot;float &quot; + f); System.out.println(&quot;d &quot; + d); System.out.println(&quot;reference &quot; + reference); &#125;&#125;@Testpublic void test2() &#123; new InitialValues().printInitialValues();&#125;Data Type Initial Valueboolean falsechar [ ]byte 0short 0int 0long 0float 0.0d 0.0reference nullchar值为0，所以显示为空白 对象的创建过程1234567假设有个名为Dog的类：1.即使没有显式地使用static关键字，构造器实际上也是静态方法。因此，当首次创建类型为Dog的对象时，或者Dog类的静态方法/静态域首次被访问时，java解释器必须查找类路径，以定位Dog.class文件2.然后载入Dog.class，有关静态初始化的所有动作都会执行。因此，静态初始化只在Class对象首次加载的时候运行一次。3.当使用new Dog()创建对象的时候，首先将堆上为Dog对象分配足够的存储空间。4.这块存储空间为被清零，这就自动地将Dog对象的所有基本类型数据都设置成了默认值，而引用则被设置成了null。5.执行所有出现于字段定义处的初始化动作。6.执行构造器。 访问权限修饰词1234public：哪里都可以访问protected：继承类可以访问，相同包内的其他类可以访问没有关键词：包访问权限private：除了包含该成员的类之外，其他任何类都无法访问这个成员。 继承（字段不共享）1234567891011121314151617181920212223242526272829303132class Super &#123; public int field = 0; public int getField() &#123; return field; &#125;&#125;class Sub extends Super &#123; public int field = 1; @Override public int getField() &#123; return field; &#125; public int getSuperSield() &#123; return super.field; &#125;&#125;@Testpublic void test1() &#123; Super sup = new Sub(); System.out.println(&quot;sup.field = &quot; + sup.field + &quot;, sup.getField() = &quot; + sup.getField()); Sub sub = new Sub(); System.out.println(&quot;sub.field = &quot; + sub.field + &quot;, sub.getField() = &quot; + sub.getField() + &quot;, sub.getSuperField() = &quot; + sub.getSuperSield());&#125;sup.field = 0, sup.getField() = 1sub.field = 1, sub.getField() = 1, sub.getSuperField() = 0 构造器内部的多态方法1234567891011121314151617181920212223242526272829303132333435class Glypy &#123; void draw() &#123; System.out.println(&quot;Glyph.draw()&quot;); &#125; public Glypy() &#123; System.out.println(&quot;Glyph() before draw()&quot;); draw(); System.out.println(&quot;Glypy() after draw()&quot;); &#125;&#125;class RoundGlyph extends Glypy &#123; private int radius = 1; public RoundGlyph(int r) &#123; radius = r; System.out.println(&quot;GoundGlyph.RoundGlyph(), radius = &quot; + radius); &#125; @Override void draw() &#123; System.out.println(&quot;GoundGlyph.draw(), radius = &quot; + radius); &#125;&#125;@Testpublic void test2() &#123; new RoundGlyph(5);&#125;Glyph() before draw()GoundGlyph.draw(), radius = 0Glypy() after draw()GoundGlyph.RoundGlyph(), radius = 5 关于容器12345678910111213List - ArrayList - LinkedList set - HashSet - TreeSet - LinkedHashSetMap - HashMap - TreeMap - LinkedHashMap retun与finally1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public static void f(int i) &#123; System.out.println(&quot;Initialization that requires cleanup&quot;); try &#123; System.out.println(&quot;Point 1&quot;); if (i == 1) &#123; return; &#125; System.out.println(&quot;Point 2&quot;); if (i == 2) &#123; return; &#125; System.out.println(&quot;Point 3&quot;); if (i == 3) &#123; return; &#125; System.out.println(&quot;End&quot;); return; &#125; finally &#123; System.out.println(&quot;Performing cleanup&quot;); &#125;&#125;@Testpublic void test1() &#123; for (int i = 1; i &lt;= 4; i++) &#123; f(i); &#125;&#125;Initialization that requires cleanupPoint 1Performing cleanupInitialization that requires cleanupPoint 1Point 2Performing cleanupInitialization that requires cleanupPoint 1Point 2Point 3Performing cleanupInitialization that requires cleanupPoint 1Point 2Point 3EndPerforming cleanup 异常轨迹123456789101112131415161718192021222324252627282930313233343536373839public static void f() &#123; try &#123; throw new Exception(); &#125; catch (Exception e) &#123; for (StackTraceElement ste : e.getStackTrace()) &#123; System.out.println(ste.getMethodName()); &#125; &#125;&#125;public static void g() &#123; f();&#125;public static void h() &#123; g();&#125;public static void main(String[] args) &#123; f(); System.out.println(&quot;-------------------------&quot;); g(); System.out.println(&quot;-------------------------&quot;); h();&#125;fmain-------------------------fgmain-------------------------fghmain 不可变String12345678910111213141516public static String upcase(String s) &#123; return s.toUpperCase();&#125;@Testpublic void test1() &#123; String q = &quot;howdy&quot;; System.out.println(q); String qq = upcase(q); System.out.println(qq); System.out.println(q);&#125;howdyHOWDYhowdy “+” 和 StringBuilder12简单的输出可以直接使用字符串的加号但凡在循环中出现字符串叠加，使用StringBuilder性能会比价好。","tags":[{"name":"工作整理","slug":"工作整理","permalink":"http://yoursite.com/tags/工作整理/"},{"name":"java编程思想","slug":"java编程思想","permalink":"http://yoursite.com/tags/java编程思想/"}]},{"title":"总结：20180513~20180519","date":"2018-05-19T09:00:00.000Z","path":"2018/05/19/summary20180519/","text":"123456789人工智能开发框架通过7个函数解密区块链java编程思想阅读总结 - 关于this - 关于Java中字符串switch的实现细节 - 关于Random - 关于逻辑操作符（&amp;&amp;(与)、 ||(或)、 !(非)） - 关于移位操作符 - 关于提升 人工智能开发框架123456TensorFlowKerasCNTKCaffeMXNetPyTorch 通过7个函数解密区块链这是链接 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153我觉得里面的程序有点错误，下面是我修改后的，应该是对的，不过我也不清楚，望指正。import jsonimport hashlibdef hash_function(k): &quot;&quot;&quot;Hashes our transaction.&quot;&quot;&quot; if type(k) is not str: k = json.dumps(k, sort_keys=True).encode(&quot;utf8&quot;) return hashlib.sha256(k).hexdigest()def update_state(transaction, state): state = state.copy() for key in transaction: if key in state.keys(): state[key] += transaction[key] else: state[key] = transaction[key] return statedef valid_transaction(transaction, state): &quot;&quot;&quot;A valid transaction must sum to 0.&quot;&quot;&quot; if sum(transaction.values()) is not 0: return False for key in transaction.keys(): if key in state.keys(): account_balance = state[key] else: account_balance = 0 if account_balance + transaction[key] &lt; 0: return False return Truedef make_block(transaction, state, chain): &quot;&quot;&quot;Make a block to go into the chain.&quot;&quot;&quot; parent_hash = chain[-1][&apos;hash&apos;] block_number = chain[-1][&apos;contents&apos;][&apos;block_number&apos;] + 1 block_contents = &#123; &apos;block_number&apos;: block_number, &apos;parent_hash&apos;: parent_hash, &apos;transaction_count&apos;: block_number + 1, &apos;transaction&apos;: [transaction], &apos;state&apos;: state, &#125; return &#123;&apos;hash&apos;: hash_function(block_contents), &apos;contents&apos;: block_contents&#125;def check_block_hash(block): expected_hash = hash_function(block[&apos;contents&apos;]) if block[&apos;hash&apos;] != expected_hash: raise Exception(&apos;Invalid transaction.&apos;) returndef check_block_validity(block, parent, state): parent_number = parent[&apos;contents&apos;][&apos;block_number&apos;] parent_hash = parent[&apos;hash&apos;] block_number = block[&apos;contents&apos;][&apos;block_number&apos;] for transaction in block[&apos;contents&apos;][&apos;transaction&apos;]: if valid_transaction(transaction, state): state = update_state(transaction, state) else: raise Exception(&apos;Invalid transaction.&apos;) check_block_hash(block) # Check hash integrity if block_number is not parent_number + 1: raise Exception(&apos;Invalid transaction.&apos;) if block[&apos;contents&apos;][&apos;parent_hash&apos;] is not parent_hash: raise Exception(&apos;Invalid transaction.&apos;) return statedef check_chain(chain): &quot;&quot;&quot;Check the chain is valid.&quot;&quot;&quot; if type(chain) is str: try: chain = json.loads(chain) assert (type(chain) == list) except ValueError: # String passed in was not valid JSON return False elif type(chain) is not list: return False state = &#123;&#125; for transaction in chain[0][&apos;contents&apos;][&apos;transaction&apos;]: state = update_state(transaction, state) check_block_hash(chain[0]) parent = chain[0] for block in chain[1:]: state = check_block_validity(block, parent, state) parent = block return statedef add_transaction_to_chain(transaction, state, chain): if valid_transaction(transaction, state): state = update_state(transaction, state) else: raise Exception(&apos;Invalid transaction.&apos;) my_block = make_block(transaction, state, chain) chain.append(my_block) # for transaction in chain: check_chain(chain) return state, chainif __name__ == &apos;__main__&apos;: genesis_block = &#123; &apos;hash&apos;: hash_function(&#123; &apos;block_number&apos;: 0, &apos;parent_hash&apos;: None, &apos;transaction_count&apos;: 1, &apos;transaction&apos;: [&#123;&apos;Tom&apos;: 10&#125;], &apos;state&apos;: &#123;&apos;Tom&apos;: 10&#125; &#125;), &apos;contents&apos;: &#123; &apos;block_number&apos;: 0, &apos;parent_hash&apos;: None, &apos;transaction_count&apos;: 1, &apos;transaction&apos;: [&#123;&apos;Tom&apos;: 10&#125;], &apos;state&apos;: &#123;&apos;Tom&apos;: 10&#125; &#125;, &#125; block_chain = [genesis_block] chain_state = &#123;&apos;Tom&apos;: 10&#125; chain_state, block_chain = add_transaction_to_chain(transaction=&#123;&apos;Tom&apos;: -1, &apos;Medium&apos;: 1&#125;, state=chain_state, chain=block_chain) java编程思想阅读总结关于this123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100package top.leagle.thinking.chapter5;import org.junit.Test;/** * * @ClassName: ThisStudy * @author: Leagle * @date: 2018年5月19日 下午4:02:56 * @Description: * Leaf是用来测试test1的 * Person、Peeler、Apple是用来测试test2的 * Flower是用来测试test3的 * * 尽管可以用this调用一个构造器，但却不能调用两个。此外，必须将构造器调用置于最起始处。 * 除了构造器之外，禁止在其他任何方法中调用构造器方法。 */public class ThisStudy &#123; @Test public void test1() &#123; Leaf leaf = new Leaf(); leaf.increment().increment().increment().print(); &#125; @Test public void test2() &#123; new Person().eat(new Apple()); &#125; @Test public void test3() &#123; new Flower().printPetalCount(); &#125;&#125;class Leaf &#123; int i = 0; Leaf increment() &#123; i++; return this; &#125; void print() &#123; System.out.println(&quot;i = &quot; + i); &#125;&#125;class Person &#123; public void eat(Apple apple) &#123; Apple peeled = apple.getPeeled(); System.out.println(peeled + &quot; Yummy&quot;); &#125;&#125;class Peeler &#123; static Apple peel(Apple apple) &#123; System.out.println(&quot;remove peel...&quot;); return apple; &#125;&#125;class Apple &#123; Apple getPeeled() &#123; return Peeler.peel(this); &#125;&#125;class Flower &#123; int petalCount = 0; String s = &quot;initial value&quot;; Flower(int petals) &#123; petalCount = petals; System.out.println(&quot;Constructor w/ int arg only, petalCount=&quot; + petalCount); &#125; Flower(String ss) &#123; s = ss; System.out.println(&quot;Constructor w/ string arg only, s=&quot; + s); &#125; Flower(String s, int petals) &#123; this(petals); // ! this(s) Can&apos;t call two! this.s = s; System.out.println(&quot;String &amp; int args&quot;); &#125; Flower() &#123; this(&quot;hi&quot;, 47); System.out.println(&quot;default constructor (no args)&quot;); &#125; void printPetalCount() &#123; // ! this(11) Not inside non-constructor! System.out.println(&quot;petalCount = &quot; + petalCount + &quot; s = &quot; + s); &#125;&#125; Java中字符串switch的实现细节这是链接 关于Random1234567891011121314151617181920212223242526272829303132package top.leagle.thinking.chapter4;import java.util.Random;import org.junit.Test;/** * * @ClassName: RandomStudy * @author: Leagle * @date: 2018年5月19日 下午4:18:26 * @Description: * 创建Random对象的时候，如果没有传递任何参数， * 那么java就会将当前时间作为随机生成器的种子，并由此 * 在程序每一次执行时期都产生不同的输出。 * * 通过在创建Random对象时提供种子，用于随机数 * 生成器的初始化值，随机数生成器对于特定的种子总是产生 * 相同的随机数序列。 */public class RandomStudy &#123; @Test public void test1() &#123; Random random = new Random(47); int i, j, k; i = random.nextInt(100) + 1; j = random.nextInt(100) + 1; k = random.nextInt(100) + 1; System.out.println(&quot;i = &quot; + i + &quot;; j = &quot; + j + &quot;; k = &quot; + k); &#125;&#125; 关于逻辑操作符（&amp;&amp;(与)、 ||(或)、 !(非)）12345678与、或、非操作只应用于布尔值。int i = 10, j = 20;错误的： print(&quot;i &amp;&amp; j is &quot; + (i &amp;&amp; j));正确的： print(&quot;(i &lt; 10) &amp;&amp; (j &lt; 10) is &quot; + ((i &lt; 10) &amp;&amp; (j &lt; 10))); 关于移位操作符123456789101112131415161718192021222324252627282930313233343536373839404142package top.leagle.thinking.chapter4;import org.junit.Test;/** * * @ClassName: ShiftStudy * @author: Leagle * @date: 2018年5月19日 下午4:50:50 * @Description: * 对char、byte或者short类型的数值进行移位处理， * 那么在移位之前，它们会被转为int类型，并且得到的结果也是 * 一个int类型的值。 */public class ShiftStudy &#123; @Test public void test1() &#123; byte b = -1; System.out.println(Integer.toBinaryString(b)); b &gt;&gt;&gt;= 10; System.out.println(Integer.toBinaryString(b)); b = -1; System.out.println(Integer.toBinaryString(b)); System.out.println(Integer.toBinaryString(b &gt;&gt;&gt; 10)); &#125; @Test public void test2() &#123; byte b = -1; System.out.println(Integer.toBinaryString(b)); b &gt;&gt;&gt;= 10; System.out.println(Integer.toBinaryString(b)); b = -1; System.out.println(Integer.toBinaryString(b)); b = (byte) (b &gt;&gt;&gt; 10); System.out.println(Integer.toBinaryString(b)); &#125;&#125; 关于提升12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package top.leagle.thinking.chapter4;import org.junit.Test;/** * * @ClassName: PromoteStudy * @author: Leagle * @date: 2018年5月19日 下午5:04:12 * @Description: * 如果对基本类型数据类型进行算术运算或按位运算， * 只要类型比int小（即char、byte和short），那么在 * 运算之前，这些值会自动转换为int，生成的结果也是int * 类型。 */public class PromoteStudy &#123; @Test public void test1() &#123; short x = 10, y = 20; x = (short) (x + y); x = (short) (x - y); x = (short) (x * y); x = (short) (x / y); x = (short) (x % y); x = (short) +y; x = (short) -y; x += y; x -= y; x *= y; x /= y; x %= y; &#125; @Test public void test2() &#123; short x = 10, y = 20; x = (short) (x &amp; y); x = (short) (x | y); x = (short) (x ^ y); x = (short) (x &lt;&lt; 1); x = (short) (x &gt;&gt; 1); x = (short) (x &gt;&gt;&gt; 1); x &amp;= y; x |= y; x ^= y; x &lt;&lt;= 1; x &gt;&gt;= 1; x &gt;&gt;&gt;= 1; &#125;&#125;","tags":[{"name":"工作整理","slug":"工作整理","permalink":"http://yoursite.com/tags/工作整理/"},{"name":"java编程思想","slug":"java编程思想","permalink":"http://yoursite.com/tags/java编程思想/"},{"name":"this","slug":"this","permalink":"http://yoursite.com/tags/this/"},{"name":"Random","slug":"Random","permalink":"http://yoursite.com/tags/Random/"},{"name":"逻辑操作符","slug":"逻辑操作符","permalink":"http://yoursite.com/tags/逻辑操作符/"},{"name":"移位操作符","slug":"移位操作符","permalink":"http://yoursite.com/tags/移位操作符/"},{"name":"java提升","slug":"java提升","permalink":"http://yoursite.com/tags/java提升/"}]},{"title":"总结：20180506~20180512","date":"2018-05-12T09:00:00.000Z","path":"2018/05/12/summary20180512/","text":"12345这件事情已经做了多半年了，需求变更很快，每次都很急，做了这么多，东西也已经很庞大了，是时候总结一下了。大概过程是这样的：从别人数据库拷贝数据、处理数据、生成各种表格图片和图表、生成word报告我负责数据处理和图表生成，当然也涉及到一点word报告。不过本篇主要讲述数据处理和图表生成的相关分析。 数据处理需求分析123456789101112131415161718192021222324252627282930313233关于学校：学校ID、学校名称、初中/高中、初中分类（公办/民办）|高中分类（市重点/市普通）关于科目：科目ID、科目名称、初中/高中关于考试：考试ID、考试名称、考试昵称（简称）、入学年份、初中/高中、年级ID（初几/高几）、第一学期/第二学期、期中/期末关于知识块：考试ID、科目ID、知识块1包含的小题数目、知识块1的名称、知识块1的总分、知识块2、知识块2...学生层面： 每次考试、每个学生的知识块分数、科目分数 每次考试、每个学生的总分（三科|五科|六科...）班级层面： 每次考试、每个班级的知识块平均分、知识块得分率、知识块平均分在整个区的排名、科目平均分、科目平均分在整个区的排名 每次考试、每个班级的总分平均分、总分平均分在整个区的排名 学校层面： 每次考试、每个学校的知识块平均分、知识块得分率、知识块平均分在整个区的排名、科目平均分、科目平均分在整个区的排名 每次考试、每个学校的总分平均分、总分平均分在整个区的排名区层面： 每次考试、每个区（全区|学校分类）的知识块平均分、知识块得分率、科目平均分 每次考试、每个区（全区|学校分类）的总分平均分过线人数： 整个区的学生前25%、前60%、前85%画分数线 根据分数线算出每个学校在每个分数线下的过线人数 关于人群： 所有参加考试的人为人群 参加中考名单或高考名单的人为人群 参加某次考试的人为人群 知识块平均分、科目平均分的人群：科目分数不为0的人 总分的人群：每个科目都不为0人 过线人数的人群：所有人 注意事项1234567891011121314----------------------------------------------------------------------学校分为初中和高中科目分为初中和高中区分为整个区（所有学校）和部分区（几个学校）部分区：公办民办？市重点市普通？知识块平均分：所有人？科目分数不为0？科目平均分：所有人？科目分数不为0？总分：三科总分？五科总分？六科总分？|所有人？总分不为0？每一科都不为0？总分分数线：所有人？总分不为0？每一科都不为0？科目分数线：所有人？科目分数不为0---------------------------------------------------------------------- 表结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263----------------------------------------------------------------------qam_school_info：学校信息qam_dimen_info：知识块信息qam_semester_info：考试信息qam_subject_info：科目信息qam_district_info：区信息--------------------------------------------------------------------------------------------------------------------------------------------qa_stu_dimen：学生知识块分数qa_stu_sum：学生总分分数qa_class_dimen：班级知识块分数qa_class_sum：班级总分分数qa_school_dimen：学生知识块分数qa_school_sum：学校分数总分qa_district_dimen：区知识块分数qa_district_sum：区分数总分--------------------------------------------------------------------------------------------------------------------------------------------qa_sum_num：区总分分数与人数qa_district_line：区总分分数线qa_school_line：学校总分过线人数qa_district_line_num：区总分过线人数qa_subject_sum_num：区科目分数与人数qa_subject_district_line：区科目分数线qa_subject_school_line：学校科目过线人数qa_subject_district_line_num：区科目过线人数--------------------------------------------------------------------------------------------------------------------------------------------qa_zk_student_jyjid：参加中考或高考学生的教育局编码qa_zk_studentid：参加中考或高考学生的学生IDqa_zk_stu_dimen：参加中考或高考学生的学生知识块分数qa_zk_stu_sum：参加中考或高考学生的学生总分分数qa_zk_class_dimen：参加中考或高考学生的班级知识块分数qa_zk_class_sum：参加中考或高考学生的班级总分分数qa_zk_school_dimen：参加中考或高考学生的学生知识块分数qa_zk_school_sum：参加中考或高考学生的学校分数总分qa_zk_district_dimen：参加中考或高考学生的区知识块分数qa_zk_district_sum：参加中考或高考学生的区分数总分qa_zk_sum_num：参加中考或高考学生的区总分分数与人数qa_zk_district_line：参加中考或高考学生的区总分分数线qa_zk_school_line：参加中考或高考学生的学校总分过线人数qa_zk_district_line_num：参加中考或高考学生的区总分过线人数qa_zk_subject_sum_num：参加中考或高考学生的区科目分数与人数qa_zk_subject_district_line：参加中考或高考学生的区科目分数线qa_zk_subject_school_line：参加中考或高考学生的学校科目过线人数qa_zk_subject_district_line_num：参加中考或高考学生的区科目过线人数---------------------------------------------------------------------- 图表生成区123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475总分散点图（图片）：每个学校的总分的得分率和总分的标准差、标签都是每个学校的名称科目散点图（图片）：每个学校的科目的得分率和科目的标准差、标签都是每个学校的名称总分箱形图（图片）：每个学校的所有的学生的总分、标签都是每个学校的名称科目箱形图（图片）：每个学校的所有的学生的科目分数、标签都是每个学校的名称考试各科分数、各科排名、总分、总分排名（表格）:类别 语文 排名 数学 排名 英语 排名 物理 排名 化学 排名 总分 排名全区公办民办曹行中学上虹中学古美学校...总分分数分布、科目分数分布（柱状图）科目 (0-120] (120-125] (125-130] (130-135] ...总分 考试各科实考人数（表格）：类别 语文 数学 英语 物理 化学全区公办民办曹行中学上虹中学古美学校...考试总分过线人数（表格）：学校 前25%人数 前60%人数 前85%人数全区公办民办曹行中学上虹中学古美学校...考试科目知识块得分（折线图）学校 默写 课内古诗 课内文言文 课外文言文 现代文阅读（一） 现代文阅读（二） 综合 作文全区公办民办曹行中学上虹中学古美学校...考试科目知识块得分（表格）：学校 默写 课内古诗 课内文言文 课外文言文 现代文阅读（一） 现代文阅读（二） 综合 作文全区公办民办曹行中学上虹中学古美学校...考试各班级各科分数及排名学校 班级 语文 排名 数学 排名 英语 排名 物理 排名 化学 排名 总分 排名上宝中学 初中三年级(8)班上宝中学 初中三年级(3)班上宝中学 初中三年级(1)班上宝中学 初中三年级(6)班... 学校123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263总分散点图（图片）：每个学校的总分的得分率和总分的标准差、别的学校的标签都是学校+数字科目散点图（图片）：每个学校的科目的得分率和科目的标准差、别的学校的标签都是学校+数字总分箱形图（图片）：每个学校的所有的学生的总分、别的学校的标签都是学校+数字科目箱形图（图片）：每个学校的所有的学生的科目分数、别的学校的标签都是学校+数字考试学校各科分数、总分（表格）类别 语文 数学 英语 物理 化学 总分全区公办民办北桥中学考试学校各科实考人数（表格）：类别 语文 数学 英语 物理 化学全区公办民办北桥中学考试学校总分过线人数（表格）：学校 前25%人数 前60%人数 前85%人数北桥中学考试学校科目知识块得分率及区、同类学校得分率（雷达图）：类别 默写 课内古诗 课内文言文 课外文言文 现代文阅读（一） 现代文阅读（二） 综合 作文区同类学校北桥中学各考试学校科目平均分、区平均分、同类学校平均分以及排名（折线图+柱状图+双轴）：考试 排名 区平均分 同类学校平均分 校平均分初中预备初一期末初二期末初三一模初三二模各考试学校科目知识块排名（雷达图）：考试 默写 课内古诗 课内文言文 课外文言文 现代文阅读（一） 现代文阅读（二） 综合 作文初中预备初一期末初二期末初三一模初三二模各考试学校科目知识块排名变化（柱状图）：考试 默写 课内古诗 课内文言文 课外文言文 现代文阅读（一） 现代文阅读（二） 综合 作文初一期末-初中预备初二期末-初一期末初三一模-初二期末初三二模-初三一模初三二模-初中预备各考试学校科目知识块分数（表格）：考试 默写 课内古诗 课内文言文 课外文言文 现代文阅读（一） 现代文阅读（二） 综合 作文初中预备初一期末初二期末初三一模初三二模 班级1234567891011121314考试学校班级各科平均分与校、区的比较（折线图+柱状图+双轴）：科目 排名 班级平均分 学校平均分 区平均分语文数学英语物理化学总分考试学校班级科目知识块得分率与校、区的比较（雷达图）：类别 默写 课内古诗 课内文言文 课外文言文 现代文阅读（一） 现代文阅读（二） 综合 作文班级学校区","tags":[{"name":"工作整理","slug":"工作整理","permalink":"http://yoursite.com/tags/工作整理/"}]},{"title":"总结：20180429~20180505","date":"2018-05-05T09:00:00.000Z","path":"2018/05/05/summary20180505/","text":"123servlet的学习word的xml格式的解析（表格、图表、图片）复合模式（Compound Pattern） servlet的学习12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152531.建立一个一个继承HttpServlet的类public class Encode extends HttpServlet &#123; private static final long serialVersionUID = 1L; @Override public void init() throws ServletException &#123; &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; &#125;&#125;2.在web.xml中添加配置&lt;servlet&gt; &lt;servlet-name&gt;encode&lt;/servlet-name&gt; &lt;servlet-class&gt;top.leagle.servlet1.Encode&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;encode&lt;/servlet-name&gt; &lt;url-pattern&gt;/encode&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;3.可以通过网页或url访问&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;GET 请求&lt;/h2&gt; &lt;form action=&quot;encode&quot; method=&quot;GET&quot; target=&quot;_blank&quot;&gt; 网址名：&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt; &lt;/form&gt; &lt;h2&gt;POST 请求&lt;/h2&gt; &lt;form action=&quot;encode&quot; method=&quot;POST&quot; target=&quot;_blank&quot;&gt; 网址名：&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; word的xml格式的解析（表格、图表、图片）word的xml格式的解析 复合模式（Compound Pattern）1把多种设计模式结合起来解决一个问题。典型的就是MVC复合模式 其他看了看html看了看JavaScript看了看css","tags":[{"name":"java 基础","slug":"java-基础","permalink":"http://yoursite.com/tags/java-基础/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"},{"name":"servlet","slug":"servlet","permalink":"http://yoursite.com/tags/servlet/"}]},{"title":"word的xml格式的解析","date":"2018-05-05T04:00:00.000Z","path":"2018/05/05/analysisOfXmlOfWord/","text":"项目背景1234567891011121314151617181920212223242526最近一直在做这样一件事情： 1.从别人的数据库把数据拷贝到自己的数据库里 2.处理数据 3.生成一些表格、图片和图表 4.生成一些word报告 注： （1）这些数据包括49所学校的 （2）图中图表和表格数据是放在excel中的，图片是单独存在的 （3）生成49份报告怎么生成49份报告呢？ 1.人工把图片、excel里面的图表和表格数据放到一份word中，作为一个模板 2.找出需要替换的地方，用程序生成其他的48份学校报告 替换那些内容呢？ 1.文字替换 2.表格内所有内容替换 3.图片替换。 3.图表的标题、数据、x轴上的标签和图例替换 怎么找出需要替换的地方呢？ 把word另存为xml文件，根据xml节点替换内容怎么去分析这份xml文件呢？ 下面的内容会告诉你。 word的xml文件下面的这张图片是Word的内容，其中有一行文字、一个表格、两张图表。其中第一张图表是柱状图、第二张是一张组合图，左边y轴是柱状图的坐标，右边y轴是折线图的坐标。 下面的内容是Word转为xml格式后的内容，由于内容太多，我只展现主要内容 这是整体结构，根节点是package，其孩子节点都是part，属性name的值不一样。 xml文件详解文字的位置 1234567891011上面的图片内容可以简化成下面内容：&lt;pkg:part pkg:name=&quot;/word/document.xml&quot;&gt; &lt;pkg:xmlData&gt; &lt;w:document &gt; &lt;w:body&gt; &lt;/w:body&gt; &lt;/w:document&gt; &lt;/pkg:xmlData&gt;&lt;/pkg:part&gt;Word文档所有的内容都在这个body里面 而第一行的文字就在第一个p节点下的r节点下的t节点，有时候它会把一段文字拆分成好几段放在r节点下。 表格的位置 123456789101112131415161718192021222324252627282930313233343536373839在body下面有一个tbl节点，这个节点下面包含了表格里面所有的内容上面的图片可以简化为下面的节点&lt;w:tbl&gt; &lt;w:tr&gt; &lt;w:tc&gt;&lt;/w:tc&gt; &lt;w:tc&gt;&lt;/w:tc&gt; &lt;w:tc&gt;&lt;/w:tc&gt; &lt;w:tc&gt;&lt;/w:tc&gt; &lt;w:tc&gt;&lt;/w:tc&gt; &lt;/w:tr&gt; &lt;w:tr&gt; &lt;w:tc&gt;&lt;/w:tc&gt; &lt;w:tc&gt;&lt;/w:tc&gt; &lt;w:tc&gt;&lt;/w:tc&gt; &lt;w:tc&gt;&lt;/w:tc&gt; &lt;w:tc&gt;&lt;/w:tc&gt; &lt;/w:tr&gt; &lt;w:tr&gt; &lt;w:tc&gt;&lt;/w:tc&gt; &lt;w:tc&gt;&lt;/w:tc&gt; &lt;w:tc&gt;&lt;/w:tc&gt; &lt;w:tc&gt;&lt;/w:tc&gt; &lt;w:tc&gt;&lt;/w:tc&gt; &lt;/w:tr&gt; &lt;w:tr&gt; &lt;w:tc&gt;&lt;/w:tc&gt; &lt;w:tc&gt;&lt;/w:tc&gt; &lt;w:tc&gt;&lt;/w:tc&gt; &lt;w:tc&gt;&lt;/w:tc&gt; &lt;w:tc&gt;&lt;/w:tc&gt; &lt;/w:tr&gt;&lt;/w:tbl&gt;这个表格有四行五列，xml里面有4个tr，每个tr下面有5个tc 这个图片展示了一个tr下面的内容，可以看出每个小方块的内容在tc节点下，p节点下，r节点下，t节点下。 图片的位置 123451.图片是放在p节点下，drawing节点下。2.根据docPr节点的name中的内容“图片 1”，知道它是一张图片3.根据rId4去第二张图片的Relationship节点找到Target节点 其内容为&quot;media/image1.jpeg&quot;4.把target的内容前加上“/word/”变成“/word/media/image1.jpeg” 找到这个part，如第三张图5.在binaryData节点下就是这张图片的内容，它是用BASE64编码的。 第一个图表的位置（以行绘制图表）第一行数据是x轴的上标签剩余行的数据是图标中真实的数据 123456781.找图表的位置和找图片的位置是一样，不同的就是图表的docPr节点下面的内容是以“图表”开头的。2.还有一点不一样的是，图表有两部分part &lt;pkg:part pkg:name=&quot;/word/charts/_rels/chart1.xml.rels&quot;&gt; &lt;pkg:part pkg:name=&quot;/word/charts/chart1.xml&quot;&gt; 第一个part是外部链接，这个图表是通过外部的excel里面复制过来的 第二个part是图表的真正内容。3.图表的内容在chart节点下面 上面是标题的位置 每一个ser节点都是每一行数据 第一个数据是这一行数据的第一个数据cat下面的是x轴上的标签值（也就是第一行的数据）val下面的是第一行剩下的数据 第一个图表的位置（以列绘制图表）第一列数据是x轴的上标签剩余列的数据是图标中真实的数据 这是组合图，所以里面有两种图表 折线图的数据是第二列的数据（第一列为x轴上的标签）这些数据都是按照列来分布的。 总的来说1231.所有的内容都在body下面2.文字和表格内容直接放在body下面3.图片和图表先把声明放到p节点下面，实现在外部 动态添加图表1234567891.添加p节点下面的声明部分2.添加&lt;Relationship Id=&quot;rId5&quot; Target=&quot;charts/chart1.xml&quot; /&gt;3.添加 &lt;pkg:part pkg:name=&quot;/word/charts/_rels/chart1.xml.rels&quot;&gt;这部分内容只要存在即可，不需要真实性4 添加&lt;pkg:part pkg:name=&quot;/word/charts/chart1.xml&quot;&gt;注：（1）其中p节点下id和relationship的id是一样的（2）relationship的target和part中的name是一样的（3）id是唯一的，target是唯一的","tags":[{"name":"word","slug":"word","permalink":"http://yoursite.com/tags/word/"},{"name":"xml","slug":"xml","permalink":"http://yoursite.com/tags/xml/"},{"name":"模板","slug":"模板","permalink":"http://yoursite.com/tags/模板/"}]},{"title":"总结：20180422~20180428","date":"2018-04-28T09:00:00.000Z","path":"2018/04/28/summary20180428/","text":"12345678stack中的peep和popJava Web中常见乱码问题的分析与解决迭代器模式（Iterator Pattern）组合模式（Composite Pattern）代理模式（Proxy Pattern）MNIST手写数字识别CIFAR-10图像识别IMDb电影评论情感分析 stack中的peep和pop12相同点：大家都返回栈顶的值。不同点：peek 不改变栈的值(不删除栈顶的值)，pop会把栈顶的值删除。 Java Web中常见乱码问题的分析与解决123456789101112131415161718192021222324252627282930313233343536373839Java Web中出现乱码的现象:第一类：前台参数传输至服务端后乱码 1. get请求参数中文发送到服务器端乱码 2. post请求参数中文发送到服务器乱码第二类：服务端响应到达浏览器后乱码 3. 在jsp页面中，中文显示乱码 Java Web中出现的各种编码：Jsp文件中会出现下面所示的编码指定方式：&lt;%@ page language=“java” contentType=“text/html; charset=UTF-8″ pageEncoding=“UTF-8″%&gt;&lt;meta http-equiv=“Content-Type” content=“text/html; charset=UTF-8″&gt;1.pageEncoding=&quot;utf-8&quot; --该jsp文件自身采用的编码格式，也就是告诉服务器使用什么编码翻译jsp文件成java文件。jsp中post表单的编码由pageEncoding和contentType参数决定，以pageEncoding为准，如果没有pageEncoding则以contentType为准，如果没有contentType以Meta标签中的charset为准，都没有则以ISO-8859-1编码2.contentType=&quot;text/html;charset=utf-8&quot;服务器发送浏览器的数据类型和内容编码。其中charset=&quot;utf-8&quot;。3.Meta标签中的charset是在contentType未指定编码时采用的默认编码格式Tomcat读取JSP文件时采用的编码：第一种Tomcat返回响应时采用的编码：第二种浏览器显示HTML时采用的编码：浏览器的编码格式的设置get请求参数乱码： 1.String name = req.getParameter(&quot;name&quot;); name = new String(name.getBytes(&quot;iso-8859-1&quot;), &quot;utf-8&quot;); 2.server.xml 设置URIEncoding &lt;Connector URIEncoding=&quot;UTF-8&quot; connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&gt;post请求参数乱码： 1.String name = req.getParameter(&quot;name&quot;); name = new String(name.getBytes(&quot;iso-8859-1&quot;), &quot;utf-8&quot;); 2.在调用getParameter方法之前调用： req.setCharacterEncoding(&quot;UTF-8&quot;); PrintWriter的乱码问题： 设置ContentType即可 resp.setContentType(&quot;text/html;charset=UTF-8&quot;); 参考Java Web中常见乱码问题的分析与解决 设计模式迭代器模式（Iterator Pattern）1给数组或列表提供统一的输出接口 组合模式（Composite Pattern）1像一颗树一样，一个节点可以包含几个孩子节点，一个节点也可以是一个孩子节点 状态模式（State Pattern）1每一种状态是一个类，这些状态继承同一个接口，不同的状态实现不同的方法 代理模式（Proxy Pattern）1复制一个类，对这个类进行代理，开放某些方法或关闭某些方法 MNIST手写数字识别Keras多层感知器识别手写数字12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182from keras.utils import np_utilsfrom keras.datasets import mnistimport matplotlib.pyplot as pltfrom keras.models import Sequentialfrom keras.layers import Densefrom keras.layers import Dropoutimport pandas as pddef plot_image(image): fig = plt.gcf() fig.set_size_inches(2, 2) plt.imshow(image, cmap=&apos;binary&apos;) plt.show()def plot_images_labels_prediction(images, labels, prediction, idx, num=10): fig = plt.gcf() fig.set_size_inches(12, 14) if num &gt; 25: num = 25 for i in range(num): ax = plt.subplot(5, 5, 1 + i) ax.imshow(images[idx], cmap=&apos;binary&apos;) title = &quot;label=&quot; + str(labels[idx]) if len(prediction) &gt; 0: title += &quot;, predict=&quot; + str(prediction[idx]) ax.set_title(title, fontsize=10) ax.set_xticks([]) ax.set_yticks([]) idx += 1 plt.show()def show_train_history(train_history, train, validation): plt.plot(train_history.history[train]) plt.plot(train_history.history[validation]) plt.title(&apos;Train History&apos;) plt.ylabel(train) plt.xlabel(&apos;Epoch&apos;) plt.legend([&apos;train&apos;, &apos;validation&apos;], loc=&apos;upper left&apos;) plt.show()(x_train_image, y_train_label), (x_test_image, y_test_label) = mnist.load_data()plot_images_labels_prediction(x_train_image, y_train_label, [], 0)x_train = x_train_image.reshape(60000, 784).astype(&apos;float32&apos;)x_test = x_test_image.reshape(10000, 784).astype(&apos;float32&apos;)x_train_normalize = x_train / 255x_test_normalize = x_test / 255y_trainOneHot = np_utils.to_categorical(y_train_label)y_testOneHot = np_utils.to_categorical(y_test_label)model = Sequential()model.add(Dense(units=256, input_dim=784, kernel_initializer=&apos;normal&apos;, activation=&apos;relu&apos;))model.add(Dropout(0.5))model.add(Dense(units=10, kernel_initializer=&apos;normal&apos;, activation=&apos;softmax&apos;))# print(model.summary())model.compile(loss=&apos;categorical_crossentropy&apos;, optimizer=&apos;adam&apos;, metrics=[&apos;accuracy&apos;])train_history = model.fit(x=x_train_normalize, y=y_trainOneHot, validation_split=0.2, epochs=10, batch_size=200, verbose=2)show_train_history(train_history, &apos;acc&apos;, &apos;val_acc&apos;)# show_train_history(train_history, &apos;loss&apos;, &apos;val_loss&apos;)scores = model.evaluate(x_test_normalize, y_testOneHot)print(&apos;accuracy=&apos;, scores[1])prediction = model.predict_classes(x_test_normalize)# plot_images_labels_prediction(x_test_image, y_test_label, prediction, idx=340)df = pd.crosstab(y_test_label, prediction, colnames=[&apos;predict&apos;], rownames=[&apos;label&apos;])print(df)# df = pd.DataFrame(&#123;&apos;label&apos;: y_test_label, &apos;predict&apos;: prediction&#125;)# print(df) Keras卷积神经网络识别手写数字12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485from keras.utils import np_utilsfrom keras.datasets import mnistimport matplotlib.pyplot as pltfrom keras.models import Sequentialfrom keras.layers import Dropout, Dense, Flatten, Conv2D, MaxPooling2Dimport pandas as pddef plot_image(image): fig = plt.gcf() fig.set_size_inches(2, 2) plt.imshow(image, cmap=&apos;binary&apos;) plt.show()def plot_images_labels_prediction(images, labels, prediction, idx, num=10): fig = plt.gcf() fig.set_size_inches(12, 14) if num &gt; 25: num = 25 for i in range(num): ax = plt.subplot(5, 5, 1 + i) ax.imshow(images[idx], cmap=&apos;binary&apos;) title = &quot;label=&quot; + str(labels[idx]) if len(prediction) &gt; 0: title += &quot;, predict=&quot; + str(prediction[idx]) ax.set_title(title, fontsize=10) ax.set_xticks([]) ax.set_yticks([]) idx += 1 plt.show()def show_train_history(train_history, train, validation): plt.plot(train_history.history[train]) plt.plot(train_history.history[validation]) plt.title(&apos;Train History&apos;) plt.ylabel(train) plt.xlabel(&apos;Epoch&apos;) plt.legend([&apos;train&apos;, &apos;validation&apos;], loc=&apos;upper left&apos;) plt.show()(x_train, y_train), (x_test, y_test) = mnist.load_data()# plot_images_labels_prediction(x_train, y_train, [], 0)x_train4D = x_train.reshape(x_train.shape[0], 28, 28, 1).astype(&apos;float32&apos;)x_test4D = x_test.reshape(x_test.shape[0], 28, 28, 1).astype(&apos;float32&apos;)x_train4D_normalize = x_train4D / 255x_test4D_normalize = x_test4D / 255y_trainOneHot = np_utils.to_categorical(y_train)y_testOneHot = np_utils.to_categorical(y_test)model = Sequential()model.add(Conv2D(filters=16, kernel_size=(5, 5), padding=&apos;same&apos;, input_shape=(28, 28, 1), activation=&apos;relu&apos;))model.add(MaxPooling2D(pool_size=(2, 2)))model.add(Conv2D(filters=36, kernel_size=(5, 5), padding=&apos;same&apos;, activation=&apos;relu&apos;))model.add(MaxPooling2D(pool_size=(2, 2)))model.add(Flatten())model.add(Dense(units=128, activation=&apos;relu&apos;))model.add(Dropout(0.5))model.add(Dense(units=10, activation=&apos;softmax&apos;))# print(model.summary())model.compile(loss=&apos;categorical_crossentropy&apos;, optimizer=&apos;adam&apos;, metrics=[&apos;accuracy&apos;])train_history = model.fit(x=x_train4D_normalize, y=y_trainOneHot, validation_split=0.2, epochs=3, batch_size=300, verbose=2)show_train_history(train_history, &apos;acc&apos;, &apos;val_acc&apos;)# show_train_history(train_history, &apos;loss&apos;, &apos;val_loss&apos;)scores = model.evaluate(x_test4D_normalize, y_testOneHot)print(&apos;accuracy=&apos;, scores[1])prediction = model.predict_classes(x_test4D_normalize)plot_images_labels_prediction(x_test, y_test, prediction, idx=0)df = pd.crosstab(y_test, prediction, colnames=[&apos;predict&apos;], rownames=[&apos;label&apos;])print(df)# df = pd.DataFrame(&#123;&apos;label&apos;: y_test, &apos;predict&apos;: prediction&#125;)# print(df) TensorFlow多层感知器识别手写数字123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116import tensorflow as tfimport numpy as npimport matplotlib.pyplot as pltimport tensorflow.examples.tutorials.mnist.input_data as input_datafrom time import timedef plot_image(image): fig = plt.gcf() fig.set_size_inches(2, 2) plt.imshow(image.reshape(28, 28), cmap=&apos;binary&apos;) plt.show()def plot_images_labels_prediction(images, labels, prediction, idx, num=10): fig = plt.gcf() fig.set_size_inches(12, 14) if num &gt; 25: num = 25 for i in range(num): ax = plt.subplot(5, 5, 1 + i) ax.imshow(np.reshape(images[idx], (28, 28)), cmap=&apos;binary&apos;) title = &quot;label=&quot; + str(np.argmax(labels[idx])) if len(prediction) &gt; 0: title += &quot;, predict=&quot; + str(prediction[idx]) ax.set_title(title, fontsize=10) ax.set_xticks([]) ax.set_yticks([]) idx += 1 plt.show()def layer(output_dim, input_dim, inputs, activation=None): w = tf.Variable(tf.random_normal([input_dim, output_dim])) b = tf.Variable(tf.random_normal([1, output_dim])) xwb = tf.matmul(inputs, w) + b if activation is None: outputs = xwb else: outputs = activation(xwb) return outputsdef show_train_history(epoch_list, outcome_list, lable): fig = plt.gcf() fig.set_size_inches(4, 2) plt.plot(epoch_list, outcome_list, label=lable) plt.ylabel(lable) plt.ylabel(&apos;epoch&apos;) plt.legend([lable], loc=&apos;upper left&apos;) plt.show()mnist = input_data.read_data_sets(&quot;MNIST_data/&quot;, one_hot=True)# print(&apos;train&apos;, mnist.train.num_examples)# print(&apos;validation&apos;, mnist.validation.num_examples)# print(&apos;test&apos;, mnist.test.num_examples)# print(&apos;train images&apos;, mnist.train.images.shape)# print(&apos;train labels&apos;, mnist.train.labels.shape)# plot_image(mnist.train.images[0])# plot_images_labels_prediction(mnist.train.images, mnist.train.labels, [], 0, num=10)x = tf.placeholder(&quot;float&quot;, [None, 784])h1 = layer(output_dim=256, input_dim=784, inputs=x, activation=tf.nn.relu)y_predict = layer(output_dim=10, input_dim=256, inputs=h1, activation=None)y_label = tf.placeholder(&quot;float&quot;, [None, 10])loss_function = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(logits=y_predict, labels=y_label))optimizer = tf.train.AdamOptimizer(learning_rate=0.001).minimize(loss_function)correct_prediction = tf.equal(tf.argmax(y_label, 1), tf.argmax(y_predict, 1))accuracy = tf.reduce_mean(tf.cast(correct_prediction, &quot;float&quot;))trainEpochs = 15batchSize = 100totalBatchs = int(mnist.train.num_examples / batchSize)loss_list = []epoch_list = []accuracy_list = []startTime = time()sess = tf.Session()sess.run(tf.global_variables_initializer())for epoch in range(trainEpochs): for i in range(totalBatchs): batch_x, batch_y = mnist.train.next_batch(batchSize) sess.run(optimizer, feed_dict=&#123;x: batch_x, y_label: batch_y&#125;) loss, acc = sess.run([loss_function, accuracy], feed_dict=&#123;x: mnist.validation.images, y_label: mnist.validation.labels&#125;) epoch_list.append(epoch) loss_list.append(loss) accuracy_list.append(acc) print(&quot;Train Epoch: %02d Loos= %f Accuracy=%f&quot; % (epoch + 1, loss, acc))duration = time() - startTimeprint(&quot;Train Finished takes:&quot;, duration)show_train_history(epoch_list, loss_list, &apos;loss&apos;)show_train_history(epoch_list, accuracy_list, &apos;accuracy&apos;)print(&apos;Accuracy:&apos;, sess.run(accuracy, feed_dict=&#123;x: mnist.test.images, y_label: mnist.test.labels&#125;))prediction_result = sess.run(tf.argmax(y_predict, 1), feed_dict=&#123;x: mnist.test.images&#125;)plot_images_labels_prediction(mnist.test.images, mnist.test.labels, prediction_result, 0, num=10) TensorFlow卷积神经网络识别手写数字123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152import tensorflow as tfimport numpy as npimport matplotlib.pyplot as pltimport tensorflow.examples.tutorials.mnist.input_data as input_datafrom time import timedef plot_image(image): fig = plt.gcf() fig.set_size_inches(2, 2) plt.imshow(image.reshape(28, 28), cmap=&apos;binary&apos;) plt.show()def plot_images_labels_prediction(images, labels, prediction, idx, num=10): fig = plt.gcf() fig.set_size_inches(12, 14) if num &gt; 25: num = 25 for i in range(num): ax = plt.subplot(5, 5, 1 + i) ax.imshow(np.reshape(images[idx], (28, 28)), cmap=&apos;binary&apos;) title = &quot;label=&quot; + str(np.argmax(labels[idx])) if len(prediction) &gt; 0: title += &quot;, predict=&quot; + str(prediction[idx]) ax.set_title(title, fontsize=10) ax.set_xticks([]) ax.set_yticks([]) idx += 1 plt.show()def show_train_history(epoch_list, outcome_list, lable): fig = plt.gcf() fig.set_size_inches(4, 2) plt.plot(epoch_list, outcome_list, label=lable) plt.ylabel(lable) plt.ylabel(&apos;epoch&apos;) plt.legend([lable], loc=&apos;upper left&apos;) plt.show()def weight(shape): return tf.Variable(tf.truncated_normal(shape, stddev=0.1), name=&apos;W&apos;)def bias(shape): return tf.Variable(tf.constant(0.1, shape=shape), name=&apos;b&apos;)def conv2d(x, W): return tf.nn.conv2d(x, W, strides=[1, 1, 1, 1], padding=&apos;SAME&apos;)def max_pool_2x2(x): return tf.nn.max_pool(x, ksize=[1, 2, 2, 1], strides=[1, 2, 2, 1], padding=&apos;SAME&apos;)mnist = input_data.read_data_sets(&quot;MNIST_data/&quot;, one_hot=True)# print(&apos;train&apos;, mnist.train.num_examples)# print(&apos;validation&apos;, mnist.validation.num_examples)# print(&apos;test&apos;, mnist.test.num_examples)# print(&apos;train images&apos;, mnist.train.images.shape)# print(&apos;train labels&apos;, mnist.train.labels.shape)# plot_image(mnist.train.images[0])# plot_images_labels_prediction(mnist.train.images, mnist.train.labels, [], 0, num=10)with tf.name_scope(&apos;Input_layer&apos;): x = tf.placeholder(&quot;float&quot;, [None, 784]) x_image = tf.reshape(x, [-1, 28, 28, 1])with tf.name_scope(&apos;C1_Conv&apos;): W1 = weight([5, 5, 1, 16]) b1 = bias([16]) Conv1 = conv2d(x_image, W1) + b1 C1_Conv = tf.nn.relu(Conv1)with tf.name_scope(&apos;C1_Pool&apos;): C1_Pool = max_pool_2x2(C1_Conv)with tf.name_scope(&apos;C2_Conv&apos;): W2 = weight([5, 5, 16, 36]) b2 = bias([36]) Conv2 = conv2d(C1_Pool, W2) + b2 C2_Conv = tf.nn.relu(Conv2)with tf.name_scope(&apos;C2_Pool&apos;): C2_Pool = max_pool_2x2(C2_Conv)with tf.name_scope(&apos;D_Flat&apos;): D_Flat = tf.reshape(C2_Pool, [-1, 1764])with tf.name_scope(&apos;D_Hidder_Layer&apos;): W3 = weight([1764, 128]) b3 = bias([128]) D_Hidden = tf.nn.relu(tf.matmul(D_Flat, W3) + b3) D_Hidden_Dropout = tf.nn.dropout(D_Hidden, keep_prob=0.8)with tf.name_scope(&apos;Output_Layer&apos;): W4 = weight([128, 10]) b4 = bias([10]) y_predict = tf.nn.softmax(tf.matmul(D_Hidden_Dropout, W4) + b4)with tf.name_scope(&apos;optimizer&apos;): y_label = tf.placeholder(&quot;float&quot;, shape=[None, 10], name=&quot;y_label&quot;) loss_function = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(logits=y_predict, labels=y_label)) optimizer = tf.train.AdamOptimizer(learning_rate=0.001).minimize(loss_function)with tf.name_scope(&apos;evaluate_model&apos;): correct_prediction = tf.equal(tf.argmax(y_label, 1), tf.argmax(y_predict, 1)) accuracy = tf.reduce_mean(tf.cast(correct_prediction, &quot;float&quot;))trainEpochs = 15batchSize = 100totalBatchs = int(mnist.train.num_examples / batchSize)loss_list = []epoch_list = []accuracy_list = []startTime = time()sess = tf.Session()sess.run(tf.global_variables_initializer())for epoch in range(trainEpochs): for i in range(totalBatchs): batch_x, batch_y = mnist.train.next_batch(batchSize) sess.run(optimizer, feed_dict=&#123;x: batch_x, y_label: batch_y&#125;) loss, acc = sess.run([loss_function, accuracy], feed_dict=&#123;x: mnist.validation.images, y_label: mnist.validation.labels&#125;) epoch_list.append(epoch) loss_list.append(loss) accuracy_list.append(acc) print(&quot;Train Epoch: %02d Loos= %f Accuracy=%f&quot; % (epoch + 1, loss, acc))duration = time() - startTimeprint(&quot;Train Finished takes:&quot;, duration)show_train_history(epoch_list, loss_list, &apos;loss&apos;)show_train_history(epoch_list, accuracy_list, &apos;accuracy&apos;)print(&apos;Accuracy:&apos;, sess.run(accuracy, feed_dict=&#123;x: mnist.test.images, y_label: mnist.test.labels&#125;))prediction_result = sess.run(tf.argmax(y_predict, 1), feed_dict=&#123;x: mnist.test.images&#125;)plot_images_labels_prediction(mnist.test.images, mnist.test.labels, prediction_result, 0, num=10) CIFAR-10图像识别Keras卷积神经网络识别CIFAR-10图像123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110from keras.utils import np_utilsfrom keras.datasets import cifar10import matplotlib.pyplot as pltfrom keras.models import Sequentialfrom keras.layers import Dropout, Dense, Flatten, Conv2D, MaxPooling2Dimport pandas as pdlabel_dict = &#123; 0: &quot;airplane&quot;, 1: &quot;automobile&quot;, 2: &quot;bird&quot;, 3: &quot;cat&quot;, 4: &quot;deer&quot;, 5: &quot;dog&quot;, 6: &quot;frog&quot;, 7: &quot;horse&quot;, 8: &quot;ship&quot;, 9: &quot;truck&quot;&#125;def plot_image(image): fig = plt.gcf() fig.set_size_inches(2, 2) plt.imshow(image, cmap=&apos;binary&apos;) plt.show()def plot_images_labels_prediction(images, labels, prediction, idx, num=10): fig = plt.gcf() fig.set_size_inches(12, 14) if num &gt; 25: num = 25 for i in range(num): ax = plt.subplot(5, 5, 1 + i) ax.imshow(images[idx], cmap=&apos;binary&apos;) title = &quot;l=&quot; + label_dict[labels[i][0]] if len(prediction) &gt; 0: title += &quot;, p=&quot; + label_dict[labels[i][0]] ax.set_title(title, fontsize=10) ax.set_xticks([]) ax.set_yticks([]) idx += 1 plt.show()def show_train_history(train_history, train, validation): plt.plot(train_history.history[train]) plt.plot(train_history.history[validation]) plt.title(&apos;Train History&apos;) plt.ylabel(train) plt.xlabel(&apos;Epoch&apos;) plt.legend([&apos;train&apos;, &apos;validation&apos;], loc=&apos;upper left&apos;) plt.show()def show_predicted_probability(y_test, prediction, x_test, predicted_probability, i): print(&apos;lable: &apos;, label_dict[y_test[i][0]], &apos;predict: &apos;, label_dict[prediction[i]]) # plt.figure(figsize=(2, 2)) # plt.imshow(np.reshape(x_test[i], (32, 32, 3))) # plt.show() for j in range(10): print(label_dict[j] + &apos; Probability:%1.9f&apos; % (predicted_probability[i][j]))(x_train, y_train), (x_test, y_test) = cifar10.load_data()# plot_images_labels_prediction(x_train, y_train, [], 0)x_train_normalize = x_train.astype(&apos;float32&apos;) / 255.0x_test_normalize = x_test.astype(&apos;float32&apos;) / 255.0y_trainOneHot = np_utils.to_categorical(y_train)y_testOneHot = np_utils.to_categorical(y_test)model = Sequential()model.add(Conv2D(filters=32, kernel_size=(3, 3), padding=&apos;same&apos;, input_shape=(32, 32, 3), activation=&apos;relu&apos;))model.add(Dropout(0.25))model.add(MaxPooling2D(pool_size=(2, 2)))model.add(Conv2D(filters=64, kernel_size=(3, 3), padding=&apos;same&apos;, activation=&apos;relu&apos;))model.add(Dropout(0.25))model.add(MaxPooling2D(pool_size=(2, 2)))model.add(Flatten())model.add(Dropout(0.25))model.add(Dense(units=1024, activation=&apos;relu&apos;))model.add(Dropout(0.25))model.add(Dense(units=10, activation=&apos;softmax&apos;))# print(model.summary())model.compile(loss=&apos;categorical_crossentropy&apos;, optimizer=&apos;adam&apos;, metrics=[&apos;accuracy&apos;])try: model.load_weights(&quot;saveModel/cifarCnnModel.h5&quot;) print(&quot;加载模型成功！继续训练模型&quot;)except: print(&quot;加载模型失败！开始训练一个新模型&quot;)train_history = model.fit(x=x_train_normalize, y=y_trainOneHot, validation_split=0.2, epochs=1, batch_size=128, verbose=2)show_train_history(train_history, &apos;acc&apos;, &apos;val_acc&apos;)# show_train_history(train_history, &apos;loss&apos;, &apos;val_loss&apos;)scores = model.evaluate(x_test_normalize, y_testOneHot)print(&apos;accuracy=&apos;, scores[1])prediction = model.predict_classes(x_test_normalize)predicted_probability = model.predict(x_test_normalize)show_predicted_probability(y_test, prediction, x_test, predicted_probability, 0)plot_images_labels_prediction(x_test, y_test, prediction, idx=0)df = pd.crosstab(y_test.reshape(-1), prediction, colnames=[&apos;predict&apos;], rownames=[&apos;label&apos;])print(df)# df = pd.DataFrame(&#123;&apos;label&apos;: y_test, &apos;predict&apos;: prediction&#125;)# print(df)model.save_weights(&quot;saveModel/cifarCnnModel.h5&quot;) IMDb电影评论情感分析Keras多层感知模型情感分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144import urllib.requestimport osimport tarfilefrom keras.preprocessing import sequencefrom keras.preprocessing.text import Tokenizerfrom keras.models import Sequentialfrom keras.layers import Dense, Dropout, Flattenfrom keras.layers.embeddings import Embeddingimport numpy as npimport resentiment_dict = &#123;1: &apos;正面的&apos;, 0: &apos;负面的&apos;&#125;url = &quot;http://ai.stanford.edu/~amaas/data/sentiment/aclImdb_v1.tar.gz&quot;filepath = &quot;data/aclImdb_v1.tar.gz&quot;if not os.path.isfile(filepath): result = urllib.request.urlretrieve(url, filepath) print(&apos;downloaded:&apos;, result)if not os.path.exists(&quot;data/aclImdb&quot;): tfile = tarfile.open(&quot;data/aclImdb_v1.tar.gz&quot;, &apos;r:gz&apos;) result = tfile.extractall(&apos;data/&apos;)def rm_tags(text): re_tag = re.compile(r&apos;&lt;[^&gt;]+&gt;&apos;) return re_tag.sub(&apos;&apos;, text)def read_files(filetype): path = &quot;data/aclImdb/&quot; file_list = [] positive_path = path + filetype + &quot;/pos/&quot; for f in os.listdir(positive_path): file_list += [positive_path + f] negative_path = path + filetype + &quot;/neg/&quot; for f in os.listdir(negative_path): file_list += [negative_path + f] print(&apos;read&apos;, filetype, &apos;files:&apos;, len(file_list)) all_labels = ([1] * 12500 + [0] * 12500) all_texts = [] for fi in file_list: with open(fi, encoding=&apos;utf-8&apos;) as file_input: all_texts += [rm_tags(&quot; &quot;.join(file_input.readlines()))] return all_labels, all_textsdef display_test_sentiment(i, test_text, y_test, predict_classes): print(test_text[i]) print(&apos;真实值: &apos;, sentiment_dict[y_test[i]], &apos; 预测结果: &apos;, sentiment_dict[predict_classes[i]])def predict_review(token, model, real_result, input_text): input_seq = token.texts_to_sequences([input_text]) pad_input_seq = sequence.pad_sequences(input_seq, maxlen=100) predict_result = model.predict_classes(pad_input_seq) print(input_text) print(&apos;真实值: &apos;, real_result, &apos; 预测结果: &apos;, sentiment_dict[predict_result[0][0]])y_train, train_text = read_files(&quot;train&quot;)y_test, test_text = read_files(&quot;test&quot;)# print(train_text[0])# print(y_train[0])# print(train_text[12501])# print(y_train[12501])token = Tokenizer(num_words=2000)token.fit_on_texts(train_text)# print(token.document_count)# print(token.word_index)x_train_seq = token.texts_to_sequences(train_text)x_test_seq = token.texts_to_sequences(test_text)# print(train_text[0])# print(x_train_seq[0])x_train = sequence.pad_sequences(x_train_seq, maxlen=100)x_test = sequence.pad_sequences(x_test_seq, maxlen=100)# print(x_train_seq[0])# print(x_train[0])# print(x_train_seq[1])# print(x_train[1])model = Sequential()model.add(Embedding(output_dim=32, input_dim=2000, input_length=100))model.add(Dropout(0.2))model.add(Flatten())model.add(Dense(units=256, activation=&apos;relu&apos;))model.add(Dropout(0.35))model.add(Dense(units=1, activation=&apos;sigmoid&apos;))# print(model.summary())model.compile(loss=&apos;binary_crossentropy&apos;, optimizer=&apos;adam&apos;, metrics=[&apos;accuracy&apos;])train_history = model.fit(x_train, np.array(y_train), validation_split=0.2, epochs=10, batch_size=100, verbose=2)scores = model.evaluate(x_test, np.array(y_test), verbose=1)print(scores[1])predict = model.predict_classes(x_test)print(predict[:10])predict_classes = predict.reshape(-1)print(predict_classes[:10])display_test_sentiment(1, test_text, y_test, predict_classes)display_test_sentiment(12502, test_text, y_test, predict_classes)input_text = &quot;&quot;&quot;A fabulous movie, I enjoyed every moment. So beautifully done that I would watch it again. It&apos;s a true musical as they used to be. I cried and laughed, it brought out many emotions. It&apos;s a great family film. The artistry and special effects make a great Disney style fantasy come to life. The music and songs were very pleasant in typical Disney fashion.&quot;&quot;&quot;predict_review(token, model, sentiment_dict[1], input_text)input_text = &quot;&quot;&quot;I must say, Disney seems to be putting out live action movies of their successful cartoons just for the sake of putting out live action movies! I guess corporate thinking is the initial buzz will make it money on the first weekend! This is the worst of the live actions, the acting is boring, the story mundane, I do not care about the characters at all, it seems it&apos;s just made to show how cool Disney can use special effects! If you like the story, stick to the original cartoon!&quot;&quot;&quot;predict_review(token, model, sentiment_dict[0], input_text) Keras递归神经网络情感分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146import urllib.requestimport osimport tarfilefrom keras.preprocessing import sequencefrom keras.preprocessing.text import Tokenizerfrom keras.models import Sequentialfrom keras.layers import Dense, Dropoutfrom keras.layers.embeddings import Embeddingfrom keras.layers.recurrent import SimpleRNNimport numpy as npimport resentiment_dict = &#123;1: &apos;正面的&apos;, 0: &apos;负面的&apos;&#125;url = &quot;http://ai.stanford.edu/~amaas/data/sentiment/aclImdb_v1.tar.gz&quot;filepath = &quot;data/aclImdb_v1.tar.gz&quot;if not os.path.isfile(filepath): result = urllib.request.urlretrieve(url, filepath) print(&apos;downloaded:&apos;, result)if not os.path.exists(&quot;data/aclImdb&quot;): tfile = tarfile.open(&quot;data/aclImdb_v1.tar.gz&quot;, &apos;r:gz&apos;) result = tfile.extractall(&apos;data/&apos;)def rm_tags(text): re_tag = re.compile(r&apos;&lt;[^&gt;]+&gt;&apos;) return re_tag.sub(&apos;&apos;, text)def read_files(filetype): path = &quot;data/aclImdb/&quot; file_list = [] positive_path = path + filetype + &quot;/pos/&quot; for f in os.listdir(positive_path): file_list += [positive_path + f] negative_path = path + filetype + &quot;/neg/&quot; for f in os.listdir(negative_path): file_list += [negative_path + f] print(&apos;read&apos;, filetype, &apos;files:&apos;, len(file_list)) all_labels = ([1] * 12500 + [0] * 12500) all_texts = [] for fi in file_list: with open(fi, encoding=&apos;utf-8&apos;) as file_input: all_texts += [rm_tags(&quot; &quot;.join(file_input.readlines()))] return all_labels, all_textsdef display_test_sentiment(i, test_text, y_test, predict_classes): print(test_text[i]) print(&apos;真实值: &apos;, sentiment_dict[y_test[i]], &apos; 预测结果: &apos;, sentiment_dict[predict_classes[i]])def predict_review(token, model, real_result, input_text): input_seq = token.texts_to_sequences([input_text]) pad_input_seq = sequence.pad_sequences(input_seq, maxlen=100) predict_result = model.predict_classes(pad_input_seq) print(input_text) print(&apos;真实值: &apos;, real_result, &apos; 预测结果: &apos;, sentiment_dict[predict_result[0][0]])y_train, train_text = read_files(&quot;train&quot;)y_test, test_text = read_files(&quot;test&quot;)# print(train_text[0])# print(y_train[0])# print(train_text[12501])# print(y_train[12501])token = Tokenizer(num_words=2000)token.fit_on_texts(train_text)# print(token.document_count)# print(token.word_index)x_train_seq = token.texts_to_sequences(train_text)x_test_seq = token.texts_to_sequences(test_text)# print(train_text[0])# print(x_train_seq[0])x_train = sequence.pad_sequences(x_train_seq, maxlen=100)x_test = sequence.pad_sequences(x_test_seq, maxlen=100)# print(x_train_seq[0])# print(x_train[0])# print(x_train_seq[1])# print(x_train[1])model = Sequential()model.add(Embedding(output_dim=32, input_dim=2000, input_length=100))model.add(Dropout(0.2))model.add(SimpleRNN(units=16))model.add(Dense(units=256, activation=&apos;relu&apos;))model.add(Dropout(0.35))model.add(Dense(units=1, activation=&apos;sigmoid&apos;))# print(model.summary())model.compile(loss=&apos;binary_crossentropy&apos;, optimizer=&apos;adam&apos;, metrics=[&apos;accuracy&apos;])train_history = model.fit(x_train, np.array(y_train), validation_split=0.2, epochs=10, batch_size=100, verbose=2)scores = model.evaluate(x_test, np.array(y_test), verbose=1)print(scores[1])predict = model.predict_classes(x_test)# print(predict[:10])predict_classes = predict.reshape(-1)# print(predict_classes[:10])display_test_sentiment(1, test_text, y_test, predict_classes)display_test_sentiment(12502, test_text, y_test, predict_classes)input_text = &quot;&quot;&quot;A fabulous movie, I enjoyed every moment. So beautifully done that I would watch it again. It&apos;s a true musical as they used to be. I cried and laughed, it brought out many emotions. It&apos;s a great family film. The artistry and special effects make a great Disney style fantasy come to life. The music and songs were very pleasant in typical Disney fashion.&quot;&quot;&quot;predict_review(token, model, sentiment_dict[1], input_text)input_text = &quot;&quot;&quot;I must say, Disney seems to be putting out live action movies of their successful cartoons just for the sake of putting out live action movies! I guess corporate thinking is the initial buzz will make it money on the first weekend! This is the worst of the live actions, the acting is boring, the story mundane, I do not care about the characters at all, it seems it&apos;s just made to show how cool Disney can use special effects! If you like the story, stick to the original cartoon!&quot;&quot;&quot;predict_review(token, model, sentiment_dict[0], input_text) Keras长短期记忆网络情感分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146import urllib.requestimport osimport tarfilefrom keras.preprocessing import sequencefrom keras.preprocessing.text import Tokenizerfrom keras.models import Sequentialfrom keras.layers import Dense, Dropout, Activation, Flattenfrom keras.layers.embeddings import Embeddingfrom keras.layers.recurrent import LSTMimport numpy as npimport resentiment_dict = &#123;1: &apos;正面的&apos;, 0: &apos;负面的&apos;&#125;url = &quot;http://ai.stanford.edu/~amaas/data/sentiment/aclImdb_v1.tar.gz&quot;filepath = &quot;data/aclImdb_v1.tar.gz&quot;if not os.path.isfile(filepath): result = urllib.request.urlretrieve(url, filepath) print(&apos;downloaded:&apos;, result)if not os.path.exists(&quot;data/aclImdb&quot;): tfile = tarfile.open(&quot;data/aclImdb_v1.tar.gz&quot;, &apos;r:gz&apos;) result = tfile.extractall(&apos;data/&apos;)def rm_tags(text): re_tag = re.compile(r&apos;&lt;[^&gt;]+&gt;&apos;) return re_tag.sub(&apos;&apos;, text)def read_files(filetype): path = &quot;data/aclImdb/&quot; file_list = [] positive_path = path + filetype + &quot;/pos/&quot; for f in os.listdir(positive_path): file_list += [positive_path + f] negative_path = path + filetype + &quot;/neg/&quot; for f in os.listdir(negative_path): file_list += [negative_path + f] print(&apos;read&apos;, filetype, &apos;files:&apos;, len(file_list)) all_labels = ([1] * 12500 + [0] * 12500) all_texts = [] for fi in file_list: with open(fi, encoding=&apos;utf-8&apos;) as file_input: all_texts += [rm_tags(&quot; &quot;.join(file_input.readlines()))] return all_labels, all_textsdef display_test_sentiment(i, test_text, y_test, predict_classes): print(test_text[i]) print(&apos;真实值: &apos;, sentiment_dict[y_test[i]], &apos; 预测结果: &apos;, sentiment_dict[predict_classes[i]])def predict_review(token, model, real_result, input_text): input_seq = token.texts_to_sequences([input_text]) pad_input_seq = sequence.pad_sequences(input_seq, maxlen=100) predict_result = model.predict_classes(pad_input_seq) print(input_text) print(&apos;真实值: &apos;, real_result, &apos; 预测结果: &apos;, sentiment_dict[predict_result[0][0]])y_train, train_text = read_files(&quot;train&quot;)y_test, test_text = read_files(&quot;test&quot;)# print(train_text[0])# print(y_train[0])# print(train_text[12501])# print(y_train[12501])token = Tokenizer(num_words=2000)token.fit_on_texts(train_text)# print(token.document_count)# print(token.word_index)x_train_seq = token.texts_to_sequences(train_text)x_test_seq = token.texts_to_sequences(test_text)# print(train_text[0])# print(x_train_seq[0])x_train = sequence.pad_sequences(x_train_seq, maxlen=100)x_test = sequence.pad_sequences(x_test_seq, maxlen=100)# print(x_train_seq[0])# print(x_train[0])# print(x_train_seq[1])# print(x_train[1])model = Sequential()model.add(Embedding(output_dim=32, input_dim=2000, input_length=100))model.add(Dropout(0.2))model.add(LSTM(32))model.add(Dense(units=256, activation=&apos;relu&apos;))model.add(Dropout(0.35))model.add(Dense(units=1, activation=&apos;sigmoid&apos;))# print(model.summary())model.compile(loss=&apos;binary_crossentropy&apos;, optimizer=&apos;adam&apos;, metrics=[&apos;accuracy&apos;])train_history = model.fit(x_train, np.array(y_train), validation_split=0.2, epochs=10, batch_size=100, verbose=2)scores = model.evaluate(x_test, np.array(y_test), verbose=1)print(scores[1])predict = model.predict_classes(x_test)# print(predict[:10])predict_classes = predict.reshape(-1)# print(predict_classes[:10])display_test_sentiment(1, test_text, y_test, predict_classes)display_test_sentiment(12502, test_text, y_test, predict_classes)input_text = &quot;&quot;&quot;A fabulous movie, I enjoyed every moment. So beautifully done that I would watch it again. It&apos;s a true musical as they used to be. I cried and laughed, it brought out many emotions. It&apos;s a great family film. The artistry and special effects make a great Disney style fantasy come to life. The music and songs were very pleasant in typical Disney fashion.&quot;&quot;&quot;predict_review(token, model, sentiment_dict[1], input_text)input_text = &quot;&quot;&quot;I must say, Disney seems to be putting out live action movies of their successful cartoons just for the sake of putting out live action movies! I guess corporate thinking is the initial buzz will make it money on the first weekend! This is the worst of the live actions, the acting is boring, the story mundane, I do not care about the characters at all, it seems it&apos;s just made to show how cool Disney can use special effects! If you like the story, stick to the original cartoon!&quot;&quot;&quot;predict_review(token, model, sentiment_dict[0], input_text)","tags":[{"name":"java 基础","slug":"java-基础","permalink":"http://yoursite.com/tags/java-基础/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"},{"name":"识别手写字体","slug":"识别手写字体","permalink":"http://yoursite.com/tags/识别手写字体/"},{"name":"识别简单图片","slug":"识别简单图片","permalink":"http://yoursite.com/tags/识别简单图片/"},{"name":"电影评论分析","slug":"电影评论分析","permalink":"http://yoursite.com/tags/电影评论分析/"}]},{"title":"总结：20180415~20180421","date":"2018-04-21T09:00:00.000Z","path":"2018/04/21/summary20180421/","text":"123456789101112131415static 关键字类与继承final 关键字enum类型转换== 和 equal路由算法TensorFlow 和 keras适配器模式（adapter Pattern）命令模式（Adapter Pattern）装饰者模式（Decorator Pattern）外观模式（Facade Pattern）工厂模式（Factory Pattern）单例模式（Singleton Pattern）模板模式（Template Pattern） static 关键字123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128static方法内部不能调用非静态方法。静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。class Base &#123; static &#123; System.out.println(&quot;base static&quot;); &#125; public Base() &#123; System.out.println(&quot;base constructor&quot;); &#125;&#125;public class StaticTest2 extends Base &#123; static &#123; System.out.println(&quot;test static&quot;); &#125; public StaticTest2() &#123; System.out.println(&quot;staticTest2 constructor&quot;); &#125; @Test public void test1() &#123; new StaticTest2(); &#125;&#125;输出：base statictest staticbase constructorstaticTest2 constructorbase constructorstaticTest2 constructor解释：先加载StaticTest2类，而在加载StaticTest2类的时候发现StaticTest2类继承自Base类。因此会转去先加载Base类，在加载Base类的时候，发现有static块，便执行了static块。在Base类加载完成之后，便继续加载Test类，然后发现StaticTest2类中也有static块，便执行static块。在加载完所需的类之后，便开始执行main方法。在main方法中执行newStaticTest2()的时候会先调用父类的构造器，然后再调用自身的构造器。package top.leagle.basic.staticT;class Person &#123; static &#123; System.out.println(&quot;person static&quot;); &#125; public Person(String str) &#123; System.out.println(&quot;person &quot; + str); &#125;&#125;class MyClass extends StaticTest3 &#123; Person person = new Person(&quot;MyClass&quot;); static &#123; System.out.println(&quot;myclass static&quot;); &#125; public MyClass() &#123; System.out.println(&quot;myclass constructor&quot;); &#125;&#125;public class StaticTest3 &#123; Person person = new Person(&quot;Test&quot;); static &#123; System.out.println(&quot;test static&quot;); &#125; public StaticTest3() &#123; System.out.println(&quot;test constructor&quot;); &#125; public static void main(String[] args) &#123; new MyClass(); &#125;&#125;输出：test staticmyclass staticperson staticperson Testtest constructorperson MyClassmyclass constructor解释：首先加载Test类，因此会执行StaticTest3类中的static块。接着执行newMyClass()，而MyClass类还没有被加载，因此需要加载MyClass类。在加载MyClass类的时候，发现MyClass类继承自StaticTest3类，但是由于StaticTest3类已经被加载了，所以只需要加载MyClass类，那么就会执行MyClass类的中的static块。在加载完之后，就通过构造器来生成对象。而在生成对象的时候，必须先初始化父类的成员变量，因此会执行StaticTest3中的Person person = new Person()。而Person类还没有被加载过，因此会先加载Person类并执行Person类中的static块，接着执行父类的构造器，完成了父类的初始化，然后就来初始化自身了。因此会接着执行MyClass中的Person person = new Person()，最后执行MyClass的构造器。package top.leagle.basic.staticT;public class StaticTest4 &#123; static &#123; System.out.println(&quot;test static 1&quot;); &#125; public static void main(String[] args) &#123; &#125; static &#123; System.out.println(&quot;test static 2&quot;); &#125;&#125;输出：test static 1test static 2解释：虽然在main方法中没有任何语句，但是还是会输出，原因上面已经讲述过了。另外，static块可以出现类中的任何地方（只要不是方法内部，记住，任何方法内部都不行），并且执行是按照static块的顺序执行的。 参考：Java中的static关键字解析 类与继承123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174对于 char、short、byte、int、long、float、double等基本数据类型的变量来说会默认初始化为0（boolean变量默认会被初始化为false）对于引用类型的变量，会默认初始化为null。如果没有显示地定义构造器，则编译器会自动创建一个无参构造器，但是要记住一点，如果显示地定义了构造器，编译器就不会自动添加构造器。注意，所有的构造器默认为static的。当程序执行时，需要生成某个类的对象，Java执行引擎会先检查是否加载了这个类，如果没有加载，则先执行类的加载再生成对象，如果已经加载，则直接生成对象。在类的加载过程中，类的static成员变量会被初始化，另外，如果类中有static语句块，则会执行static语句块。static成员变量和static语句块的执行顺序同代码中的顺序一致。记住，在Java中，类是按需加载，只有当需要用到这个类的时候，才会加载这个类，并且只会加载一次。package top.leagle.basic.object;import org.junit.Test;class Bread &#123; static &#123; System.out.println(&quot;Bread is loaded&quot;); &#125; public Bread() &#123; System.out.println(&quot;bread&quot;); &#125;&#125;public class ObjectTest &#123; @Test public void test1() &#123; Bread bread1 = new Bread(); Bread bread2 = new Bread(); &#125;&#125;输出：Bread is loadedbreadbread解释：类只加载一次在生成对象的过程中，会先初始化对象的成员变量，然后再执行构造器。也就是说类中的变量会在任何方法（包括构造器）调用之前得到初始化，即使变量散步于方法定义之间。package top.leagle.basic.object;class Meal &#123; public Meal() &#123; System.out.println(&quot;meal&quot;); &#125; Bread1 bread = new Bread1();&#125;class Bread1 &#123; public Bread1() &#123; System.out.println(&quot;bread&quot;); &#125;&#125;public class ObjectTest2 &#123; public static void main(String[] args) &#123; new Meal(); &#125;&#125;输出：breadmeal解释：先成员变量，后构造函数super主要有两种用法：1.super.成员变量 / super.成员方法;2.super(parameter1, parameter2....)package top.leagle.basic.object;class Draw &#123; public Draw(String type) &#123; System.out.println(type + &quot; draw constructor&quot;); &#125;&#125;class Shape &#123; private Draw draw = new Draw(&quot;shape&quot;); public Shape() &#123; System.out.println(&quot;shape constructor&quot;); &#125;&#125;class Circle extends Shape &#123; private Draw draw = new Draw(&quot;circle&quot;); public Circle() &#123; System.out.println(&quot;circle constructor&quot;); &#125;&#125;public class ObjectTest3 &#123; public static void main(String[] args) &#123; new Circle(); &#125;&#125;输出：shape draw constructorshape constructorcircle draw constructorcircle constructor解释：先父类，后子类package top.leagle.basic.object;class Shape1 &#123; public String name = &quot;shape&quot;; public Shape1() &#123; System.out.println(&quot;shape constructor&quot;); &#125; public void printType() &#123; System.out.println(&quot;this is shape&quot;); &#125; public static void printName() &#123; System.out.println(&quot;shape&quot;); &#125;&#125;class Circle1 extends Shape1 &#123; public String name = &quot;circle&quot;; public Circle1() &#123; System.out.println(&quot;circle constructor&quot;); &#125; public void printType() &#123; System.out.println(&quot;this is circle&quot;); &#125; public static void printName() &#123; System.out.println(&quot;circle&quot;); &#125;&#125;public class ObjectTest4 &#123; public static void main(String[] args) &#123; Shape1 shape1 = new Circle1(); System.out.println(shape1.name); shape1.printType(); shape1.printName(); &#125;&#125;输出：shape constructorcircle constructorshapethis is circleshape解释：覆盖只针对非静态方法，而隐藏是针对成员变量和静态方法的。 参考：Java：类与继承java提高篇(二)—–理解java的三大特性之继承 final 关键字1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，不需要使用final方法进行这些优化了。对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。@Testpublic void test1() &#123; String a = &quot;hello2&quot;; final String b = &quot;hello&quot;; String d = &quot;hello&quot;; String c = b + 2; String e = d + 2; System.out.println((a == c)); System.out.println((a == e));&#125;输出：truefalse解释：由于变量b被final修饰，因此会被当做编译器常量，所以在使用到b的地方会直接将变量b 替换为它的值@Testpublic void test2() &#123; final MyClass myClass = new MyClass(); System.out.println(++myClass.i);&#125;class MyClass &#123; public int i = 0;&#125; 输出：1解释：引用变量被final修饰之后，虽然不能再指向其他对象，但是它指向的对象的内容是可变的。public class FinalTest &#123; @Test public void test3() &#123; FinalTest myClass1 = new FinalTest(); FinalTest myClass2 = new FinalTest(); System.out.println(myClass1.i); System.out.println(myClass1.j); System.out.println(myClass2.i); System.out.println(myClass2.j); &#125;&#125;输出：两个j值都是一样的，而i的值却是不同的解释：static只加载一次，而final是每个对象的值 参考：浅析Java中的final关键字 enum1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283enum Color &#123; RED, GREEN, BLANK, YELLOW&#125;public boolean isRed(Color color) &#123; if (Color.RED.equals(color)) &#123; return true; &#125; else &#123; return false; &#125;&#125;@Testpublic void test1() &#123; System.out.println(isRed(Color.RED)); System.out.println(isRed(Color.GREEN));&#125;public void showColor(Color color) &#123; switch (color) &#123; case BLANK: System.out.println(color); break; case RED: System.out.println(color); break; default: System.out.println(color); break; &#125;&#125;@Testpublic void test2() &#123; showColor(Color.RED); showColor(Color.GREEN);&#125;enum Color1 &#123; RED(&quot;红色&quot;, 1), GREEN(&quot;绿色&quot;, 2), BLANK(&quot;白色&quot;, 3), YELLO(&quot;黄色&quot;, 4); private String name; private int index; private Color1(String name, int index) &#123; this.name = name; this.index = index; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getIndex() &#123; return index; &#125; public void setIndex(int index) &#123; this.index = index; &#125;&#125;@Testpublic void test3() &#123; // 输出某一枚举的值 System.out.println(Color1.RED.getName()); System.out.println(Color1.RED.getIndex()); // 遍历所有的枚举 for (Color1 color : Color1.values()) &#123; System.out.println(color + &quot; name: &quot; + color.getName() + &quot; index: &quot; + color.getIndex()); &#125;&#125; 类型转换1234567891011121314151617181920212223242526272829301.低级向高级转换---自动转换:隐式转换 byte i = 0; int a =i; long b = i; float c =b; double d =c; short j =i; 2.高级到低级转换---强制转换 int i=99; byte b=(byte)i; char c=(char)i; float f=i; double d = f; f =(float) d; @Testpublic void test() &#123; int gradeLev = 2; String schoolName = &quot;曹行中学&quot;; System.out.println(gradeLev + &quot; &quot; + schoolName); Object gradeLev1 = gradeLev; Object schoolName1 = schoolName; System.out.println(gradeLev1 + &quot; &quot; + schoolName1); int gradeLev2 = (int) gradeLev1; String schoolName2 = (String) schoolName1; System.out.println(gradeLev2 + &quot; &quot; + schoolName2);&#125; == 和 equal12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394基本数据类型：==比较的是他们的值。复合数据类型（类）：==比较的是2个对象的地址，而equals比较的是2个对象的内容。@Testpublic void test1() &#123; String s1 = &quot;Hello&quot;; String s2 = &quot;Hello&quot;; System.out.println(s1 == s2);&#125;输出：true@Testpublic void test2() &#123; String str1 = &quot;Hello&quot;; String str2 = new String(&quot;Hello&quot;); String str3 = str2; System.out.println(str1 == str2); System.out.println(str1 == str3); System.out.println(str2 == str3); System.out.println(str1.equals(str2)); System.out.println(str1.equals(str3)); System.out.println(str2.equals(str3));&#125;输出：falsefalsetruetruetruetrue@Testpublic void test3() &#123; String s1 = &quot;Hello&quot;; String s2 = new String(&quot;Hello&quot;); s2 = s2.intern(); System.out.println(s1 == s2); System.out.println(s1.equals(s2));&#125;输出：truetrueclass Student &#123; private String name; private int age; private String address; public Student(String name, int age, String address) &#123; this.name = name; this.age = age; this.address = address; &#125; @Override public boolean equals(Object obj) &#123; // 如果内存地址相等，那么一定是同一个对象，就无需比较两个对象的属性值 if (this == obj) &#123; return true; &#125; // 判断obj是否为Baboon类型的实例 if (obj instanceof Student) &#123; Student b = (Student) obj;// 强制转换 // 判断两个对象的属性值是否相等 if (!this.name.equals(b.name)) &#123; return false; &#125; else if (this.age != b.age) &#123; return false; &#125; else if (this.address != b.address) &#123; return false; &#125; return true; &#125; else &#123; return false; &#125; &#125;&#125;@Testpublic void test4() &#123; Student student1 = new Student(&quot;生命壹号&quot;, 22, &quot;成都&quot;); Student student2 = new Student(&quot;生命壹号&quot;, 22, &quot;成都&quot;); System.out.println(student1 == student2); System.out.println(student1.equals(student2));&#125;输出：falsetrue 路由算法 链路状态路由选择算法（Link State, LS）12345678910111213Initialization: N&apos; = &#123;u&#125; for all nodes v if v is a neighbor of u then D(v) = c(u, v) else D(v) = ∞Loop find w not in N&apos; such that D(w) is a minimum add w to N&apos; update D(v) for each neighbor v of w and not in N&apos;: D(v) = min(D(v), D(w) + c(w, v))until N&apos;=N 步骤 N’ D(V), p(V) (w), p(w) D(x), p(x) D(y), p(y) D(z), p(z) 0 u 2, u 5, u 1, u ∞ ∞ 1 ux 2, u 4, x 1, u 2, x ∞ 2 uxy 2, u 3, y 1, u 2, x 4, y 3 uxyv 2, u 3, y 1, u 2, x 4, y 4 uxyvw 2, u 3, y 1, u 2, x 4, y 5 uxyvwz 2, u 3, y 1, u 2, x 4, y 距离向量路由选择算法123456789101112131415Initialization: for all destinations y in N: Dx(y) = c(x, y) for each neighbor w Dw(y) = ? for all destinations y in N for each neighbor w send distance vector Dx = [Dx(y) : y in N] to wloop wait(until I see a link cost change to some neighbor w or until I receive a distance vector from some neighbor w) for each y in N: Dx(y) = MINv&#123;c(x,v) + Dv(y)&#125; if Dx(y) changed for any destination y send distance vector Dx = [Dx(y) : y in N] to all neighbors TensorFlow 和 kerasTensorFlow keras12345Keras是一个模型级（model-level）的深度学习链接库，Keras只处理模型的建立、训练、预测等功能。深度学习底层的运行，例如张量运算，Keras必须配合“后端引擎”进行预算。目前Keras提供了两种后端引擎：TensorFlow和Theano。内建各种神经网络层级，可以简单快速建立模型。 设计模式适配器模式（adapter Pattern）123接口的转换： 火鸡转为鸭子。 鸭子转为火鸡。 命令模式（Adapter Pattern）12很多命令有一个相同的执行方法名称，每个命令的这个执行方法的定义不一样。 装饰者模式（Decorator Pattern）1一层功能一层功能的嵌套。 外观模式（Facade Pattern）1把很多方法放到一个方法中，统一方法。 工厂模式（Factory Pattern）1使用一个共同的接口来指向新创建的对象。 单例模式（Singleton Pattern）1这个对象只被实例化一次。 模板模式（Template Pattern）1定义一个模板，按照这个模板，写自己对应的内容。","tags":[{"name":"java 基础","slug":"java-基础","permalink":"http://yoursite.com/tags/java-基础/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"总结：20180408~20180414","date":"2018-04-14T09:00:00.000Z","path":"2018/04/14/summary20180414/","text":"1234567array、vector、list、arraylist的区别Java泛型可变参数封装、继承、多态的理解策略模式（strategy）观察者模式（observer）#和$ PreparedStatement和Statement array、vector、list、arraylist的区别1234567891011121314array是数组：基本类型和对象类型，大小固定Vector：只能包含对象类型，线程安全的，也就是说是同步的list是接口：所以lit不能实例化arraylist是list的实现类：只能包含对象类型，基于动态数组实现，线程序不安全的，不是同步的，不需要指定长度，Object类型LinkedList是list的实现类：只能包含对象类型，基于链表的数据结构 Java泛型1234567891011121314151617181920212223242526272829303132333435363738public class Box&lt;T&gt; &#123; private T object; public void set(T object) &#123; this.object = object; &#125; public T get() &#123; return object; &#125;&#125;不用泛型：Box box2 = new Box();box2.set(new Apple());Apple apple = (Apple) box2.get();用泛型：Box&lt;Apple&gt; box = new Box&lt;Apple&gt;();box.set(new Apple());Apple apple = box.get();字每A,B,C,D...定义的，就是泛型这里T只是名字上的意义而已T----typeE----Element K----keyV----value ?----表示不确定的java类型? extends E:接收E类型或者E的子类型。? super E:接收E类型或者E的父类型 Object和T不同点:Object是一个实打实的类,并没有泛指谁，而T可以泛指Object。比方public void printList(List&lt;T&gt; list)&#123;&#125;方法中可以传入List&lt;Object&gt;，也可以传入List&lt;String&gt;，但是public void printList(List&lt;Object&gt;list)&#123;&#125;方法中只可以传入List&lt;Object&gt;list类型参数，因为Object类型并没有泛指谁，是一个确定的类型 可变参数可变参数的本质就是数组12345678public void RegularFunction();public void RegularFunction(int i);public void RegularFunction(int i, int j);public void RegularFunction(int i, int j, int k);等价于：public void VariableFunction(int... args); 可变参数的使用12VariableFunction(1, 2, 3);VariableFunction(new int[] &#123; 1, 2, 3 &#125;); 注意事项123456789101112public void VariableFunction(int... args);public void VariableFunction(int[] args);Duplicate method本质上是一样的，无法完成重载public void VariableFunction(int... args, int i);The variable argument type int of the method variableTest must be the last不定项参数必须放在参数列表最后一个。public void VariableFunction(int... args1, int... args2);The variable argument type int of the method variableTest must be the last不定项参数只能有一个（多个，必然有一个不是最后一个）。 重载时，运行优先级问题123456789public void VariableFunction(int i, int j, int k);public void VariableFunction(int... args);调用VariableFunction(1, 2, 3);优先运行 VariableFunction(int i, int j, int k);public void VariableFunction(int... args)public void VariableFunction(int i, int j, int... args);调用VariableFunction(1, 2, 3, 4);优先运行 VariableFunction(int i, int j, int... args); 疑问12345678910public void VariableFunction(int... args)public void VariableFunction(int i, int j, int... args);调用VariableFunction(1, 2, 3, 4);可以成功public void VariableFunction(int... args)public void VariableFunction(int i, int... args);调用VariableFunction(1, 2, 3, 4);调用失败The method is ambiguouswhy? 封装、继承、多态123封装：类继承：父类和子类多态：函数的重载；父类的多个子类；接口的多种实现 设计模式策略模式（strategy）1234567891011121314红头鸭：会游泳、呱呱叫、用翅膀飞绿头鸭：会游泳、呱呱叫、用翅膀飞木头鸭子：会游泳、不会叫、不会飞橡皮鸭：会游泳、吱吱叫、不会飞定义一个鸭子类，就知道这个鸭子的行为。接口：飞行行为实现：用翅膀飞、不会飞接口：叫行为实现：呱呱叫、吱吱叫、不会叫抽象类：鸭子（游泳、叫、飞）继承类：红头鸭、绿头鸭、木头鸭子、橡皮鸭 观察者模式（observer）123456789天气：温度、湿度、气压展示板：当前天气情况、预测天气、天气数据集一旦天气发生变化，发送给所有的展示板接口：Subject实现：WeatherData接口：Observer实现：CurrenCondition、Forecast、Statistics #和$ PreparedStatement和Statement12345678910111213141516我的理解(可能不对)：# 相当于 PreparedStatement $ 相当于 StatementStatement 每次都会执行SQL语句PreparedStatement 预编译，执行相同语句使，不需要编译。Statement:String name = &quot;A\\&apos; or &apos;1&apos; = &apos;1&quot;;String sql = &quot;select * from user where userName = &apos;&quot; + name + &quot;&apos;&quot;select * from user where userName = &apos;A&apos; or &apos;1&apos; = &apos;1&apos;PreparedStatement:String sql = &quot;select * from user where userName = ?&quot;;String name = &quot;A\\&apos; or &apos;1&apos; = &apos;1&quot;;select * from user where userName = &apos;A\\&apos; or \\&apos;1\\&apos; = \\&apos;1&apos; 未解决的问题1random 底层实现","tags":[{"name":"java 基础","slug":"java-基础","permalink":"http://yoursite.com/tags/java-基础/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"28 自制操作系统第二十八天","date":"2018-02-26T09:00:00.000Z","path":"2018/02/26/omake_28/","text":"项目地址 12345主要内容：1. alloca（1）（harib25a）2. alloca（2）（harib25b）3. 文件操作API（harib25c)4. 命令行API（harib25d） alloca（1）（harib25a）写一个读取文件的功能和显示文字的功能。 12345678910111213141516171819202122232425sosu.c 文件#include &lt;stdio.h&gt;#include &quot;apilib.h&quot;#define MAX 1000void HariMain(void)&#123; char flag[MAX], s[8]; int i, j; for (i = 0; i &lt; MAX; i++) &#123; flag[i] = 0; &#125; for (i = 2; i &lt; MAX; i++) &#123; if (flag[i] == 0) &#123; sprintf(s, &quot;%d &quot;, i); api_putstr0(s); for (j = i * 2; j &lt; MAX; j += i) &#123; flag[j] = 1; &#125; &#125; &#125; api_end();&#125; 这个功能是显示1000以内的质数。 如果把MAX改为10000，这个程序就出现了警告：“can’t link __alloca” 电脑中的C语言编译器规定，如果栈中的变量超过了4KB，则需要调用__alloc这个函数。这个函数的主要功能就是根据操作系统的规格来获取栈中的空间。 先不编写__alloc这个函数，先修改一下代码 123456789101112131415161718192021222324252627sosu3.c 文件#include &lt;stdio.h&gt;#include &quot;apilib.h&quot;#define MAX 10000void HariMain(void)&#123; char *flag, s[8]; int i, j; api_initmalloc(); flag = api_malloc(MAX); for (i = 0; i &lt; MAX; i++) &#123; flag[i] = 0; &#125; for (i = 2; i &lt; MAX; i++) &#123; if (flag[i] == 0) &#123; sprintf(s, &quot;%d &quot;, i); api_putstr0(s); for (j = i * 2; j &lt; MAX; j += i) &#123; flag[j] = 1; &#125; &#125; &#125; api_end();&#125; 我们事先用malloc给它分配一下空间就好了。 alloca（2）（harib25b）编写__alloca函数，这个函数只需要对ESP进行减法运算，而不做其他任何多余的操作。 12345678910111213[FORMAT &quot;WCOFF&quot;][INSTRSET &quot;i486p&quot;][BITS 32][FILE &quot;alloca.nas&quot;] GLOBAL __alloca[SECTION .text]__alloca: ADD EAX,-4 SUB ESP,EAX JMP DWORD [ESP+EAX] ; 代替RET 文件操作API（harib25c)打开文件EDX=21EBX=文件名EAX=文件句柄（为0时表示打开失败）（由操作系统返回） 关闭文件EDX=22EAX=文件句柄 文件定位EDX=23EAX=文件句柄ECX=定位模式0：定位的起点为文件开头1：定位的起点为当前的访问位置2：定位的起点为文件末尾EBX=定位偏移量 获取文件大小EAX=文件句柄ECX=文件大小获取模式0：普通文件大小1：当前读取位置从文件开头起算的偏移量2：当前读取位置从文件末尾起算的偏移量EAX=文件大小（由操作系统返回） 文件读取EDX=25EAX=文件句柄EBX=缓冲区地址ECX=最大读取字节数EAX=本次读取到的字节数（由操作系统返回） 1234567891011121314151617struct TASK &#123; int sel, flags; /* sel偼GDT偺斣崋偺偙偲 */ int level, priority; struct FIFO32 fifo; struct TSS32 tss; struct SEGMENT_DESCRIPTOR ldt[2]; struct CONSOLE *cons; int ds_base, cons_stack; struct FILEHANDLE *fhandle; int *fat;&#125;;struct FILEHANDLE &#123; char *buf; int size; int pos;&#125;; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495void console_task(struct SHEET *sheet, int memtotal)&#123; struct FILEHANDLE fhandle[8]; file_readfat(fat, (unsigned char *) (ADR_DISKIMG + 0x000200)); for (i = 0; i &lt; 8; i++) &#123; fhandle[i].buf = 0; /* 枹巊梡儅乕僋 */ &#125; task-&gt;fhandle = fhandle; task-&gt;fat = fat;&#125;int cmd_app(struct CONSOLE *cons, int *fat, char *cmdline)&#123; if (finfo != 0) &#123; if (finfo-&gt;size &gt;= 36 &amp;&amp; strncmp(p + 4, &quot;Hari&quot;, 4) == 0 &amp;&amp; *p == 0x00) &#123; for (i = 0; i &lt; 8; i++) &#123; if (task-&gt;fhandle[i].buf != 0) &#123; memman_free_4k(memman, (int) task-&gt;fhandle[i].buf, task-&gt;fhandle[i].size); task-&gt;fhandle[i].buf = 0; &#125; &#125; &#125; else &#123; &#125; &#125; return 0;&#125;int *hrb_api(int edi, int esi, int ebp, int esp, int ebx, int edx, int ecx, int eax)&#123; &#125; else if (edx == 21) &#123; for (i = 0; i &lt; 8; i++) &#123; if (task-&gt;fhandle[i].buf == 0) &#123; break; &#125; &#125; fh = &amp;task-&gt;fhandle[i]; reg[7] = 0; if (i &lt; 8) &#123; finfo = file_search((char *) ebx + ds_base, (struct FILEINFO *) (ADR_DISKIMG + 0x002600), 224); if (finfo != 0) &#123; reg[7] = (int) fh; fh-&gt;buf = (char *) memman_alloc_4k(memman, finfo-&gt;size); fh-&gt;size = finfo-&gt;size; fh-&gt;pos = 0; file_loadfile(finfo-&gt;clustno, finfo-&gt;size, fh-&gt;buf, task-&gt;fat, (char *) (ADR_DISKIMG + 0x003e00)); &#125; &#125; &#125; else if (edx == 22) &#123; fh = (struct FILEHANDLE *) eax; memman_free_4k(memman, (int) fh-&gt;buf, fh-&gt;size); fh-&gt;buf = 0; &#125; else if (edx == 23) &#123; fh = (struct FILEHANDLE *) eax; if (ecx == 0) &#123; fh-&gt;pos = ebx; &#125; else if (ecx == 1) &#123; fh-&gt;pos += ebx; &#125; else if (ecx == 2) &#123; fh-&gt;pos = fh-&gt;size + ebx; &#125; if (fh-&gt;pos &lt; 0) &#123; fh-&gt;pos = 0; &#125; if (fh-&gt;pos &gt; fh-&gt;size) &#123; fh-&gt;pos = fh-&gt;size; &#125; &#125; else if (edx == 24) &#123; fh = (struct FILEHANDLE *) eax; if (ecx == 0) &#123; reg[7] = fh-&gt;size; &#125; else if (ecx == 1) &#123; reg[7] = fh-&gt;pos; &#125; else if (ecx == 2) &#123; reg[7] = fh-&gt;pos - fh-&gt;size; &#125; &#125; else if (edx == 25) &#123; fh = (struct FILEHANDLE *) eax; for (i = 0; i &lt; ecx; i++) &#123; if (fh-&gt;pos == fh-&gt;size) &#123; break; &#125; *((char *) ebx + ds_base + i) = fh-&gt;buf[fh-&gt;pos]; fh-&gt;pos++; &#125; reg[7] = i; &#125; return 0;&#125; 1234567891011121314151617api021.nas 文件[FORMAT &quot;WCOFF&quot;][INSTRSET &quot;i486p&quot;][BITS 32][FILE &quot;api021.nas&quot;] GLOBAL _api_fopen[SECTION .text]_api_fopen: ; int api_fopen(char *fname); PUSH EBX MOV EDX,21 MOV EBX,[ESP+8] ; fname INT 0x40 POP EBX RET 123456789101112131415api022.nas 文件[FORMAT &quot;WCOFF&quot;][INSTRSET &quot;i486p&quot;][BITS 32][FILE &quot;api022.nas&quot;] GLOBAL _api_fclose[SECTION .text]_api_fclose: ; void api_fclose(int fhandle); MOV EDX,22 MOV EAX,[ESP+4] ; fhandle INT 0x40 RET 12345678910111213141516171819api023.nas 文件[FORMAT &quot;WCOFF&quot;][INSTRSET &quot;i486p&quot;][BITS 32][FILE &quot;api023.nas&quot;] GLOBAL _api_fseek[SECTION .text]_api_fseek: ; void api_fseek(int fhandle, int offset, int mode); PUSH EBX MOV EDX,23 MOV EAX,[ESP+8] ; fhandle MOV ECX,[ESP+16] ; mode MOV EBX,[ESP+12] ; offset INT 0x40 POP EBX RET 12345678910111213141516api024.nas 文件[FORMAT &quot;WCOFF&quot;][INSTRSET &quot;i486p&quot;][BITS 32][FILE &quot;api024.nas&quot;] GLOBAL _api_fsize[SECTION .text]_api_fsize: ; int api_fsize(int fhandle, int mode); MOV EDX,24 MOV EAX,[ESP+4] ; fhandle MOV ECX,[ESP+8] ; mode INT 0x40 RET 12345678910111213141516171819api025.nas 文件[FORMAT &quot;WCOFF&quot;][INSTRSET &quot;i486p&quot;][BITS 32][FILE &quot;api025.nas&quot;] GLOBAL _api_fread[SECTION .text]_api_fread: ; int api_fread(char *buf, int maxsize, int fhandle); PUSH EBX MOV EDX,25 MOV EAX,[ESP+16] ; fhandle MOV ECX,[ESP+12] ; maxsize MOV EBX,[ESP+8] ; buf INT 0x40 POP EBX RET 12345678910111213141516171819typeipl.c文件#include &quot;apilib.h&quot;void HariMain(void)&#123; int fh; char c; fh = api_fopen(&quot;ipl10.nas&quot;); if (fh != 0) &#123; for (;;) &#123; if (api_fread(&amp;c, 1, fh) == 0) &#123; break; &#125; api_putchar(c); &#125; &#125; api_end();&#125; 命令行API（harib25d）用typeipl.hrb代替console中的type命令。 但是要编写一个获取命令行的API 获取命令行EDX=26EBX=存放命令行内容的地址 123456789101112struct TASK &#123; int sel, flags; int level, priority; struct FIFO32 fifo; struct TSS32 tss; struct SEGMENT_DESCRIPTOR ldt[2]; struct CONSOLE *cons; int ds_base, cons_stack; struct FILEHANDLE *fhandle; int *fat; char *cmdline;&#125;; 123456789101112131415161718int *hrb_api(int edi, int esi, int ebp, int esp, int ebx, int edx, int ecx, int eax)&#123; &#125; else if (edx == 26) &#123; i = 0; for (;;) &#123; *((char *) ebx + ds_base + i) = task-&gt;cmdline[i]; if (task-&gt;cmdline[i] == 0) &#123; break; &#125; if (i &gt;= ecx) &#123; break; &#125; i++; &#125; reg[7] = i; &#125; return 0;&#125; 12345678910111213141516171819api026.nas 文件[FORMAT &quot;WCOFF&quot;][INSTRSET &quot;i486p&quot;][BITS 32][FILE &quot;api026.nas&quot;] GLOBAL _api_cmdline[SECTION .text]_api_cmdline: ; int api_cmdline(char *buf, int maxsize); PUSH EBX MOV EDX,26 MOV ECX,[ESP+12] ; maxsize MOV EBX,[ESP+8] ; buf INT 0x40 POP EBX RET 12345678910111213141516171819202122232425type.c 文件#include &quot;apilib.h&quot;void HariMain(void)&#123; int fh; char c, cmdline[30], *p; api_cmdline(cmdline, 30); for (p = cmdline; *p &gt; &apos; &apos;; p++) &#123; &#125; /* 跳过之前的内容，直到遇到空格 */ for (; *p == &apos; &apos;; p++) &#123; &#125; /* 跳过空格 */ fh = api_fopen(p); if (fh != 0) &#123; for (;;) &#123; if (api_fread(&amp;c, 1, fh) == 0) &#123; break; &#125; api_putchar(c); &#125; &#125; else &#123; api_putstr0(&quot;File not found.\\n&quot;); &#125; api_end();&#125;","tags":[{"name":"30天自制操作系统","slug":"30天自制操作系统","permalink":"http://yoursite.com/tags/30天自制操作系统/"},{"name":"alloca","slug":"alloca","permalink":"http://yoursite.com/tags/alloca/"},{"name":"文件操作API","slug":"文件操作API","permalink":"http://yoursite.com/tags/文件操作API/"}]},{"title":"27 自制操作系统第二十七天","date":"2018-02-24T09:00:00.000Z","path":"2018/02/24/omake_27/","text":"项目地址 12345678主要内容：1. 修复bug（harib24a）2. 应用程序运行时关闭命令行窗口（harib24b）3. 保护应用程序（1）（harib24c)4. 保护应用程序（2）（harib24d）5. 优化应用程序的大小（harib24e）6. 库（harib24f）7. 整理make环境（harib24g） 修复bug（harib24a）nsct命令运行的应用程序，使用shift+F1还或点击窗口的“×”按钮关闭窗口。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859void HariMain(void)&#123; for (;;) &#123; if (fifo32_status(&amp;fifo) == 0) &#123; &#125; else &#123; if (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; if (i == 256 + 0x3b &amp;&amp; key_shift != 0 &amp;&amp; key_win != 0) &#123; /* Shift+F1 */ task = key_win-&gt;task; if (task != 0 &amp;&amp; task-&gt;tss.ss0 != 0) &#123; cons_putstr0(task-&gt;cons, &quot;\\nBreak(key) :\\n&quot;); io_cli(); task-&gt;tss.eax = (int) &amp;(task-&gt;tss.esp0); task-&gt;tss.eip = (int) asm_end_app; io_sti(); task_run(task, -1, 0); /* 为了确实执行结束处理，如果处于休眠状态则唤醒 */ &#125; &#125; &#125; else if (512 &lt;= i &amp;&amp; i &lt;= 767) &#123; if ((mdec.btn &amp; 0x01) != 0) &#123; if (mmx &lt; 0) &#123; for (j = shtctl-&gt;top - 1; j &gt; 0; j--) &#123; if (0 &lt;= x &amp;&amp; x &lt; sht-&gt;bxsize &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; sht-&gt;bysize) &#123; if (sht-&gt;bxsize - 21 &lt;= x &amp;&amp; x &lt; sht-&gt;bxsize - 5 &amp;&amp; 5 &lt;= y &amp;&amp; y &lt; 19) &#123; if ((sht-&gt;flags &amp; 0x10) != 0) &#123; task = sht-&gt;task; cons_putstr0(task-&gt;cons, &quot;\\nBreak(mouse) :\\n&quot;); io_cli(); task-&gt;tss.eax = (int) &amp;(task-&gt;tss.esp0); task-&gt;tss.eip = (int) asm_end_app; io_sti(); task_run(task, -1, 0); /* 为了确实执行结束处理，如果处于休眠状态则唤醒 */ &#125; else &#123; &#125; &#125; break; &#125; &#125; &#125; &#125; else &#123; &#125; &#125; else &#123; &#125; &#125; &#125; else if (768 &lt;= i &amp;&amp; i &lt;= 1023) &#123; &#125; else if (1024 &lt;= i &amp;&amp; i &lt;= 2023) &#123; &#125; &#125; &#125;&#125; 尽管我们特地在TSS中改写了EIP和EAX以便执行结束任务的处理，可如果一直处以休眠状态的话结束任务的处理就永远不会开始执行，因为我们需要唤醒它，使得结束处理确实能够被执行。 之前一直没有这个语句，强制结束功能也没出现过问题，这是怎么回事？因为命令行窗口会触发用来控制光标闪烁的定时器中断（在命令行窗口中，不显示光标时也会每0.5秒触发一次定时器中断），当产生定时器中断时，定时器超时会想FIFO写入数据，于是任务就被自动唤醒了。 应用程序运行时关闭命令行窗口（harib24b1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556void HariMain(void)&#123; struct SHEET *sht = 0, *key_win, *sht2; for (;;) &#123; if (fifo32_status(&amp;fifo) == 0) &#123; &#125; else &#123; if (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; &#125; else if (512 &lt;= i &amp;&amp; i &lt;= 767) &#123; /* ?&#125;?E?X?f?[?^ */ if (mouse_decode(&amp;mdec, i - 512) != 0) &#123; if ((mdec.btn &amp; 0x01) != 0) &#123; if (mmx &lt; 0) &#123; for (j = shtctl-&gt;top - 1; j &gt; 0; j--) &#123; if (0 &lt;= x &amp;&amp; x &lt; sht-&gt;bxsize &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; sht-&gt;bysize) &#123; if (sht-&gt;buf[y * sht-&gt;bxsize + x] != sht-&gt;col_inv) &#123; if (sht-&gt;bxsize - 21 &lt;= x &amp;&amp; x &lt; sht-&gt;bxsize - 5 &amp;&amp; 5 &lt;= y &amp;&amp; y &lt; 19) &#123; if ((sht-&gt;flags &amp; 0x10) != 0) &#123; &#125; else &#123; /* 命令行窗口 */ task = sht-&gt;task; sheet_updown(sht, -1); /* 暂且隐藏该图层 */ keywin_off(key_win); key_win = shtctl-&gt;sheets[shtctl-&gt;top - 1]; keywin_on(key_win); io_cli(); fifo32_put(&amp;task-&gt;fifo, 4); io_sti(); &#125; &#125; break; &#125; &#125; &#125; &#125; else &#123; &#125; &#125; else &#123; &#125; &#125; &#125; else if (768 &lt;= i &amp;&amp; i &lt;= 1023) &#123; &#125; else if (1024 &lt;= i &amp;&amp; i &lt;= 2023) &#123; &#125; else if (2024 &lt;= i &amp;&amp; i &lt;= 2279) &#123; /* 只关闭命令行窗口 */ sht2 = shtctl-&gt;sheets0 + (i - 2024); memman_free_4k(memman, (int) sht2-&gt;buf, 256 * 165); sheet_free(sht2); &#125; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263void console_task(struct SHEET *sheet, int memtotal)&#123; if (cons.sht != 0) &#123; &#125; for (;;) &#123; io_cli(); if (fifo32_status(&amp;task-&gt;fifo) == 0) &#123; &#125; else &#123; if (i &lt;= 1 &amp;&amp; cons.sht != 0) &#123; &#125; if (i == 3) &#123; if (cons.sht != 0) &#123; boxfill8(cons.sht-&gt;buf, cons.sht-&gt;bxsize, COL8_000000, cons.cur_x, cons.cur_y, cons.cur_x + 7, cons.cur_y + 15); &#125; &#125; if (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; if (i == 8 + 256) &#123; &#125; else if (i == 10 + 256) &#123; /* Enter */ if (cons.sht == 0) &#123; cmd_exit(&amp;cons, fat); &#125; &#125; else &#123; &#125; &#125; if (cons.sht != 0) &#123; if (cons.cur_c &gt;= 0) &#123; boxfill8(cons.sht-&gt;buf, cons.sht-&gt;bxsize, cons.cur_c, cons.cur_x, cons.cur_y, cons.cur_x + 7, cons.cur_y + 15); &#125; sheet_refresh(cons.sht, cons.cur_x, cons.cur_y, cons.cur_x + 8, cons.cur_y + 16); &#125; &#125; &#125;&#125;int *hrb_api(int edi, int esi, int ebp, int esp, int ebx, int edx, int ecx, int eax)&#123; &#125; else if (edx == 15) &#123; for (;;) &#123; i = fifo32_get(&amp;task-&gt;fifo); if (i == 4) &#123; timer_cancel(cons-&gt;timer); io_cli(); fifo32_put(sys_fifo, cons-&gt;sht - shtctl-&gt;sheets0 + 2024); cons-&gt;sht = 0; io_sti(); &#125; &#125; &#125; else if (edx == 16) &#123;&#125; 保护应用程序（1）（harib24c)12345678910111213141516171819202122232425262728[FORMAT &quot;WCOFF&quot;][INSTRSET &quot;i486p&quot;][BITS 32][FILE &quot;crack7.nas&quot;] GLOBAL _HariMain[SECTION .text]_HariMain: MOV AX,1005*8 MOV DS,AX CMP DWORD [DS:0x0004],&apos;Hari&apos; JNE fin MOV ECX,[DS:0x0000] ; 读取该应用程序数据段的大小 MOV AX,2005*8 MOV DS,AXcrackloop: ; 用123填充 ADD ECX,-1 MOV BYTE [DS:ECX],123 CMP ECX,0 JNE crackloopfin: MOV EDX,4 INT 0x40 如果你增在运行一个应用程序。它会把这个应用程序的数据段都改为123，虽然没有什么意义，但足可以破坏。 保护应用程序（2）（harib24d）LDT 是local descriptor table。只对某个应用程序有效。如果将应用程序设置在LDT中，其他的任务由于无法使用该LDT，也就不用担心他们来搞破坏了。 现在需要设置两个段，一个是GDT，一个是LDT，我们把这16个字节的信息放在struct TASK中。 123456789101112#define AR_LDT 0x0082struct TASK &#123; int sel, flags; /* sel偼GDT偺斣崋偺偙偲 */ int level, priority; struct FIFO32 fifo; struct TSS32 tss; struct SEGMENT_DESCRIPTOR ldt[2]; struct CONSOLE *cons; int ds_base, cons_stack;&#125;; 123456789101112131415mtask.c 文件struct TASK *task_init(struct MEMMAN *memman)&#123; for (i = 0; i &lt; MAX_TASKS; i++) &#123; taskctl-&gt;tasks0[i].flags = 0; taskctl-&gt;tasks0[i].sel = (TASK_GDT0 + i) * 8; taskctl-&gt;tasks0[i].tss.ldtr = (TASK_GDT0 + MAX_TASKS + i) * 8; set_segmdesc(gdt + TASK_GDT0 + i, 103, (int) &amp;taskctl-&gt;tasks0[i].tss, AR_TSS32); set_segmdesc(gdt + TASK_GDT0 + MAX_TASKS + i, 15, (int) taskctl-&gt;tasks0[i].ldt, AR_LDT); &#125; return task;&#125; 1234567891011121314151617181920console.c 文件int cmd_app(struct CONSOLE *cons, int *fat, char *cmdline)&#123; if (finfo != 0) &#123; if (finfo-&gt;size &gt;= 36 &amp;&amp; strncmp(p + 4, &quot;Hari&quot;, 4) == 0 &amp;&amp; *p == 0x00) &#123; set_segmdesc(task-&gt;ldt + 0, finfo-&gt;size - 1, (int) p, AR_CODE32_ER + 0x60); set_segmdesc(task-&gt;ldt + 1, segsiz - 1, (int) q, AR_DATA32_RW + 0x60); start_app(0x1b, 0 * 8 + 4, esp, 1 * 8 + 4, &amp;(task-&gt;tss.esp0)); &#125; else &#123; &#125; return 1; &#125; return 0;&#125; 如果这样的写法，在多个应用程序同时运行时，应用程序的代码段号都为4，数据段号都为12。其实不然，由于这里我们使用的是LDT的段号，而每个任务都有自己专用的LDT，因此这样写完全没有问题。 优化应用程序的大小（harib24e）hello3.hrb 引用a_nask.nas文件，但其实只需要部分的函数。所以我们把每个函数都做成一个nas文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354api001.nas 文件[FORMAT &quot;WCOFF&quot;][INSTRSET &quot;i486p&quot;][BITS 32][FILE &quot;api001.nas&quot;] GLOBAL _api_putchar[SECTION .text]_api_putchar: ; void api_putchar(int c); MOV EDX,1 MOV AL,[ESP+4] ; c INT 0x40 RETapi002.nas 文件[FORMAT &quot;WCOFF&quot;][INSTRSET &quot;i486p&quot;][BITS 32][FILE &quot;api002.nas&quot;] GLOBAL _api_putstr0[SECTION .text]_api_putstr0: ; void api_putstr0(char *s); PUSH EBX MOV EDX,2 MOV EBX,[ESP+8] ; s INT 0x40 POP EBX RET api003.nas 文件[FORMAT &quot;WCOFF&quot;][INSTRSET &quot;i486p&quot;][BITS 32][FILE &quot;api003.nas&quot;] GLOBAL _api_putstr1[SECTION .text]_api_putstr1: ; void api_putstr1(char *s, int l); PUSH EBX MOV EDX,3 MOV EBX,[ESP+ 8] ; s MOV ECX,[ESP+12] ; l INT 0x40 POP EBX RET..... 1234567891011Makefile 文件OBJS_API = api001.obj api002.obj api003.obj api004.obj api005.obj api006.obj \\ api007.obj api008.obj api009.obj api010.obj api011.obj api012.obj \\ api013.obj api014.obj api015.obj api016.obj api017.obj api018.obj \\ api019.obj api020.objhello3.bim : hello3.obj $(OBJS_API) Makefile $(OBJ2BIM) @$(RULEFILE) out:hello3.bim map:hello3.map hello3.obj $(OBJS_API) 程序会自动识别它用到了哪些函数，然后就会链接哪些。 库（harib24f）库就是把很多歌.obj文件打包成一个文件，这样一来文件的数量就少了，整个系统的结构也精简了。 1234567GOLIB = $(TOOLPATH)golib00.exe apilib.lib : Makefile $(OBJS_API) $(GOLIB) $(OBJS_API) out:apilib.lib hello3.bim : hello3.obj apilib.lib Makefile $(OBJ2BIM) @$(RULEFILE) out:hello3.bim map:hello3.map hello3.obj apilib.lib 1234567891011121314151617181920212223apilib.h 文件void api_putchar(int c);void api_putstr0(char *s);void api_putstr1(char *s, int l);void api_end(void);int api_openwin(char *buf, int xsiz, int ysiz, int col_inv, char *title);void api_putstrwin(int win, int x, int y, int col, int len, char *str);void api_boxfilwin(int win, int x0, int y0, int x1, int y1, int col);void api_initmalloc(void);char *api_malloc(int size);void api_free(char *addr, int size);void api_point(int win, int x, int y, int col);void api_refreshwin(int win, int x0, int y0, int x1, int y1);void api_linewin(int win, int x0, int y0, int x1, int y1, int col);void api_closewin(int win);int api_getkey(int mode);int api_alloctimer(void);void api_inittimer(int timer, int data);void api_settimer(int timer, int time);void api_freetimer(int timer);void api_beep(int tone); 12345678910111213hello3.c 文件#include &quot;apilib.h&quot; /* 一句话就搞定了！ */void HariMain(void)&#123; api_putchar(&apos;h&apos;); api_putchar(&apos;e&apos;); api_putchar(&apos;l&apos;); api_putchar(&apos;l&apos;); api_putchar(&apos;o&apos;); api_end();&#125; 整理make环境（harib24g）将操作系统、应用程序和库的源文件隔离。 创建一个haribote的目录，将操作系统核心的源代码以及Makefile移动到这里。创建一个apilib的目录，将库相关的源文件以及Makefile移动到这里。每个应用程序有一个目录， 将应用程序相关的源文件以及Makefile放到这里。","tags":[{"name":"30天自制操作系统","slug":"30天自制操作系统","permalink":"http://yoursite.com/tags/30天自制操作系统/"},{"name":"保护应用程序","slug":"保护应用程序","permalink":"http://yoursite.com/tags/保护应用程序/"},{"name":"优化应用程序","slug":"优化应用程序","permalink":"http://yoursite.com/tags/优化应用程序/"}]},{"title":"26 自制操作系统第二十六天","date":"2018-02-23T09:00:00.000Z","path":"2018/02/23/omake_26/","text":"项目地址 1234567891011主要内容：1. 提高窗口移动速度（1）（harib23a）2. 提高窗口移动速度（2）（harib23b）3. 提高窗口移动速度（3）（harib23c)4. 提高窗口移动速度（4）（harib23d）5. 启动时只打开一个命令行窗口（harib23e）6. 增加更多的命令行窗口（harib23f）7. 关闭命令行窗口（1）（harib23g）8. 关闭命令行窗口（2）（harib23h)9. start命令（harib23i）10. ncst命令（harib23j） 提高窗口移动速度（1）（harib23a）修改sheet_refreshmap这个函数。去掉if语句 12345678910111213141516171819202122232425262728void sheet_refreshmap(struct SHTCTL *ctl, int vx0, int vy0, int vx1, int vy1, int h0)&#123; for (h = h0; h &lt;= ctl-&gt;top; h++) &#123; if (sht-&gt;col_inv == -1) &#123; /* 无透明色图层专用的高速版 */ for (by = by0; by &lt; by1; by++) &#123; vy = sht-&gt;vy0 + by; for (bx = bx0; bx &lt; bx1; bx++) &#123; vx = sht-&gt;vx0 + bx; map[vy * ctl-&gt;xsize + vx] = sid; &#125; &#125; &#125; else &#123; /* 有透明色图层用的普通版 */ for (by = by0; by &lt; by1; by++) &#123; vy = sht-&gt;vy0 + by; for (bx = bx0; bx &lt; bx1; bx++) &#123; vx = sht-&gt;vx0 + bx; if (buf[by * sht-&gt;bxsize + bx] != sht-&gt;col_inv) &#123; map[vy * ctl-&gt;xsize + vx] = sid; &#125; &#125; &#125; &#125; &#125; return;&#125; 提高窗口移动速度（2）（harib23b）在汇编语言中，我们用16位寄存器代替8位寄存在来执行MOV指令的话，相邻的数据也会同时写入数据，而如果使用32位寄存器的话，仅1条指令就可以同时向相邻的4个地址写入值了。 一次赋值4个字节的值。 1234567891011121314151617181920212223242526272829303132333435void sheet_refreshmap(struct SHTCTL *ctl, int vx0, int vy0, int vx1, int vy1, int h0)&#123; int h, bx, by, vx, vy, bx0, by0, bx1, by1, sid4, *p; for (h = h0; h &lt;= ctl-&gt;top; h++) &#123; if (sht-&gt;col_inv == -1) &#123; if ((sht-&gt;vx0 &amp; 3) == 0 &amp;&amp; (bx0 &amp; 3) == 0 &amp;&amp; (bx1 &amp; 3) == 0) &#123; /* 无透明色图层专用的高速版（4字节） */ bx1 = (bx1 - bx0) / 4; sid4 = sid | sid &lt;&lt; 8 | sid &lt;&lt; 16 | sid &lt;&lt; 24; for (by = by0; by &lt; by1; by++) &#123; vy = sht-&gt;vy0 + by; vx = sht-&gt;vx0 + bx0; p = (int *) &amp;map[vy * ctl-&gt;xsize + vx]; for (bx = 0; bx &lt; bx1; bx++) &#123; p[bx] = sid4; &#125; &#125; &#125; else &#123; /* 无透明色图层专用的高速版（1字节） */ for (by = by0; by &lt; by1; by++) &#123; vy = sht-&gt;vy0 + by; for (bx = bx0; bx &lt; bx1; bx++) &#123; vx = sht-&gt;vx0 + bx; map[vy * ctl-&gt;xsize + vx] = sid; &#125; &#125; &#125; &#125; else &#123; &#125; &#125; return;&#125; 需要将窗口的x坐标赋值为4的倍数。 123456789101112131415console.c 文件int *hrb_api(int edi, int esi, int ebp, int esp, int ebx, int edx, int ecx, int eax)&#123; &#125; else if (edx == 5) &#123; sht = sheet_alloc(shtctl); sht-&gt;task = task; sht-&gt;flags |= 0x10; sheet_setbuf(sht, (char *) ebx + ds_base, esi, edi, eax); make_window8((char *) ebx + ds_base, esi, edi, (char *) ecx + ds_base, 0); sheet_slide(sht, ((shtctl-&gt;xsize - esi) / 2) &amp; ~3, (shtctl-&gt;ysize - edi) / 2); sheet_updown(sht, shtctl-&gt;top); reg[7] = (int) sht; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445void HariMain(void)&#123; int j, x, y, mmx = -1, mmy = -1, mmx2 = 0; for (;;) &#123; if (fifo32_status(&amp;fifo) == 0) &#123; &#125; else &#123; if (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; &#125; else if (512 &lt;= i &amp;&amp; i &lt;= 767) &#123; if ((mdec.btn &amp; 0x01) != 0) &#123; if (mmx &lt; 0) &#123; for (j = shtctl-&gt;top - 1; j &gt; 0; j--) &#123; sht = shtctl-&gt;sheets[j]; x = mx - sht-&gt;vx0; y = my - sht-&gt;vy0; if (0 &lt;= x &amp;&amp; x &lt; sht-&gt;bxsize &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; sht-&gt;bysize) &#123; if (sht-&gt;buf[y * sht-&gt;bxsize + x] != sht-&gt;col_inv) &#123; if (3 &lt;= x &amp;&amp; x &lt; sht-&gt;bxsize - 3 &amp;&amp; 3 &lt;= y &amp;&amp; y &lt; 21) &#123; mmx = mx; mmy = my; mmx2 = sht-&gt;vx0; &#125; &#125; &#125; &#125; &#125; else &#123; x = mx - mmx; y = my - mmy; sheet_slide(sht, (mmx2 + x + 2) &amp; ~3, sht-&gt;vy0 + y); mmy = my; &#125; &#125; else &#123; &#125; &#125; &#125; &#125; &#125;&#125; 提高窗口移动速度（3）（harib23c)一次性写入4字节这个办法应用到sheet_refreshsub。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465void sheet_refreshsub(struct SHTCTL *ctl, int vx0, int vy0, int vx1, int vy1, int h0, int h1)&#123; int h, bx, by, vx, vy, bx0, by0, bx1, by1, bx2, sid4, i, i1, *p, *q, *r; for (h = h0; h &lt;= h1; h++) &#123; if ((sht-&gt;vx0 &amp; 3) == 0) &#123; i = (bx0 + 3) / 4; /* bx0除以4（小数进位）*/ i1 = bx1 / 4; /* bx1除以4（小数舍位） */ i1 = i1 - i; sid4 = sid | sid &lt;&lt; 8 | sid &lt;&lt; 16 | sid &lt;&lt; 24; for (by = by0; by &lt; by1; by++) &#123; vy = sht-&gt;vy0 + by; for (bx = bx0; bx &lt; bx1 &amp;&amp; (bx &amp; 3) != 0; bx++) &#123; /* 前面被4除多余的部分逐个字节写入 */ vx = sht-&gt;vx0 + bx; if (map[vy * ctl-&gt;xsize + vx] == sid) &#123; vram[vy * ctl-&gt;xsize + vx] = buf[by * sht-&gt;bxsize + bx]; &#125; &#125; vx = sht-&gt;vx0 + bx; p = (int *) &amp;map[vy * ctl-&gt;xsize + vx]; q = (int *) &amp;vram[vy * ctl-&gt;xsize + vx]; r = (int *) &amp;buf[by * sht-&gt;bxsize + bx]; for (i = 0; i &lt; i1; i++) &#123; /* 4的倍数部分 */ if (p[i] == sid4) &#123; q[i] = r[i]; &#125; else &#123; bx2 = bx + i * 4; vx = sht-&gt;vx0 + bx2; if (map[vy * ctl-&gt;xsize + vx + 0] == sid) &#123; vram[vy * ctl-&gt;xsize + vx + 0] = buf[by * sht-&gt;bxsize + bx2 + 0]; &#125; if (map[vy * ctl-&gt;xsize + vx + 1] == sid) &#123; vram[vy * ctl-&gt;xsize + vx + 1] = buf[by * sht-&gt;bxsize + bx2 + 1]; &#125; if (map[vy * ctl-&gt;xsize + vx + 2] == sid) &#123; vram[vy * ctl-&gt;xsize + vx + 2] = buf[by * sht-&gt;bxsize + bx2 + 2]; &#125; if (map[vy * ctl-&gt;xsize + vx + 3] == sid) &#123; vram[vy * ctl-&gt;xsize + vx + 3] = buf[by * sht-&gt;bxsize + bx2 + 3]; &#125; &#125; &#125; for (bx += i1 * 4; bx &lt; bx1; bx++) &#123; /* 后面被4除多余的部分逐个字节写入 */ vx = sht-&gt;vx0 + bx; if (map[vy * ctl-&gt;xsize + vx] == sid) &#123; vram[vy * ctl-&gt;xsize + vx] = buf[by * sht-&gt;bxsize + bx]; &#125; &#125; &#125; &#125; else &#123; /* 1字节型 */ for (by = by0; by &lt; by1; by++) &#123; vy = sht-&gt;vy0 + by; for (bx = bx0; bx &lt; bx1; bx++) &#123; vx = sht-&gt;vx0 + bx; if (map[vy * ctl-&gt;xsize + vx] == sid) &#123; vram[vy * ctl-&gt;xsize + vx] = buf[by * sht-&gt;bxsize + bx]; &#125; &#125; &#125; &#125; &#125; return;&#125; 提高窗口移动速度（4）（harib23d）可能会出现这种问题，就是已经放开了鼠标，窗口却还在挪动。这是因为伴随图层移动所进行的绘图操作非常消耗时间，导师系统来不及处理FIFO中的鼠标移动数据。那么我们可以在接收到鼠标移动数据后不立即进行绘图操作，等FIFO为空时再进行绘图操作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859void HariMain(void)&#123; int j, x, y, mmx = -1, mmy = -1, mmx2 = 0; for (;;) &#123; if (fifo32_status(&amp;fifo) == 0) &#123; if (new_mx &gt;= 0) &#123; io_sti(); sheet_slide(sht_mouse, new_mx, new_my); new_mx = -1; &#125; else if (new_wx != 0x7fffffff) &#123; io_sti(); sheet_slide(sht, new_wx, new_wy); new_wx = 0x7fffffff; &#125; else &#123; task_sleep(task_a); io_sti(); &#125; &#125; else &#123; &#125; else if (512 &lt;= i &amp;&amp; i &lt;= 767) &#123; if (mouse_decode(&amp;mdec, i - 512) != 0) &#123; new_mx = mx; new_my = my; if ((mdec.btn &amp; 0x01) != 0) &#123; if (mmx &lt; 0) &#123; for (j = shtctl-&gt;top - 1; j &gt; 0; j--) &#123; if (0 &lt;= x &amp;&amp; x &lt; sht-&gt;bxsize &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; sht-&gt;bysize) &#123; if (sht-&gt;buf[y * sht-&gt;bxsize + x] != sht-&gt;col_inv) &#123; if (3 &lt;= x &amp;&amp; x &lt; sht-&gt;bxsize - 3 &amp;&amp; 3 &lt;= y &amp;&amp; y &lt; 21) &#123; mmx = mx; mmy = my; mmx2 = sht-&gt;vx0; new_wy = sht-&gt;vy0; &#125; &#125; &#125; &#125; &#125; else &#123; x = mx - mmx; y = my - mmy; new_wx = (mmx2 + x + 2) &amp; ~3; new_wy = new_wy + y; mmy = my; &#125; &#125; else &#123; mmx = -1; if (new_wx != 0x7fffffff) &#123; sheet_slide(sht, new_wx, new_wy); new_wx = 0x7fffffff; &#125; &#125; &#125; &#125; &#125;&#125; 启动时只打开一个命令行窗口（harib23e）规定按下 shift+F2就打开一个新的命令行窗口。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667void HariMain(void)&#123; /* sht_cons */ sht_cons[0] = open_console(shtctl, memtotal); sht_cons[1] = 0; sheet_slide(sht_back, 0, 0); sheet_slide(sht_cons[0], 32, 4); sheet_slide(sht_mouse, mx, my); sheet_updown(sht_back, 0); sheet_updown(sht_cons[0], 1); sheet_updown(sht_mouse, 2); key_win = sht_cons[0]; keywin_on(key_win); for (;;) &#123; if (fifo32_status(&amp;fifo) == 0) &#123; &#125; else &#123; if (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; if (i == 256 + 0x3c &amp;&amp; key_shift != 0 &amp;&amp; sht_cons[1] == 0) &#123; /* Shift+F2 */ sht_cons[1] = open_console(shtctl, memtotal); sheet_slide(sht_cons[1], 32, 4); sheet_updown(sht_cons[1], shtctl-&gt;top); /* 自动将输入焦点切换到新打开的命令行窗口 */ keywin_off(key_win); key_win = sht_cons[1]; keywin_on(key_win); &#125; &#125; else if (512 &lt;= i &amp;&amp; i &lt;= 767) &#123; &#125; &#125; &#125;&#125;struct SHEET *open_console(struct SHTCTL *shtctl, unsigned int memtotal)&#123; struct MEMMAN *memman = (struct MEMMAN *) MEMMAN_ADDR; struct SHEET *sht = sheet_alloc(shtctl); unsigned char *buf = (unsigned char *) memman_alloc_4k(memman, 256 * 165); struct TASK *task = task_alloc(); int *cons_fifo = (int *) memman_alloc_4k(memman, 128 * 4); sheet_setbuf(sht, buf, 256, 165, -1); /* ?????F??? */ make_window8(buf, 256, 165, &quot;console&quot;, 0); make_textbox8(sht, 8, 28, 240, 128, COL8_000000); task-&gt;tss.esp = memman_alloc_4k(memman, 64 * 1024) + 64 * 1024 - 12; task-&gt;tss.eip = (int) &amp;console_task; task-&gt;tss.es = 1 * 8; task-&gt;tss.cs = 2 * 8; task-&gt;tss.ss = 1 * 8; task-&gt;tss.ds = 1 * 8; task-&gt;tss.fs = 1 * 8; task-&gt;tss.gs = 1 * 8; *((int *) (task-&gt;tss.esp + 4)) = (int) sht; *((int *) (task-&gt;tss.esp + 8)) = memtotal; task_run(task, 2, 2); /* level=2, priority=2 */ sht-&gt;task = task; sht-&gt;flags |= 0x20; /* ?J?[?\\?????? */ fifo32_init(&amp;task-&gt;fifo, 128, cons_fifo, task); return sht;&#125; 增加更多的命令行窗口（harib23f）1234567891011121314151617181920212223242526272829303132333435void HariMain(void)&#123; /* sht_cons */ key_win = open_console(shtctl, memtotal); sheet_slide(sht_back, 0, 0); sheet_slide(key_win, 32, 4); sheet_slide(sht_mouse, mx, my); sheet_updown(sht_back, 0); sheet_updown(key_win, 1); sheet_updown(sht_mouse, 2); keywin_on(key_win); for (;;) &#123; if (fifo32_status(&amp;fifo) == 0) &#123; &#125; else &#123; if (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; if (i == 256 + 0x3c &amp;&amp; key_shift != 0) &#123; /* Shift+F2 */ keywin_off(key_win); key_win = open_console(shtctl, memtotal); sheet_slide(key_win, 32, 4); sheet_updown(key_win, shtctl-&gt;top); keywin_on(key_win); &#125; &#125; else if (512 &lt;= i &amp;&amp; i &lt;= 767) &#123; &#125; &#125; &#125;&#125; 关闭命令行窗口（1）（harib23g）在命令行窗口中输入“exit”命令就可以关闭当前窗口。 增加cons_task成员，用来保存栈的地址。1234567891011121314151617181920212223242526272829303132333435363738struct TASK &#123; int sel, flags; int level, priority; struct FIFO32 fifo; struct TSS32 tss; struct CONSOLE *cons; int ds_base, cons_stack;&#125;;struct SHEET *open_console(struct SHTCTL *shtctl, unsigned int memtotal)&#123; task-&gt;cons_stack = memman_alloc_4k(memman, 64 * 1024); task-&gt;tss.esp = task-&gt;cons_stack + 64 * 1024 - 12; return sht;&#125;void close_constask(struct TASK *task)&#123; struct MEMMAN *memman = (struct MEMMAN *) MEMMAN_ADDR; task_sleep(task); memman_free_4k(memman, task-&gt;cons_stack, 64 * 1024); memman_free_4k(memman, (int) task-&gt;fifo.buf, 128 * 4); task-&gt;flags = 0; /* task_free(task); ????? */ return;&#125;void close_console(struct SHEET *sht)&#123; struct MEMMAN *memman = (struct MEMMAN *) MEMMAN_ADDR; struct TASK *task = sht-&gt;task; memman_free_4k(memman, (int) sht-&gt;buf, 256 * 165); sheet_free(sht); close_constask(task); return;&#125; 12345678910111213141516171819202122232425262728console.c文件void cons_runcmd(char *cmdline, struct CONSOLE *cons, int *fat, int memtotal)&#123; &#125; else if (strcmp(cmdline, &quot;exit&quot;) == 0) &#123; cmd_exit(cons, fat); &#125; else if (cmdline[0] != 0) &#123; return;&#125;void cmd_exit(struct CONSOLE *cons, int *fat)&#123; struct MEMMAN *memman = (struct MEMMAN *) MEMMAN_ADDR; struct TASK *task = task_now(); struct SHTCTL *shtctl = (struct SHTCTL *) *((int *) 0x0fe4); struct FIFO32 *fifo = (struct FIFO32 *) *((int *) 0x0fec); timer_cancel(cons-&gt;timer); memman_free_4k(memman, (int) fat, 4 * 2880); io_cli(); fifo32_put(fifo, cons-&gt;sht - shtctl-&gt;sheets0 + 768); io_sti(); for (;;) &#123; task_sleep(task); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354void HariMain(void)&#123; *((int *) 0x0fec) = (int) &amp;fifo; for (;;) &#123; if (fifo32_status(&amp;fifo) == 0) &#123; &#125; else &#123; if (key_win != 0 &amp;&amp; key_win-&gt;flags == 0) &#123; if (shtctl-&gt;top == 1) &#123; key_win = 0; &#125; else &#123; key_win = shtctl-&gt;sheets[shtctl-&gt;top - 1]; keywin_on(key_win); &#125; &#125; if (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; if (s[0] != 0 &amp;&amp; key_win != 0) &#123; fifo32_put(&amp;key_win-&gt;task-&gt;fifo, s[0] + 256); &#125; if (i == 256 + 0x0f &amp;&amp; key_win != 0) &#123; /* Tab */ &#125; if (i == 256 + 0x3b &amp;&amp; key_shift != 0 &amp;&amp; key_win != 0) &#123; /* Shift+F1 */ task = key_win-&gt;task; if (task != 0 &amp;&amp; task-&gt;tss.ss0 != 0) &#123; cons_putstr0(task-&gt;cons, &quot;\\nBreak(key) :\\n&quot;); io_cli(); task-&gt;tss.eax = (int) &amp;(task-&gt;tss.esp0); task-&gt;tss.eip = (int) asm_end_app; io_sti(); &#125; &#125; if (i == 256 + 0x3c &amp;&amp; key_shift != 0) &#123; /* Shift+F2 */ if (key_win != 0) &#123; keywin_off(key_win); &#125; key_win = open_console(shtctl, memtotal); sheet_slide(key_win, 32, 4); sheet_updown(key_win, shtctl-&gt;top); keywin_on(key_win); &#125; &#125; else if (512 &lt;= i &amp;&amp; i &lt;= 767) &#123; &#125; else if (768 &lt;= i &amp;&amp; i &lt;= 1023) &#123; /* 命令行窗口关闭处理 */ close_console(shtctl-&gt;sheets0 + (i - 768)); &#125; &#125; &#125;&#125; 关闭命令行窗口（2）（harib23h)实现用鼠标关闭命令行窗口的功能。 向命令行窗口任务发送4这个数据，命令行窗口接收到这个数据后则开始执行exit命令。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849void HariMain(void)&#123; for (;;) &#123; if (fifo32_status(&amp;fifo) == 0) &#123; &#125; else &#123; if (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; &#125; else if (512 &lt;= i &amp;&amp; i &lt;= 767) &#123; if (mouse_decode(&amp;mdec, i - 512) != 0) &#123; if ((mdec.btn &amp; 0x01) != 0) &#123; if (mmx &lt; 0) &#123; for (j = shtctl-&gt;top - 1; j &gt; 0; j--) &#123; if (0 &lt;= x &amp;&amp; x &lt; sht-&gt;bxsize &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; sht-&gt;bysize) &#123; if (sht-&gt;buf[y * sht-&gt;bxsize + x] != sht-&gt;col_inv) &#123; if (sht-&gt;bxsize - 21 &lt;= x &amp;&amp; x &lt; sht-&gt;bxsize - 5 &amp;&amp; 5 &lt;= y &amp;&amp; y &lt; 19) &#123; if ((sht-&gt;flags &amp; 0x10) != 0) &#123; /* 是否为应用程序窗口 */ task = sht-&gt;task; cons_putstr0(task-&gt;cons, &quot;\\nBreak(mouse) :\\n&quot;); io_cli(); task-&gt;tss.eax = (int) &amp;(task-&gt;tss.esp0); task-&gt;tss.eip = (int) asm_end_app; io_sti(); &#125; else &#123; task = sht-&gt;task; io_cli(); fifo32_put(&amp;task-&gt;fifo, 4); io_sti(); &#125; &#125; break; &#125; &#125; &#125; &#125; else &#123; &#125; &#125; else &#123; &#125; &#125; &#125; else if (768 &lt;= i &amp;&amp; i &lt;= 1023) &#123; &#125; &#125; &#125;&#125; start命令（harib23i）start命令就是打开一个新的命令行窗口并运行指定的应用程序。 1234567891011121314151617181920212223void cons_runcmd(char *cmdline, struct CONSOLE *cons, int *fat, int memtotal)&#123; &#125; else if (strncmp(cmdline, &quot;start &quot;, 6) == 0) &#123; cmd_start(cons, cmdline, memtotal); &#125; else if (cmdline[0] != 0) &#123;&#125;void cmd_start(struct CONSOLE *cons, char *cmdline, int memtotal)&#123; struct SHTCTL *shtctl = (struct SHTCTL *) *((int *) 0x0fe4); struct SHEET *sht = open_console(shtctl, memtotal); struct FIFO32 *fifo = &amp;sht-&gt;task-&gt;fifo; int i; sheet_slide(sht, 32, 4); sheet_updown(sht, shtctl-&gt;top); for (i = 6; cmdline[i] != 0; i++) &#123; fifo32_put(fifo, cmdline[i] + 256); &#125; fifo32_put(fifo, 10 + 256); /* Enter */ cons_newline(cons); return;&#125; ncst命令（harib23j）ncst命令就是不打开新命令窗口的start命令。 实现方法：就是打开一个任务，但是不绘制命令行图层。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139void cons_runcmd(char *cmdline, struct CONSOLE *cons, int *fat, int memtotal)&#123; if (strcmp(cmdline, &quot;mem&quot;) == 0 &amp;&amp; cons-&gt;sht != 0) &#123; cmd_mem(cons, memtotal); &#125; else if (strcmp(cmdline, &quot;cls&quot;) == 0 &amp;&amp; cons-&gt;sht != 0) &#123; cmd_cls(cons); &#125; else if (strcmp(cmdline, &quot;dir&quot;) == 0 &amp;&amp; cons-&gt;sht != 0) &#123; cmd_dir(cons); &#125; else if (strncmp(cmdline, &quot;type &quot;, 5) == 0 &amp;&amp; cons-&gt;sht != 0) &#123; cmd_type(cons, fat, cmdline); &#125; else if (strncmp(cmdline, &quot;start &quot;, 6) == 0) &#123; cmd_start(cons, cmdline, memtotal); &#125; else if (strncmp(cmdline, &quot;ncst &quot;, 5) == 0) &#123; cmd_ncst(cons, cmdline, memtotal); &#125; else if (strcmp(cmdline, &quot;exit&quot;) == 0) &#123; cmd_exit(cons, fat); &#125; else if (cmdline[0] != 0) &#123; &#125; return;&#125;void cmd_ncst(struct CONSOLE *cons, char *cmdline, int memtotal) &#123; struct TASK *task = open_constask(0, memtotal); struct FIFO32 *fifo = &amp;task-&gt;fifo; int i; for (i = 5; cmdline[i] != 0; i++) &#123; fifo32_put(fifo, cmdline[i] + 256); &#125; fifo32_put(fifo, 10 + 256); cons_newline(cons); return;&#125;void cons_putchar(struct CONSOLE *cons, int chr, char move)&#123; char s[2]; s[0] = chr; s[1] = 0; if (s[0] == 0x09) &#123; /* 制表符 */ for (;;) &#123; if (cons-&gt;sht != 0) &#123; putfonts8_asc_sht(cons-&gt;sht, cons-&gt;cur_x, cons-&gt;cur_y, COL8_FFFFFF, COL8_000000, &quot; &quot;, 1); &#125; &#125; &#125; else if (s[0] == 0x0a) &#123; /* 换行 */ &#125; else if (s[0] == 0x0d) &#123; /* 回车 */ &#125; else &#123; /* 一般字符 */ if (cons-&gt;sht != 0) &#123; putfonts8_asc_sht(cons-&gt;sht, cons-&gt;cur_x, cons-&gt;cur_y, COL8_FFFFFF, COL8_000000, s, 1); &#125; if (move != 0) &#123; &#125; &#125; return;&#125;void cons_newline(struct CONSOLE *cons)&#123; if (cons-&gt;cur_y &lt; 28 + 112) &#123; &#125; else &#123; if (sheet != 0) &#123; for (y = 28; y &lt; 28 + 112; y++) &#123; &#125; for (y = 28 + 112; y &lt; 28 + 128; y++) &#123; &#125; sheet_refresh(sheet, 8, 28, 8 + 240, 28 + 128); &#125; &#125;&#125;void console_task(struct SHEET *sheet, int memtotal)&#123; if (sheet != 0) &#123; cons.timer = timer_alloc(); timer_init(cons.timer, &amp;task-&gt;fifo, 1); timer_settime(cons.timer, 50); &#125; for (;;) &#123; io_cli(); if (fifo32_status(&amp;task-&gt;fifo) == 0) &#123; task_sleep(task); io_sti(); &#125; else &#123; if (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; if (i == 8 + 256) &#123; &#125; else if (i == 10 + 256) &#123; /* Enter */ if (sheet == 0) &#123; cmd_exit(&amp;cons, fat); &#125; cons_putchar(&amp;cons, &apos;&gt;&apos;, 1); &#125; else &#123; &#125; &#125; if (sheet != 0) &#123; if (cons.cur_c &gt;= 0) &#123; boxfill8(sheet-&gt;buf, sheet-&gt;bxsize, cons.cur_c, cons.cur_x, cons.cur_y, cons.cur_x + 7, cons.cur_y + 15); &#125; sheet_refresh(sheet, cons.cur_x, cons.cur_y, cons.cur_x + 8, cons.cur_y + 16); &#125; &#125; &#125;&#125;void cmd_exit(struct CONSOLE *cons, int *fat) &#123; struct MEMMAN *memman = (struct MEMMAN *) MEMMAN_ADDR; struct TASK *task = task_now(); struct SHTCTL *shtctl = (struct SHTCTL *) *((int *) 0x0fe4); struct FIFO32 *fifo = (struct FIFO32 *) *((int *) 0x0fec); timer_cancel(cons-&gt;timer); memman_free_4k(memman, (int) fat, 4 * 2880); io_cli(); if (cons-&gt;sht != 0) &#123; fifo32_put(fifo, cons-&gt;sht - shtctl-&gt;sheets0 + 768); &#125; else &#123; fifo32_put(fifo, task - taskctl-&gt;tasks0 + 1024); &#125; io_sti(); for(;;) &#123; task_sleep(task); &#125; &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253void HariMain(void)&#123; for (;;) &#123; if (fifo32_status(&amp;fifo) == 0) &#123; &#125; else &#123; if (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; &#125; else if (512 &lt;= i &amp;&amp; i &lt;= 767) &#123; &#125; else if (768 &lt;= i &amp;&amp; i &lt;= 1023) &#123; &#125; else if (1024 &lt;= i &amp;&amp; i &lt;= 2023) &#123; close_constask(taskctl-&gt;tasks0 + (i - 1024)); &#125; &#125; &#125;&#125;struct TASK *open_constask(struct SHEET *sht, unsigned int memtotal) &#123; struct MEMMAN *memman = (struct MEMMAN *) MEMMAN_ADDR; struct TASK *task = task_alloc(); int *cons_fifo = (int *) memman_alloc_4k(memman, 128 * 4); task-&gt;cons_stack = memman_alloc_4k(memman, 64 * 1024); task-&gt;tss.esp = task-&gt;cons_stack + 64 * 1024 - 12; task-&gt;tss.eip = (int) &amp;console_task; task-&gt;tss.es = 1 * 8; task-&gt;tss.cs = 2 * 8; task-&gt;tss.ss = 1 * 8; task-&gt;tss.ds = 1 * 8; task-&gt;tss.fs = 1 * 8; task-&gt;tss.gs = 1 * 8; *((int *) (task-&gt;tss.esp + 4)) = (int) sht; *((int *) (task-&gt;tss.esp + 8)) = memtotal; task_run(task, 2, 2); /* level=2, priority=2 */ fifo32_init(&amp;task-&gt;fifo, 128, cons_fifo, task); return task; &#125;struct SHEET *open_console(struct SHTCTL *shtctl, unsigned int memtotal) &#123; struct MEMMAN *memman = (struct MEMMAN *) MEMMAN_ADDR; struct SHEET *sht = sheet_alloc(shtctl); unsigned char *buf = (unsigned char *) memman_alloc_4k(memman, 256 * 165); sheet_setbuf(sht, buf, 256, 165, -1); /* ?????? */ make_window8(buf, 256, 165, &quot;console&quot;, 0); make_textbox8(sht, 8, 28, 240, 128, COL8_000000); sht-&gt;task = open_constask(sht, memtotal); sht-&gt;flags |= 0x20; /* 有光标 */ return sht; &#125; 用鼠标点击应用程序窗口的“×”按钮无法关闭窗口！用shift+F1强制关闭也不行。不过按回车键可以正常退出。","tags":[{"name":"30天自制操作系统","slug":"30天自制操作系统","permalink":"http://yoursite.com/tags/30天自制操作系统/"},{"name":"提高窗口移动速度","slug":"提高窗口移动速度","permalink":"http://yoursite.com/tags/提高窗口移动速度/"},{"name":"命令行窗口","slug":"命令行窗口","permalink":"http://yoursite.com/tags/命令行窗口/"}]},{"title":"25 自制操作系统第二十五天","date":"2018-02-04T09:00:00.000Z","path":"2018/02/04/omake_25/","text":"项目地址 1234567891011主要内容：1. 蜂鸣器发声（harib22a）2. 增加更多的颜色（1）（harib22b）3. 增加更多的颜色（2）（harib22c)4. 窗口初始位置（harib22d）5. 增加命令行窗口（1）（harib22e）6. 增加命令行窗口（2）（harib22f）7. 增加命令行窗口（3）（harib22g）8. 增加命令行窗口（4）（harib22h)9. 变得像真正的操作系统（1）（harib22i）10. 变得想真正的操作系统（2）（harib22j） 蜂鸣器发声（harib22a）蜂鸣器发声的控制 高音操作：AL = 0xb6; OUT(0x43, AL);AL = 设定值的低位8bit; OUT(0x42, AL);AL = 设定值的高位8bit; OUT(0x42, AL);设定0时当作65536来处理发声的音高为时钟除以设定值，也就是说设定值为1000时相当于发出1.19318KHz的声音；设定置为10000时相当于119.318Hz。 蜂鸣器ON/OFF:使用I/O端口0x61控制。ON：IN(AL, 0x61); AL|=0x43; AL&amp;=0x0f; OUT(0x61, AL);OFF:IN(AL, 0x61); AL&amp;=0xd; OUT(0x61, AL); EDX = 20EAX = 声音频率（单位是mHz）频率设为0时，表示停止发生123456789101112131415161718int *hrb_api(int edi, int esi, int ebp, int esp, int ebx, int edx, int ecx, int eax)&#123; &#125; else if (edx == 20) &#123; if (eax == 0) &#123; i = io_in8(0x61); io_out8(0x61, i &amp; 0x0d); &#125; else &#123; i = 1193180000 / eax; io_out8(0x43, 0xb6); io_out8(0x42, i &amp; 0xff); io_out8(0x42, i &gt;&gt; 8); i = io_in8(0x61); io_out8(0x61, (i | 0x03) &amp; 0x0f); &#125; &#125; return 0;&#125; 12345_api_beep: ; void api_beep(int tone); MOV EDX,20 MOV EAX,[ESP+4] ; tone INT 0x40 RET 1234567891011121314151617181920212223void api_end(void);int api_getkey(int mode);int api_alloctimer(void);void api_inittimer(int timer, int data);void api_settimer(int timer, int time);void api_beep(int tone);void HariMain(void)&#123; int i, timer; timer = api_alloctimer(); api_inittimer(timer, 128); for (i = 20000000; i &gt;= 20000; i -= i / 100) &#123; /* 20KHz~20Hz*/ api_beep(i); api_settimer(timer, 1); /* 0.01?b */ if (api_getkey(1) != 128) &#123; break; &#125; &#125; api_beep(0); api_end();&#125; 增加更多的颜色（1）（harib22b）为每种颜色赋予6个色阶，就可以定义6×6×6=216个颜色。 123456789101112131415void init_palette(void) set_palette(0, 15, table_rgb); for (b = 0; b &lt; 6; b++) &#123; for (g = 0; g &lt; 6; g++) &#123; for (r = 0; r &lt; 6; r++) &#123; table2[(r + g * 6 + b * 36) * 3 + 0] = r * 51; table2[(r + g * 6 + b * 36) * 3 + 1] = g * 51; table2[(r + g * 6 + b * 36) * 3 + 2] = b * 51; &#125; &#125; &#125; set_palette(16, 231, table2); return;&#125; 123456789101112131415161718192021222324252627int api_openwin(char *buf, int xsiz, int ysiz, int col_inv, char *title);void api_initmalloc(void);char *api_malloc(int size);void api_refreshwin(int win, int x0, int y0, int x1, int y1);void api_linewin(int win, int x0, int y0, int x1, int y1, int col);int api_getkey(int mode);void api_end(void);void HariMain(void)&#123; char *buf; int win, x, y, r, g, b; api_initmalloc(); buf = api_malloc(144 * 164); win = api_openwin(buf, 144, 164, -1, &quot;color&quot;); for (y = 0; y &lt; 128; y++) &#123; for (x = 0; x &lt; 128; x++) &#123; r = x * 2; g = y * 2; b = 0; buf[(x + 8) + (y + 28) * 144] = 16 + (r / 43) + (g / 43) * 6 + (b / 43) * 36; &#125; &#125; api_refreshwin(win, 8, 28, 136, 156); api_getkey(1); api_end();&#125; 增加更多的颜色（2）（harib22c)两种颜色交替排列，可以定义出更多的颜色。 123456789101112131415161718192021222324252627282930313233343536373839404142int api_openwin(char *buf, int xsiz, int ysiz, int col_inv, char *title);void api_initmalloc(void);char *api_malloc(int size);void api_refreshwin(int win, int x0, int y0, int x1, int y1);void api_linewin(int win, int x0, int y0, int x1, int y1, int col);int api_getkey(int mode);void api_end(void);unsigned char rgb2pal(int r, int g, int b, int x, int y);void HariMain(void)&#123; char *buf; int win, x, y; api_initmalloc(); buf = api_malloc(144 * 164); win = api_openwin(buf, 144, 164, -1, &quot;color2&quot;); for (y = 0; y &lt; 128; y++) &#123; for (x = 0; x &lt; 128; x++) &#123; buf[(x + 8) + (y + 28) * 144] = rgb2pal(x * 2, y * 2, 0, x, y); &#125; &#125; api_refreshwin(win, 8, 28, 136, 156); api_getkey(1); api_end();&#125;unsigned char rgb2pal(int r, int g, int b, int x, int y)&#123; static int table[4] = &#123; 3, 1, 0, 2 &#125;; int i; x &amp;= 1; /* ????????? */ y &amp;= 1; i = table[x + y * 2]; r = (r * 21) / 256; g = (g * 21) / 256; b = (b * 21) / 256; r = (r + i) / 4; g = (g + i) / 4; b = (b + i) / 4; return 16 + r + g * 6 + b * 36;&#125; 窗口初始位置（harib22d）让应用程序窗口显示在最中间的位置。 123456789int *hrb_api(int edi, int esi, int ebp, int esp, int ebx, int edx, int ecx, int eax)&#123; &#125; else if (edx == 5) &#123; sheet_slide(sht, (shtctl-&gt;xsize - esi) / 2, (shtctl-&gt;ysize - edi) / 2); sheet_updown(sht, shtctl-&gt;top); &#125; return 0;&#125; 增加命令行窗口（1）（harib22e）现在想同时运行两个程序。那就开两个命令行窗口，然后两个命令行窗口输入两条指令。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182void HariMain(void)&#123; unsigned char *buf_back, buf_mouse[256], *buf_win, *buf_cons[2]; struct SHEET *sht_back, *sht_mouse, *sht_win, *sht_cons[2]; struct TASK *task_a, *task_cons[2]; /* sht_cons */ for (i = 0; i &lt; 2; i++) &#123; sht_cons[i] = sheet_alloc(shtctl); buf_cons[i] = (unsigned char *) memman_alloc_4k(memman, 256 * 165); sheet_setbuf(sht_cons[i], buf_cons[i], 256, 165, -1); make_window8(buf_cons[i], 256, 165, &quot;console&quot;, 0); make_textbox8(sht_cons[i], 8, 28, 240, 128, COL8_000000); task_cons[i] = task_alloc(); task_cons[i]-&gt;tss.esp = memman_alloc_4k(memman, 64 * 1024) + 64 * 1024 - 12; task_cons[i]-&gt;tss.eip = (int) &amp;console_task; task_cons[i]-&gt;tss.es = 1 * 8; task_cons[i]-&gt;tss.cs = 2 * 8; task_cons[i]-&gt;tss.ss = 1 * 8; task_cons[i]-&gt;tss.ds = 1 * 8; task_cons[i]-&gt;tss.fs = 1 * 8; task_cons[i]-&gt;tss.gs = 1 * 8; *((int *) (task_cons[i]-&gt;tss.esp + 4)) = (int) sht_cons[i]; *((int *) (task_cons[i]-&gt;tss.esp + 8)) = memtotal; task_run(task_cons[i], 2, 2); /* level=2, priority=2 */ sht_cons[i]-&gt;task = task_cons[i]; sht_cons[i]-&gt;flags |= 0x20; /* 有光标 */ &#125; for (;;) &#123; io_cli(); if (fifo32_status(&amp;fifo) == 0) &#123; &#125; else &#123; if (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; if (i == 256 + 0x3b &amp;&amp; key_shift != 0 &amp;&amp; task_cons[0]-&gt;tss.ss0 != 0) &#123; /* Shift+F1 */ cons = (struct CONSOLE *) *((int *) 0x0fec); cons_putstr0(cons, &quot;\\nBreak(key) :\\n&quot;); io_cli(); task_cons[0]-&gt;tss.eax = (int) &amp;(task_cons[0]-&gt;tss.esp0); task_cons[0]-&gt;tss.eip = (int) asm_end_app; io_sti(); &#125; &#125; else if (512 &lt;= i &amp;&amp; i &lt;= 767) &#123; if (mouse_decode(&amp;mdec, i - 512) != 0) &#123; if ((mdec.btn &amp; 0x01) != 0) &#123; if (mmx &lt; 0) &#123; for (j = shtctl-&gt;top - 1; j &gt; 0; j--) &#123; if (0 &lt;= x &amp;&amp; x &lt; sht-&gt;bxsize &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; sht-&gt;bysize) &#123; if (sht-&gt;bxsize - 21 &lt;= x &amp;&amp; x &lt; sht-&gt;bxsize - 5 &amp;&amp; 5 &lt;= y &amp;&amp; y &lt; 19) &#123; if ((sht-&gt;flags &amp; 0x10) != 0) &#123; cons = (struct CONSOLE *) *((int *) 0x0fec); cons_putstr0(cons, &quot;\\nBreak(mouse) :\\n&quot;); io_cli(); task_cons[0]-&gt;tss.eax = (int) &amp;(task_cons[0]-&gt;tss.esp0); task_cons[0]-&gt;tss.eip = (int) asm_end_app; io_sti(); &#125; &#125; break; &#125; &#125; &#125; &#125; else &#123; &#125; &#125; else &#123; &#125; &#125; &#125; else if (i &lt;= 1) &#123; &#125; &#125; &#125;&#125; 这样是不正确的，这个窗口显示的内容会出现在另一个窗口上。 增加命令行窗口（2）（harib22f）((int ) 0x0fec) = (int) &cons; 是写死的。((int ) 0xfe8) = (int) q; 是写死的。 12345678struct TASK &#123; int sel, flags; /* sel偼GDT偺斣崋偺偙偲 */ int level, priority; struct FIFO32 fifo; struct TSS32 tss; struct CONSOLE *cons; int ds_base;&#125;; 12345678910void console_task(struct SHEET *sheet, int memtotal)&#123; task-&gt;cons = &amp;cons;&#125;int cmd_app(struct CONSOLE *cons, int *fat, char *cmdline)&#123; q = (char *) memman_alloc_4k(memman, segsiz); task-&gt;ds_base = (int) q;&#125; 然后在其他用到这两个东西都换一下。 这样是可以运行成功的，但是按下回车键之后，会出错。 增加命令行窗口（3）（harib22g）原因是应用程序的内存段有问题。 color.hrb准备的1003号代码段和1004号数据段，被color2.hrb所用的段给覆盖掉了。 为每个应用程序分配不同的段就好了。 12345678910111213141516171819int cmd_app(struct CONSOLE *cons, int *fat, char *cmdline)&#123; if (finfo != 0) &#123; p = (char *) memman_alloc_4k(memman, finfo-&gt;size); file_loadfile(finfo-&gt;clustno, finfo-&gt;size, p, fat, (char *) (ADR_DISKIMG + 0x003e00)); if (finfo-&gt;size &gt;= 36 &amp;&amp; strncmp(p + 4, &quot;Hari&quot;, 4) == 0 &amp;&amp; *p == 0x00) &#123; set_segmdesc(gdt + task-&gt;sel / 8 + 1000, finfo-&gt;size - 1, (int) p, AR_CODE32_ER + 0x60); set_segmdesc(gdt + task-&gt;sel / 8 + 2000, segsiz - 1, (int) q, AR_DATA32_RW + 0x60); &#125; else &#123; cons_putstr0(cons, &quot;.hrb file format error.\\n&quot;); &#125; memman_free_4k(memman, (int) p, finfo-&gt;size); cons_newline(cons); return 1; &#125; return 0;&#125; 增加命令行窗口（4）（harib22h)解决shift+F1 和 ×按钮的执行。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758void HariMain(void)&#123; struct TASK *task_a, *task_cons[2], *task; for (;;) &#123; io_cli(); if (fifo32_status(&amp;fifo) == 0) &#123; &#125; else &#123; if (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; if (i == 256 + 0x3b &amp;&amp; key_shift != 0) &#123; task = key_win-&gt;task; if (task != 0 &amp;&amp; task-&gt;tss.ss0 != 0) &#123; /* Shift+F1 */ cons_putstr0(task-&gt;cons, &quot;\\nBreak(key) :\\n&quot;); io_cli(); task-&gt;tss.eax = (int) &amp;(task-&gt;tss.esp0); task-&gt;tss.eip = (int) asm_end_app; io_sti(); &#125; &#125; &#125; else if (512 &lt;= i &amp;&amp; i &lt;= 767) &#123; if (mouse_decode(&amp;mdec, i - 512) != 0) &#123; if ((mdec.btn &amp; 0x01) != 0) &#123; if (mmx &lt; 0) &#123; for (j = shtctl-&gt;top - 1; j &gt; 0; j--) &#123; if (0 &lt;= x &amp;&amp; x &lt; sht-&gt;bxsize &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; sht-&gt;bysize) &#123; if (sht-&gt;bxsize - 21 &lt;= x &amp;&amp; x &lt; sht-&gt;bxsize - 5 &amp;&amp; 5 &lt;= y &amp;&amp; y &lt; 19) &#123; if ((sht-&gt;flags &amp; 0x10) != 0) &#123; task = sht-&gt;task; cons_putstr0(task-&gt;cons, &quot;\\nBreak(mouse) :\\n&quot;); io_cli(); task-&gt;tss.eax = (int) &amp;(task-&gt;tss.esp0); task-&gt;tss.eip = (int) asm_end_app; io_sti(); &#125; &#125; break; &#125; &#125; &#125; &#125; else &#123; &#125; &#125; else &#123; &#125; &#125; &#125; else if (i &lt;= 1) &#123; &#125; &#125; &#125;&#125; 变得像真正的操作系统（1）（harib22i）把之前的sht_win删掉，只留下两个命令行窗口。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970void HariMain(void)&#123; key_win = sht_cons[0]; keywin_on(key_win); for (;;) &#123; if (fifo32_status(&amp;fifo) == 0) &#123; &#125; else &#123; if (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; if (s[0] != 0) &#123; fifo32_put(&amp;key_win-&gt;task-&gt;fifo, s[0] + 256); &#125; if (i == 256 + 0x0f) &#123; /* Tab */ keywin_off(key_win); j = key_win-&gt;height - 1; if (j == 0) &#123; j = shtctl-&gt;top - 1; &#125; key_win = shtctl-&gt;sheets[j]; keywin_on(key_win); &#125; &#125; else if (512 &lt;= i &amp;&amp; i &lt;= 767) &#123; if (mouse_decode(&amp;mdec, i - 512) != 0) &#123; if ((mdec.btn &amp; 0x01) != 0) &#123; if (mmx &lt; 0) &#123; for (j = shtctl-&gt;top - 1; j &gt; 0; j--) &#123; if (0 &lt;= x &amp;&amp; x &lt; sht-&gt;bxsize &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; sht-&gt;bysize) &#123; if (sht-&gt;buf[y * sht-&gt;bxsize + x] != sht-&gt;col_inv) &#123; sheet_updown(sht, shtctl-&gt;top - 1); if (sht != key_win) &#123; keywin_off(key_win); key_win = sht; keywin_on(key_win); &#125; &#125; &#125; &#125; &#125; else &#123; &#125; &#125; else &#123; &#125; &#125; &#125; &#125; &#125;&#125;void keywin_off(struct SHEET *key_win)&#123; change_wtitle8(key_win, 0); if ((key_win-&gt;flags &amp; 0x20) != 0) &#123; fifo32_put(&amp;key_win-&gt;task-&gt;fifo, 3); &#125; return;&#125;void keywin_on(struct SHEET *key_win)&#123; change_wtitle8(key_win, 1); if ((key_win-&gt;flags &amp; 0x20) != 0) &#123; fifo32_put(&amp;key_win-&gt;task-&gt;fifo, 2); &#125; return;&#125; 运行后，发现没有光标闪烁。 变得想真正的操作系统（2）（harib22j）命令行窗口的FIFO缓冲区是在console_task初始化的。 bootpack.c的HariMain的优先级比窗口任务的优先级高，所以只有等HariMain休眠之后，console_task才会运行。但是在一开始的时候，keywin_on(key_win)，这个函数会往窗口任务的FIFO缓冲区发送数据，所以会出错。 1234567891011void HariMain(void)&#123; int fifobuf[128], keycmd_buf[32], *cons_fifo[2]; /* sht_cons */ for (i = 0; i &lt; 2; i++) &#123; cons_fifo[i] = (int *) memman_alloc_4k(memman, 128 * 4); fifo32_init(&amp;task_cons[i]-&gt;fifo, 128, cons_fifo[i], task_cons[i]); &#125;&#125; 这样就可以了。","tags":[{"name":"30天自制操作系统","slug":"30天自制操作系统","permalink":"http://yoursite.com/tags/30天自制操作系统/"},{"name":"增加颜色","slug":"增加颜色","permalink":"http://yoursite.com/tags/增加颜色/"},{"name":"增加命令行窗口","slug":"增加命令行窗口","permalink":"http://yoursite.com/tags/增加命令行窗口/"}]},{"title":"24 自制操作系统第二十四天","date":"2018-02-04T04:00:00.000Z","path":"2018/02/04/omake_24/","text":"项目地址 123456789主要内容：1. 窗口切换（1）（harib21a）2. 窗口切换（2）（harib21b）3. 移动窗口（harib21c)4. 用鼠标关闭窗口（harib21d）5. 将输入切换到应用程序窗口（harib21e）6. 用鼠标切换到输入窗口（harib21f）7. 定时器API（harib21g）8. 取消定时器（harib21h) 窗口切换（1）（harib21a）按下F11，将最下面的那个窗口放到最上面。 123456789101112void HariMain(void)&#123; if (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; if (i == 256 + 0x57 &amp;&amp; shtctl-&gt;top &gt; 2) &#123; /* F11 */ sheet_updown(shtctl-&gt;sheets[1], shtctl-&gt;top - 1); &#125; &#125;&#125; shtctl-&gt;sheets[0]是背景，shetctl-&gt;top是鼠标 窗口切换（2）（harib21b）点击鼠标进行窗口的切换。 12345678910111213141516171819202122void HariMain(void)&#123; &#125; else if (512 &lt;= i &amp;&amp; i &lt;= 767) &#123; if ((mdec.btn &amp; 0x01) != 0) &#123; /* 按下左键 */ for (j = shtctl-&gt;top - 1; j &gt; 0; j--) &#123; sht = shtctl-&gt;sheets[j]; x = mx - sht-&gt;vx0; y = my - sht-&gt;vy0; if (0 &lt;= x &amp;&amp; x &lt; sht-&gt;bxsize &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; sht-&gt;bysize) &#123; if (sht-&gt;buf[y * sht-&gt;bxsize + x] != sht-&gt;col_inv) &#123; sheet_updown(sht, shtctl-&gt;top - 1); break; &#125; &#125; &#125; &#125; &#125; &#125; 移动窗口（harib21c)用鼠标进行移动窗口。 123456789101112131415161718192021222324252627282930313233343536373839void HariMain(void)&#123; int j, x, y, mmx = -1, mmy = -1; struct SHEET *sht = 0; &#125; else if (512 &lt;= i &amp;&amp; i &lt;= 767) &#123; if ((mdec.btn &amp; 0x01) != 0) &#123; if (mmx &lt; 0) &#123; for (j = shtctl-&gt;top - 1; j &gt; 0; j--) &#123; sht = shtctl-&gt;sheets[j]; x = mx - sht-&gt;vx0; y = my - sht-&gt;vy0; if (0 &lt;= x &amp;&amp; x &lt; sht-&gt;bxsize &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; sht-&gt;bysize) &#123; if (sht-&gt;buf[y * sht-&gt;bxsize + x] != sht-&gt;col_inv) &#123; sheet_updown(sht, shtctl-&gt;top - 1); if (3 &lt;= x &amp;&amp; x &lt; sht-&gt;bxsize - 3 &amp;&amp; 3 &lt;= y &amp;&amp; y &lt; 21) &#123; mmx = mx; mmy = my; &#125; break; &#125; &#125; &#125; &#125; else &#123; /* 窗口移动模式 */ x = mx - mmx; y = my - mmy; sheet_slide(sht, sht-&gt;vx0 + x, sht-&gt;vy0 + y); mmx = mx; mmy = my; &#125; &#125; else &#123; mmx = -1; &#125; &#125; &#125; 用鼠标关闭窗口（harib21d）12345678910111213141516171819202122232425262728293031323334353637383940414243444546void HariMain(void)&#123; int j, x, y, mmx = -1, mmy = -1; struct SHEET *sht = 0; &#125; else if (512 &lt;= i &amp;&amp; i &lt;= 767) &#123; if ((mdec.btn &amp; 0x01) != 0) &#123; if (mmx &lt; 0) &#123; for (j = shtctl-&gt;top - 1; j &gt; 0; j--) &#123; sht = shtctl-&gt;sheets[j]; x = mx - sht-&gt;vx0; y = my - sht-&gt;vy0; if (0 &lt;= x &amp;&amp; x &lt; sht-&gt;bxsize &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; sht-&gt;bysize) &#123; if (sht-&gt;buf[y * sht-&gt;bxsize + x] != sht-&gt;col_inv) &#123; sheet_updown(sht, shtctl-&gt;top - 1); if (3 &lt;= x &amp;&amp; x &lt; sht-&gt;bxsize - 3 &amp;&amp; 3 &lt;= y &amp;&amp; y &lt; 21) &#123; mmx = mx; mmy = my; &#125; if (sht-&gt;bxsize - 21 &lt;= x &amp;&amp; x &lt; sht-&gt;bxsize - 5 &amp;&amp; 5 &lt;= y &amp;&amp; y &lt; 19) &#123; /* 点击“×”按钮 */ if (sht-&gt;task != 0) &#123; /* 该窗口是否位应用程序窗口 */ cons = (struct CONSOLE *) *((int *) 0x0fec); cons_putstr0(cons, &quot;\\nBreak(mouse) :\\n&quot;); io_cli(); task_cons-&gt;tss.eax = (int) &amp;(task_cons-&gt;tss.esp0); task_cons-&gt;tss.eip = (int) asm_end_app; io_sti(); &#125; &#125; break; &#125; &#125; &#125; &#125; else &#123; &#125; &#125; else &#123; &#125; &#125; &#125; 将输入切换到应用程序窗口（harib21e）将tab键应用到应用程序窗口。 用sheet结构中的task成员来判断数据发送对象FIFO，这样就无法判断窗口是不是由应用程序生成的，我们通过sheet结构中falgs判断（以0x10比特位进行区分），此外，只有命令行窗口需要控制光标的ON/OFF，应用窗口不需要，这一区别通过falgs来进行判断（以0x20比特位进行区分）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384void HariMain(void)&#123; struct SHEET *sht = 0, *key_win; for (;;) &#123; if (fifo32_status(&amp;fifo) == 0) &#123; &#125; else &#123; i = fifo32_get(&amp;fifo); io_sti(); if (key_win-&gt;flags == 0) &#123; /* 输入窗口被关闭 */ key_win = shtctl-&gt;sheets[shtctl-&gt;top - 1]; cursor_c = keywin_on(key_win, sht_win, cursor_c); &#125; if (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; /* 键盘数据 */ if (s[0] != 0) &#123; if (key_win == sht_win) &#123; if (cursor_x &lt; 128) &#123; s[1] = 0; putfonts8_asc_sht(sht_win, cursor_x, 28, COL8_000000, COL8_FFFFFF, s, 1); cursor_x += 8; &#125; &#125; else &#123; fifo32_put(&amp;key_win-&gt;task-&gt;fifo, s[0] + 256); &#125; &#125; if (i == 256 + 0x0e) &#123; if (key_win == sht_win) &#123; if (cursor_x &gt; 8) &#123; putfonts8_asc_sht(sht_win, cursor_x, 28, COL8_000000, COL8_FFFFFF, &quot; &quot;, 1); cursor_x -= 8; &#125; &#125; else &#123; fifo32_put(&amp;key_win-&gt;task-&gt;fifo, 8 + 256); &#125; &#125; if (i == 256 + 0x1c) &#123; if (key_win != sht_win) &#123; fifo32_put(&amp;key_win-&gt;task-&gt;fifo, 10 + 256); &#125; &#125; if (i == 256 + 0x0f) &#123; /* Tab */ cursor_c = keywin_off(key_win, sht_win, cursor_c, cursor_x); j = key_win-&gt;height - 1; if (j == 0) &#123; j = shtctl-&gt;top - 1; &#125; key_win = shtctl-&gt;sheets[j]; cursor_c = keywin_on(key_win, sht_win, cursor_c); &#125; &#125; else if (512 &lt;= i &amp;&amp; i &lt;= 767) &#123; /* 鼠标数据 */ if (mouse_decode(&amp;mdec, i - 512) != 0) &#123; if ((mdec.btn &amp; 0x01) != 0) &#123; if (mmx &lt; 0) &#123; for (j = shtctl-&gt;top - 1; j &gt; 0; j--) &#123; if (0 &lt;= x &amp;&amp; x &lt; sht-&gt;bxsize &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; sht-&gt;bysize) &#123; if (sht-&gt;buf[y * sht-&gt;bxsize + x] != sht-&gt;col_inv) &#123; if (sht-&gt;bxsize - 21 &lt;= x &amp;&amp; x &lt; sht-&gt;bxsize - 5 &amp;&amp; 5 &lt;= y &amp;&amp; y &lt; 19) &#123; if ((sht-&gt;flags &amp; 0x10) != 0) &#123; &#125; &#125; break; &#125; &#125; &#125; &#125; &#125; else &#123; &#125; &#125; &#125; else if (i &lt;= 1) &#123; &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223242526int keywin_off(struct SHEET *key_win, struct SHEET *sht_win, int cur_c, int cur_x)&#123; change_wtitle8(key_win, 0); if (key_win == sht_win) &#123; cur_c = -1; boxfill8(sht_win-&gt;buf, sht_win-&gt;bxsize, COL8_FFFFFF, cur_x, 28, cur_x + 7, 43); &#125; else &#123; if ((key_win-&gt;flags &amp; 0x20) != 0) &#123; fifo32_put(&amp;key_win-&gt;task-&gt;fifo, 3); &#125; &#125; return cur_c;&#125;int keywin_on(struct SHEET *key_win, struct SHEET *sht_win, int cur_c)&#123; change_wtitle8(key_win, 1); if (key_win == sht_win) &#123; cur_c = COL8_000000; &#125; else &#123; if ((key_win-&gt;flags &amp; 0x20) != 0) &#123; fifo32_put(&amp;key_win-&gt;task-&gt;fifo, 2); &#125; &#125; return cur_c;&#125; 1234567891011121314151617181920212223242526272829void change_wtitle8(struct SHEET *sht, char act)&#123; int x, y, xsize = sht-&gt;bxsize; char c, tc_new, tbc_new, tc_old, tbc_old, *buf = sht-&gt;buf; if (act != 0) &#123; tc_new = COL8_FFFFFF; tbc_new = COL8_000084; tc_old = COL8_C6C6C6; tbc_old = COL8_848484; &#125; else &#123; tc_new = COL8_C6C6C6; tbc_new = COL8_848484; tc_old = COL8_FFFFFF; tbc_old = COL8_000084; &#125; for (y = 3; y &lt;= 20; y++) &#123; for (x = 3; x &lt;= xsize - 4; x++) &#123; c = buf[y * xsize + x]; if (c == tc_old &amp;&amp; x &lt;= xsize - 22) &#123; c = tc_new; &#125; else if (c == tbc_old) &#123; c = tbc_new; &#125; buf[y * xsize + x] = c; &#125; &#125; sheet_refresh(sht, 3, 3, xsize, 21); return;&#125; 12345678910111213141516171819202122232425262728int cmd_app(struct CONSOLE *cons, int *fat, char *cmdline)&#123; if (finfo != 0) &#123; if (finfo-&gt;size &gt;= 36 &amp;&amp; strncmp(p + 4, &quot;Hari&quot;, 4) == 0 &amp;&amp; *p == 0x00) &#123; for (i = 0; i &lt; MAX_SHEETS; i++) &#123; sht = &amp;(shtctl-&gt;sheets0[i]); if ((sht-&gt;flags &amp; 0x11) == 0x11 &amp;&amp; sht-&gt;task == task) &#123; sheet_free(sht); &#125; &#125; &#125; else &#123; &#125; &#125;&#125;int *hrb_api(int edi, int esi, int ebp, int esp, int ebx, int edx, int ecx, int eax)&#123; &#125; else if (edx == 5) &#123; sht-&gt;flags |= 0x10; &#125; return 0;&#125; 用鼠标切换到输入窗口（harib21f）1234567891011121314151617181920212223242526void HariMain(void)&#123; if ((mdec.btn &amp; 0x01) != 0) &#123; if (mmx &lt; 0) &#123; for (j = shtctl-&gt;top - 1; j &gt; 0; j--) &#123; if (0 &lt;= x &amp;&amp; x &lt; sht-&gt;bxsize &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; sht-&gt;bysize) &#123; if (sht-&gt;buf[y * sht-&gt;bxsize + x] != sht-&gt;col_inv) &#123; sheet_updown(sht, shtctl-&gt;top - 1); if (sht != key_win) &#123; cursor_c = keywin_off(key_win, sht_win, cursor_c, cursor_x); key_win = sht; cursor_c = keywin_on(key_win, sht_win, cursor_c); &#125; break; &#125; &#125; &#125; &#125; else &#123; &#125; &#125;&#125; 定时器API（harib21g）获取定时器（alloc）EDX = 16EAX = 定时器句柄 设置定时器的发送数据（init）EDX = 17EBX = 定时器句柄EAX = 数据 定时器时间的设定（set）EDX = 18EBX = 定时器句柄EAX = 时间 释放定时器（free）EDX = 19EBX = 定时器句柄 1234567891011121314int *hrb_api(int edi, int esi, int ebp, int esp, int ebx, int edx, int ecx, int eax)&#123; &#125; else if (edx == 16) &#123; reg[7] = (int) timer_alloc(); &#125; else if (edx == 17) &#123; timer_init((struct TIMER *) ebx, &amp;task-&gt;fifo, eax + 256); &#125; else if (edx == 18) &#123; timer_settime((struct TIMER *) ebx, eax); &#125; else if (edx == 19) &#123; timer_free((struct TIMER *) ebx); &#125; return 0;&#125; 123456789101112131415161718192021222324252627282930_api_alloctimer: ; int api_alloctimer(void); MOV EDX,16 INT 0x40 RET_api_inittimer: ; void api_inittimer(int timer, int data); PUSH EBX MOV EDX,17 MOV EBX,[ESP+ 8] ; timer MOV EAX,[ESP+12] ; data INT 0x40 POP EBX RET_api_settimer: ; void api_settimer(int timer, int time); PUSH EBX MOV EDX,18 MOV EBX,[ESP+ 8] ; timer MOV EAX,[ESP+12] ; time INT 0x40 POP EBX RET_api_freetimer: ; void api_freetimer(int timer); PUSH EBX MOV EDX,19 MOV EBX,[ESP+ 8] ; timer INT 0x40 POP EBX RET 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;int api_openwin(char *buf, int xsiz, int ysiz, int col_inv, char *title);void api_putstrwin(int win, int x, int y, int col, int len, char *str);void api_boxfilwin(int win, int x0, int y0, int x1, int y1, int col);void api_initmalloc(void);char *api_malloc(int size);int api_getkey(int mode);int api_alloctimer(void);void api_inittimer(int timer, int data);void api_settimer(int timer, int time);void api_end(void);void HariMain(void)&#123; char *buf, s[12]; int win, timer, sec = 0, min = 0, hou = 0; api_initmalloc(); buf = api_malloc(150 * 50); win = api_openwin(buf, 150, 50, -1, &quot;noodle&quot;); timer = api_alloctimer(); api_inittimer(timer, 128); for (;;) &#123; sprintf(s, &quot;%5d:%02d:%02d&quot;, hou, min, sec); api_boxfilwin(win, 28, 27, 115, 41, 7); api_putstrwin(win, 28, 27, 0 , 11, s); api_settimer(timer, 100); if (api_getkey(1) != 128) &#123; break; &#125; sec++; if (sec == 60) &#123; sec = 0; min++; if (min == 60) &#123; min = 0; hou++; &#125; &#125; &#125; api_end();&#125; 取消定时器（harib21h)应用程序设置了一个1秒的定时器，当定时器到达指定时间会产生超时，并向任务发送数据。如果此时应用程序已经结束了，定时器的数据就会被发送命令行窗口，而命令行窗口一头雾水。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566struct TIMER &#123; struct TIMER *next; unsigned int timeout; char flags, flags2; struct FIFO32 *fifo; int data;&#125;;struct TIMER *timer_alloc(void)&#123; int i; for (i = 0; i &lt; MAX_TIMER; i++) &#123; timerctl.timers0[i].flags2 = 0; &#125; &#125; return 0; &#125;int timer_cancel(struct TIMER *timer)&#123; int e; struct TIMER *t; e = io_load_eflags(); io_cli(); if (timer-&gt;flags == TIMER_FLAGS_USING) &#123; if (timer == timerctl.t0) &#123; /* 第一个定时器的取消处理 */ t = timer-&gt;next; timerctl.t0 = t; timerctl.next = t-&gt;timeout; &#125; else &#123; /* 非第一个定时器的取消处理 */ t = timerctl.t0; for (;;) &#123; if (t-&gt;next == timer) &#123; break; &#125; t = t-&gt;next; &#125; t-&gt;next = timer-&gt;next; &#125; timer-&gt;flags = TIMER_FLAGS_ALLOC; io_store_eflags(e); return 1; &#125; io_store_eflags(e); return 0;&#125;void timer_cancelall(struct FIFO32 *fifo)&#123; int e, i; struct TIMER *t; e = io_load_eflags(); io_cli(); for (i = 0; i &lt; MAX_TIMER; i++) &#123; t = &amp;timerctl.timers0[i]; if (t-&gt;flags != 0 &amp;&amp; t-&gt;flags2 != 0 &amp;&amp; t-&gt;fifo == fifo) &#123; timer_cancel(t); timer_free(t); &#125; &#125; io_store_eflags(e); return;&#125; 1234567891011121314151617181920212223242526272829303132int *hrb_api(int edi, int esi, int ebp, int esp, int ebx, int edx, int ecx, int eax)&#123; &#125; else if (edx == 16) &#123; reg[7] = (int) timer_alloc(); ((struct TIMER *) reg[7])-&gt;flags2 = 1; &#125;&#125;int cmd_app(struct CONSOLE *cons, int *fat, char *cmdline)&#123; if (finfo != 0) &#123; if (finfo-&gt;size &gt;= 36 &amp;&amp; strncmp(p + 4, &quot;Hari&quot;, 4) == 0 &amp;&amp; *p == 0x00) &#123; start_app(0x1b, 1003 * 8, esp, 1004 * 8, &amp;(task-&gt;tss.esp0)); shtctl = (struct SHTCTL *) *((int *) 0x0fe4); for (i = 0; i &lt; MAX_SHEETS; i++) &#123; sht = &amp;(shtctl-&gt;sheets0[i]); if ((sht-&gt;flags &amp; 0x11) == 0x11 &amp;&amp; sht-&gt;task == task) &#123; sheet_free(sht); &#125; &#125; timer_cancelall(&amp;task-&gt;fifo); &#125; else &#123; &#125; return 1; &#125; return 0;&#125;","tags":[{"name":"30天自制操作系统","slug":"30天自制操作系统","permalink":"http://yoursite.com/tags/30天自制操作系统/"},{"name":"窗口切换","slug":"窗口切换","permalink":"http://yoursite.com/tags/窗口切换/"},{"name":"窗口移动","slug":"窗口移动","permalink":"http://yoursite.com/tags/窗口移动/"},{"name":"鼠标关闭窗口","slug":"鼠标关闭窗口","permalink":"http://yoursite.com/tags/鼠标关闭窗口/"}]},{"title":"23 自制操作系统第二十三天","date":"2018-02-04T01:00:00.000Z","path":"2018/02/04/omake_23/","text":"项目地址 123456789主要内容：1. 编写malloc（harib20a）2. 画点（harib20b）3. 刷新窗口（harib20c)4. 画直线（harib20d）5. 关闭窗口（harib20e）6. 键盘输入API（harib20f）7. 用键盘输入来消遣（harib20g）8. 强制结束并关闭窗口（harib20h) 编写malloc（harib20a）memman初始化EDX = 8EBX = memman的地址EAX = memman所管理的内存空间的起始地址ECX = memman所管理的内存空间的字节数 mallocEDX = 9EBX = memman的地址ECX = 需要请求的字节数EAX = 分配到的内存空间地址 freeEDX = 9EBX = memman的地址EAX = 需要释放的内存空间地址ECX = 需要释放的字节数 12345678910111213141516171819int *hrb_api(int edi, int esi, int ebp, int esp, int ebx, int edx, int ecx, int eax)&#123; int *reg = &amp;eax + 1; /* reg[0] : EDI, reg[1] : ESI, reg[2] : EBP, reg[3] : ESP */ /* reg[4] : EBX, reg[5] : EDX, reg[6] : ECX, reg[7] : EAX */ &#125; else if (edx == 8) &#123; memman_init((struct MEMMAN *) (ebx + ds_base)); ecx &amp;= 0xfffffff0; /* 16字节为单位 */ memman_free((struct MEMMAN *) (ebx + ds_base), eax, ecx); &#125; else if (edx == 9) &#123; ecx = (ecx + 0x0f) &amp; 0xfffffff0; /* 16字节为单位取整 */ reg[7] = memman_alloc((struct MEMMAN *) (ebx + ds_base), ecx); &#125; else if (edx == 10) &#123; ecx = (ecx + 0x0f) &amp; 0xfffffff0; /* 16字节为单位取整 */ memman_free((struct MEMMAN *) (ebx + ds_base), eax, ecx); &#125; return 0;&#125; 123456789101112131415161718192021222324252627282930_api_initmalloc: ; void api_initmalloc(void); PUSH EBX MOV EDX,8 MOV EBX,[CS:0x0020] ; malloc内存空间地址 MOV EAX,EBX ADD EAX,32*1024 ; 加上32KB MOV ECX,[CS:0x0000] ; 数据段的大小 SUB ECX,EAX INT 0x40 POP EBX RET_api_malloc: ; char *api_malloc(int size); PUSH EBX MOV EDX,9 MOV EBX,[CS:0x0020] MOV ECX,[ESP+8] ; size INT 0x40 POP EBX RET_api_free: ; void api_free(char *addr, int size); PUSH EBX MOV EDX,10 MOV EBX,[CS:0x0020] MOV EAX,[ESP+ 8] ; addr MOV ECX,[ESP+12] ; size INT 0x40 POP EBX RET 12345678910111213141516171819int api_openwin(char *buf, int xsiz, int ysiz, int col_inv, char *title);void api_putstrwin(int win, int x, int y, int col, int len, char *str);void api_boxfilwin(int win, int x0, int y0, int x1, int y1, int col);void api_initmalloc(void);char *api_malloc(int size);void api_end(void);void HariMain(void)&#123; char *buf; int win; api_initmalloc(); buf = api_malloc(150 * 50); win = api_openwin(buf, 150, 50, -1, &quot;hello&quot;); api_boxfilwin(win, 8, 36, 141, 43, 6); api_putstrwin(win, 28, 28, 0, 12, &quot;hello, world&quot;); api_end();&#125; 画点（harib20b）EDX = 11EBX = 窗口句柄ESI = 显示位置的x坐标EDI = 显示位置的y坐标EAX = 色号 12345678int *hrb_api(int edi, int esi, int ebp, int esp, int ebx, int edx, int ecx, int eax)&#123; &#125; else if (edx == 11) &#123; sht = (struct SHEET *) ebx; sht-&gt;buf[sht-&gt;bxsize * edi + esi] = eax; sheet_refresh(sht, esi, edi, esi + 1, edi + 1); &#125;&#125; 1234567891011121314_api_point: ; void api_point(int win, int x, int y, int col); PUSH EDI PUSH ESI PUSH EBX MOV EDX,11 MOV EBX,[ESP+16] ; win MOV ESI,[ESP+20] ; x MOV EDI,[ESP+24] ; y MOV EAX,[ESP+28] ; col INT 0x40 POP EBX POP ESI POP EDI RET 123456789101112131415161718192021222324int api_openwin(char *buf, int xsiz, int ysiz, int col_inv, char *title);void api_boxfilwin(int win, int x0, int y0, int x1, int y1, int col);void api_initmalloc(void);char *api_malloc(int size);void api_point(int win, int x, int y, int col);void api_end(void);int rand(void); void HariMain(void)&#123; char *buf; int win, i, x, y; api_initmalloc(); buf = api_malloc(150 * 100); win = api_openwin(buf, 150, 100, -1, &quot;stars&quot;); api_boxfilwin(win, 6, 26, 143, 93, 0); for (i = 0; i &lt; 50; i++) &#123; x = (rand() % 137) + 6; y = (rand() % 67) + 26; api_point(win, x, y, 3); &#125; api_end();&#125; 刷新窗口（harib20c)刚才画的50个点，每画一个点，都要刷新一次，太浪费了。 EDX = 12EBX = 窗口句柄EAX = x0ECX = y0ESI = x1EDI = y1 12345678910111213141516171819202122232425262728293031323334353637int *hrb_api(int edi, int esi, int ebp, int esp, int ebx, int edx, int ecx, int eax)&#123; &#125; else if (edx == 6) &#123; sht = (struct SHEET *) (ebx &amp; 0xfffffffe); putfonts8_asc(sht-&gt;buf, sht-&gt;bxsize, esi, edi, eax, (char *) ebp + ds_base); if ((ebx &amp; 1) == 0) &#123; sheet_refresh(sht, esi, edi, esi + ecx * 8, edi + 16); &#125; &#125; else if (edx == 7) &#123; sht = (struct SHEET *) (ebx &amp; 0xfffffffe); boxfill8(sht-&gt;buf, sht-&gt;bxsize, ebp, eax, ecx, esi, edi); if ((ebx &amp; 1) == 0) &#123; sheet_refresh(sht, eax, ecx, esi + 1, edi + 1); &#125; &#125; else if (edx == 8) &#123; memman_init((struct MEMMAN *) (ebx + ds_base)); ecx &amp;= 0xfffffff0; /* 16僶僀僩扨埵偵 */ memman_free((struct MEMMAN *) (ebx + ds_base), eax, ecx); &#125; else if (edx == 9) &#123; ecx = (ecx + 0x0f) &amp; 0xfffffff0; /* 16僶僀僩扨埵偵愗傝忋偘 */ reg[7] = memman_alloc((struct MEMMAN *) (ebx + ds_base), ecx); &#125; else if (edx == 10) &#123; ecx = (ecx + 0x0f) &amp; 0xfffffff0; /* 16僶僀僩扨埵偵愗傝忋偘 */ memman_free((struct MEMMAN *) (ebx + ds_base), eax, ecx); &#125; else if (edx == 11) &#123; sht = (struct SHEET *) (ebx &amp; 0xfffffffe); sht-&gt;buf[sht-&gt;bxsize * edi + esi] = eax; if ((ebx &amp; 1) == 0) &#123; sheet_refresh(sht, esi, edi, esi + 1, edi + 1); &#125; &#125; else if (edx == 12) &#123; sht = (struct SHEET *) ebx; sheet_refresh(sht, eax, ecx, esi, edi); &#125; return 0;&#125; 123456789101112131415_api_refreshwin: ; void api_refreshwin(int win, int x0, int y0, int x1, int y1); PUSH EDI PUSH ESI PUSH EBX MOV EDX,12 MOV EBX,[ESP+16] ; win MOV EAX,[ESP+20] ; x0 MOV ECX,[ESP+24] ; y0 MOV ESI,[ESP+28] ; x1 MOV EDI,[ESP+32] ; y1 INT 0x40 POP EBX POP ESI POP EDI RET 1234567891011121314151617181920212223242526int api_openwin(char *buf, int xsiz, int ysiz, int col_inv, char *title);void api_boxfilwin(int win, int x0, int y0, int x1, int y1, int col);void api_initmalloc(void);char *api_malloc(int size);void api_point(int win, int x, int y, int col);void api_refreshwin(int win, int x0, int y0, int x1, int y1);void api_end(void);int rand(void);void HariMain(void)&#123; char *buf; int win, i, x, y; api_initmalloc(); buf = api_malloc(150 * 100); win = api_openwin(buf, 150, 100, -1, &quot;stars2&quot;); api_boxfilwin(win + 1, 6, 26, 143, 93, 0); for (i = 0; i &lt; 50; i++) &#123; x = (rand() % 137) + 6; y = (rand() % 67) + 26; api_point(win + 1, x, y, 3); &#125; api_refreshwin(win, 6, 26, 144, 94); api_end();&#125; 画直线（harib20d）EDX = 13EBX = 窗口句柄EAX = x0ECX = y0ESI = x1EDI = y1EBP = 色号 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162zint *hrb_api(int edi, int esi, int ebp, int esp, int ebx, int edx, int ecx, int eax)&#123; &#125; else if (edx == 13) &#123; sht = (struct SHEET *) (ebx &amp; 0xfffffffe); hrb_api_linewin(sht, eax, ecx, esi, edi, ebp); if ((ebx &amp; 1) == 0) &#123; sheet_refresh(sht, eax, ecx, esi + 1, edi + 1); &#125; &#125; return 0;&#125;void hrb_api_linewin(struct SHEET *sht, int x0, int y0, int x1, int y1, int col)&#123; int i, x, y, len, dx, dy; dx = x1 - x0; dy = y1 - y0; x = x0 &lt;&lt; 10; y = y0 &lt;&lt; 10; if (dx &lt; 0) &#123; dx = - dx; &#125; if (dy &lt; 0) &#123; dy = - dy; &#125; if (dx &gt;= dy) &#123; len = dx + 1; if (x0 &gt; x1) &#123; dx = -1024; &#125; else &#123; dx = 1024; &#125; if (y0 &lt;= y1) &#123; dy = ((y1 - y0 + 1) &lt;&lt; 10) / len; &#125; else &#123; dy = ((y1 - y0 - 1) &lt;&lt; 10) / len; &#125; &#125; else &#123; len = dy + 1; if (y0 &gt; y1) &#123; dy = -1024; &#125; else &#123; dy = 1024; &#125; if (x0 &lt;= x1) &#123; dx = ((x1 - x0 + 1) &lt;&lt; 10) / len; &#125; else &#123; dx = ((x1 - x0 - 1) &lt;&lt; 10) / len; &#125; &#125; for (i = 0; i &lt; len; i++) &#123; sht-&gt;buf[(y &gt;&gt; 10) * sht-&gt;bxsize + (x &gt;&gt; 10)] = col; x += dx; y += dy; &#125; return;&#125; 123456789101112131415161718_api_linewin: ; void api_linewin(int win, int x0, int y0, int x1, int y1, int col); PUSH EDI PUSH ESI PUSH EBP PUSH EBX MOV EDX,13 MOV EBX,[ESP+20] ; win MOV EAX,[ESP+24] ; x0 MOV ECX,[ESP+28] ; y0 MOV ESI,[ESP+32] ; x1 MOV EDI,[ESP+36] ; y1 MOV EBP,[ESP+40] ; col INT 0x40 POP EBX POP EBP POP ESI POP EDI RET 123456789101112131415161718192021int api_openwin(char *buf, int xsiz, int ysiz, int col_inv, char *title);void api_initmalloc(void);char *api_malloc(int size);void api_refreshwin(int win, int x0, int y0, int x1, int y1);void api_linewin(int win, int x0, int y0, int x1, int y1, int col);void api_end(void);void HariMain(void)&#123; char *buf; int win, i; api_initmalloc(); buf = api_malloc(160 * 100); win = api_openwin(buf, 160, 100, -1, &quot;lines&quot;); for (i = 0; i &lt; 8; i++) &#123; api_linewin(win + 1, 8, 26, 77, i * 9 + 26, i); api_linewin(win + 1, 88, 26, i * 9 + 88, 89, i); &#125; api_refreshwin(win, 6, 26, 154, 90); api_end();&#125; 关闭窗口（harib20e）EDX = 14EBX = 窗口句柄 12345678int *hrb_api(int edi, int esi, int ebp, int esp, int ebx, int edx, int ecx, int eax)&#123; &#125; else if (edx == 14) &#123; sheet_free((struct SHEET *) ebx); &#125; return 0;&#125; 123456_api_closewin: ; void api_closewin(int win); PUSH EBX MOV EDX,14 MOV EBX,[ESP+8] ; win INT 0x40 POP EBX 1234567891011121314151617181920212223int api_openwin(char *buf, int xsiz, int ysiz, int col_inv, char *title);void api_initmalloc(void);char *api_malloc(int size);void api_refreshwin(int win, int x0, int y0, int x1, int y1);void api_linewin(int win, int x0, int y0, int x1, int y1, int col);void api_closewin(int win);void api_end(void);void HariMain(void)&#123; char *buf; int win, i; api_initmalloc(); buf = api_malloc(160 * 100); win = api_openwin(buf, 160, 100, -1, &quot;lines&quot;); for (i = 0; i &lt; 8; i++) &#123; api_linewin(win + 1, 8, 26, 77, i * 9 + 26, i); api_linewin(win + 1, 88, 26, i * 9 + 88, 89, i); &#125; api_refreshwin(win, 6, 26, 154, 90); api_closewin(win); api_end();&#125; 键盘输入API（harib20f）给应用程序增加接收键盘输入的功能，当按下回车键时再结束运行。 EDX = 15EAX = 0 没有键盘输入是返回-1，不休眠EAX = 0 休眠直至发生键盘输入EAX = 输入的字符编码 1234567891011121314151617181920212223242526272829303132333435363738394041struct CONSOLE &#123; struct SHEET *sht; int cur_x, cur_y, cur_c; struct TIMER *timer;&#125;;int *hrb_api(int edi, int esi, int ebp, int esp, int ebx, int edx, int ecx, int eax)&#123; &#125; else if (edx == 15) &#123; for (;;) &#123; io_cli(); if (fifo32_status(&amp;task-&gt;fifo) == 0) &#123; if (eax != 0) &#123; task_sleep(task); &#125; else &#123; io_sti(); reg[7] = -1; return 0; &#125; &#125; i = fifo32_get(&amp;task-&gt;fifo); io_sti(); if (i &lt;= 1) &#123; timer_init(cons-&gt;timer, &amp;task-&gt;fifo, 1); timer_settime(cons-&gt;timer, 50); &#125; if (i == 2) &#123; cons-&gt;cur_c = COL8_FFFFFF; &#125; if (i == 3) &#123; cons-&gt;cur_c = -1; &#125; if (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; reg[7] = i - 256; return 0; &#125; &#125; &#125; return 0;&#125; 12345_api_getkey: ; int api_getkey(int mode); MOV EDX,15 MOV EAX,[ESP+4] ; mode INT 0x40 RET 1234567891011121314151617181920212223242526272829int api_openwin(char *buf, int xsiz, int ysiz, int col_inv, char *title);void api_initmalloc(void);char *api_malloc(int size);void api_refreshwin(int win, int x0, int y0, int x1, int y1);void api_linewin(int win, int x0, int y0, int x1, int y1, int col);void api_closewin(int win);int api_getkey(int mode);void api_end(void);void HariMain(void)&#123; char *buf; int win, i; api_initmalloc(); buf = api_malloc(160 * 100); win = api_openwin(buf, 160, 100, -1, &quot;lines&quot;); for (i = 0; i &lt; 8; i++) &#123; api_linewin(win + 1, 8, 26, 77, i * 9 + 26, i); api_linewin(win + 1, 88, 26, i * 9 + 88, 89, i); &#125; api_refreshwin(win, 6, 26, 154, 90); for (;;) &#123; if (api_getkey(1) == 0x0a) &#123; break; /* Enter 则break; */ &#125; &#125; api_closewin(win); api_end();&#125; 用键盘输入来消遣（harib20g）1234567891011121314151617181920212223242526272829303132333435int api_openwin(char *buf, int xsiz, int ysiz, int col_inv, char *title);void api_putstrwin(int win, int x, int y, int col, int len, char *str);void api_boxfilwin(int win, int x0, int y0, int x1, int y1, int col);void api_initmalloc(void);char *api_malloc(int size);void api_refreshwin(int win, int x0, int y0, int x1, int y1);void api_linewin(int win, int x0, int y0, int x1, int y1, int col);void api_closewin(int win);int api_getkey(int mode);void api_end(void);void HariMain(void)&#123; char *buf; int win, i, x, y; api_initmalloc(); buf = api_malloc(160 * 100); win = api_openwin(buf, 160, 100, -1, &quot;walk&quot;); api_boxfilwin(win, 4, 24, 155, 95, 0); x = 76; y = 56; api_putstrwin(win, x, y, 3, 1, &quot;*&quot;); for (;;) &#123; i = api_getkey(1); api_putstrwin(win, x, y, 0, 1, &quot;*&quot;); if (i == &apos;4&apos; &amp;&amp; x &gt; 4) &#123; x -= 8; &#125; if (i == &apos;6&apos; &amp;&amp; x &lt; 148) &#123; x += 8; &#125; if (i == &apos;8&apos; &amp;&amp; y &gt; 24) &#123; y -= 8; &#125; if (i == &apos;2&apos; &amp;&amp; y &lt; 80) &#123; y += 8; &#125; if (i == 0x0a) &#123; break; &#125; api_putstrwin(win, x, y, 3 /* */, 1, &quot;*&quot;); &#125; api_closewin(win); api_end();&#125; 按2、4、6、8可以上下左右移动，玩累了可以按回车键退出程序。 强制结束并关闭窗口（harib20h)在运行walk.hrb和lines.hrb时，如果不按回车键结束，而是按shift+F11强制结束程序的话，窗口就会残留在画面上。 123456struct SHEET &#123; unsigned char *buf; int bxsize, bysize, vx0, vy0, col_inv, height, flags; struct SHTCTL *ctl; struct TASK *task;&#125;; 123456789101112131415struct SHEET *sheet_alloc(struct SHTCTL *ctl)&#123; struct SHEET *sht; int i; for (i = 0; i &lt; MAX_SHEETS; i++) &#123; if (ctl-&gt;sheets0[i].flags == 0) &#123; sht = &amp;ctl-&gt;sheets0[i]; sht-&gt;flags = SHEET_USE; sht-&gt;height = -1; sht-&gt;task = 0; return sht; &#125; &#125; return 0; &#125; 12345678910111213141516171819202122232425262728293031323334353637int *hrb_api(int edi, int esi, int ebp, int esp, int ebx, int edx, int ecx, int eax)&#123; &#125; else if (edx == 5) &#123; sht = sheet_alloc(shtctl); sht-&gt;task = task; sheet_setbuf(sht, (char *) ebx + ds_base, esi, edi, eax); make_window8((char *) ebx + ds_base, esi, edi, (char *) ecx + ds_base, 0); sheet_slide(sht, 100, 50); sheet_updown(sht, 3); reg[7] = (int) sht; &#125;&#125;int cmd_app(struct CONSOLE *cons, int *fat, char *cmdline)&#123; if (finfo != 0) &#123; if (finfo-&gt;size &gt;= 36 &amp;&amp; strncmp(p + 4, &quot;Hari&quot;, 4) == 0 &amp;&amp; *p == 0x00) &#123; start_app(0x1b, 1003 * 8, esp, 1004 * 8, &amp;(task-&gt;tss.esp0)); shtctl = (struct SHTCTL *) *((int *) 0x0fe4); for (i = 0; i &lt; MAX_SHEETS; i++) &#123; sht = &amp;(shtctl-&gt;sheets0[i]); if (sht-&gt;flags != 0 &amp;&amp; sht-&gt;task == task) &#123; sheet_free(sht); &#125; &#125; memman_free_4k(memman, (int) q, segsiz); &#125; else &#123; cons_putstr0(cons, &quot;.hrb file format error.\\n&quot;); &#125; memman_free_4k(memman, (int) p, finfo-&gt;size); cons_newline(cons); return 1; &#125; return 0;&#125; 一个console只能打开一个sheet。","tags":[{"name":"30天自制操作系统","slug":"30天自制操作系统","permalink":"http://yoursite.com/tags/30天自制操作系统/"},{"name":"画点","slug":"画点","permalink":"http://yoursite.com/tags/画点/"},{"name":"画直线","slug":"画直线","permalink":"http://yoursite.com/tags/画直线/"}]},{"title":"22 自制操作系统第二十二天","date":"2018-02-03T09:00:00.000Z","path":"2018/02/03/omake_22/","text":"项目地址 12345678主要内容：1. 保护操作系统（5）（harib19a）2. 帮助发现bug（harib19b）3. 强制结束应用程序（harib19c)4. 用C语言显示字符串（1）（harib19d）5. 用C语言显示字符串（2）（harib19e）6. 显示窗口（harib19f）7. 在窗口中描绘字符和方块（harib19g） 保护操作系统（5）（harib19a）12345678910111213141516[INSTRSET &quot;i486p&quot;][BITS 32] MOV AL,0x34 OUT 0x43,AL MOV AL,0xff OUT 0x40,AL MOV AL,0xff OUT 0x40,AL; 相当于; io_out8(PIT_CTRL, 0x34);; io_out8(PIT_CNT0, 0xff);; io_out8(PIT_CNT0, 0xff); MOV EDX,4 INT 0x40 在定时器上做手脚，光标闪烁会变得异常的慢。 产生异常了。当以程序模式运行时，执行IN指令和OUT指令都会产生一般保护异常。 123456[INSTRSET &quot;i486p&quot;][BITS 32] CLIfin: HLT JMP fin 执行CLT，然后在HLT，这样电脑就司机了。 产生异常了。当以程序模式运行时，CLI、STI和HLT这些指令都会产生异常。 12345[INSTRSET &quot;i486p&quot;][BITS 32] CALL 2*8:0xac1 MOV EDX,4 INT 0x40 0xac1是 io_cli函数的起始地址 产生异常了。CPU规定除了设置好的地址以外，进制应用程序CALL其他的地址。 帮助发现bug（harib19b）1234567891011121314void api_putchar(int c);void api_end(void);void HariMain(void)&#123; char a[100]; a[10] = &apos;A&apos;; /* 没有问题 */ api_putchar(a[10]); a[102] = &apos;B&apos;; /* 有问题 */ api_putchar(a[102]); a[123] = &apos;C&apos;; /* 有问题 */ api_putchar(a[123]); api_end();&#125; a这个数组是保存在栈中的，因此这次可能产生了栈异常。 123456789101112131415161718192021222324252627282930313233343536373839404142434445_asm_inthandler0c: STI PUSH ES PUSH DS PUSHAD MOV EAX,ESP PUSH EAX MOV AX,SS MOV DS,AX MOV ES,AX CALL _inthandler0c CMP EAX,0 JNE end_app POP EAX POPAD POP DS POP ES ADD ESP,4 ; INT 0x0c 必要 IRETD int *inthandler0c(int *esp)&#123; struct CONSOLE *cons = (struct CONSOLE *) *((int *) 0x0fec); struct TASK *task = task_now(); char s[30]; cons_putstr0(cons, &quot;\\nINT 0C :\\n Stack Exception.\\n&quot;); sprintf(s, &quot;EIP = %08X\\n&quot;, esp[11]); cons_putstr0(cons, s); return &amp;(task-&gt;tss.esp0); &#125;void init_gdtidt(void)&#123; set_gatedesc(idt + 0x0c, (int) asm_inthandler0c, 2 * 8, AR_INTGATE32); set_gatedesc(idt + 0x0d, (int) asm_inthandler0d, 2 * 8, AR_INTGATE32); set_gatedesc(idt + 0x20, (int) asm_inthandler20, 2 * 8, AR_INTGATE32); set_gatedesc(idt + 0x21, (int) asm_inthandler21, 2 * 8, AR_INTGATE32); set_gatedesc(idt + 0x27, (int) asm_inthandler27, 2 * 8, AR_INTGATE32); set_gatedesc(idt + 0x2c, (int) asm_inthandler2c, 2 * 8, AR_INTGATE32); set_gatedesc(idt + 0x40, (int) asm_hrb_api, 2 * 8, AR_INTGATE32 + 0x60); return;&#125; 强制结束应用程序（harib19c)1234void HariMain(void)&#123; for (;;) &#123; &#125;&#125; 这样的程序，会一直运行下去。 使用“Shift + F11” 作为程序的强制结束键。 123456789101112131415161718192021222324252627282930313233343536void HariMain(void)&#123; for (;;) &#123; if (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; if (i == 256 + 0x3b &amp;&amp; key_shift != 0 &amp;&amp; task_cons-&gt;tss.ss0 != 0) &#123; /* Shift+F1 */ cons = (struct CONSOLE *) *((int *) 0x0fec); cons_putstr0(cons, &quot;\\nBreak(key) :\\n&quot;); io_cli(); task_cons-&gt;tss.eax = (int) &amp;(task_cons-&gt;tss.esp0); task_cons-&gt;tss.eip = (int) asm_end_app; io_sti(); &#125; &#125; &#125;&#125;_asm_end_app: MOV ESP,[EAX] MOV DWORD [EAX+4],0 POPAD RET struct TASK *task_alloc(void)&#123; int i; struct TASK *task; for (i = 0; i &lt; MAX_TASKS; i++) &#123; if (taskctl-&gt;tasks0[i].flags == 0) &#123; task-&gt;tss.ss0 = 0; return task; &#125; &#125; return 0;&#125; 用C语言显示字符串（1）（harib19d）123456789101112131415161718192021222324252627282930313233343536373839404142a_nask.nas 文件_api_putstr0: ; void api_putstr0(char *s); PUSH EBX MOV EDX,2 MOV EBX,[ESP+8] ; s INT 0x40 POP EBX REThello4.c 文件void api_putstr0(char *s);void api_end(void);void HariMain(void)&#123; api_putstr0(&quot;hello, world\\n&quot;); api_end();&#125;console.c 文件int cmd_app(struct CONSOLE *cons, int *fat, char *cmdline)&#123; if (finfo != 0) &#123; if (finfo-&gt;size &gt;= 8 &amp;&amp; strncmp(p + 4, &quot;Hari&quot;, 4) == 0) &#123; start_app(0x1b, 1003 * 8, 64 * 1024, 1004 * 8, &amp;(task-&gt;tss.esp0)); &#125; else &#123; start_app(0, 1003 * 8, 64 * 1024, 1004 * 8, &amp;(task-&gt;tss.esp0)); &#125; return 1; &#125; return 0;&#125; 显示不出字符串。 用C语言显示字符串（2）（harib19e）bim2hrb生成的.hrb其实有两部分构成的，代码部分和数据部分。 当程序中灭有使用字符串和外部变量时，就会生成不包含数据部分的.hrb文件，因此之前的程序都没有问题。 .hrb文件开头的36个字节不是程序，而是放了一些信息。0x0000（DWORD） 请求操作系统位应用程序准备的数据段的大小0x0004（DWORD） “Hari”标记0x0008（DWORD） 数据段内预备空间的大小0x000c（DWORD） ESP初始值&amp;数据部分传送目的地址0x0010（DWORD） hrb文件内数据部分的大小0x0014（DWORD） hrb文件内数据部分从哪里开始0x0018（DWORD） 0xe90000000x001c（DWORD） 应用程序运行入口地址- 0x200x0020（DWORD） malloc空间的起始地址 1234567891011121314151617181920212223242526272829int cmd_app(struct CONSOLE *cons, int *fat, char *cmdline)&#123; if (finfo != 0) &#123; p = (char *) memman_alloc_4k(memman, finfo-&gt;size); file_loadfile(finfo-&gt;clustno, finfo-&gt;size, p, fat, (char *) (ADR_DISKIMG + 0x003e00)); if (finfo-&gt;size &gt;= 36 &amp;&amp; strncmp(p + 4, &quot;Hari&quot;, 4) == 0 &amp;&amp; *p == 0x00) &#123; segsiz = *((int *) (p + 0x0000)); esp = *((int *) (p + 0x000c)); datsiz = *((int *) (p + 0x0010)); dathrb = *((int *) (p + 0x0014)); q = (char *) memman_alloc_4k(memman, segsiz); *((int *) 0xfe8) = (int) q; set_segmdesc(gdt + 1003, finfo-&gt;size - 1, (int) p, AR_CODE32_ER + 0x60); set_segmdesc(gdt + 1004, segsiz - 1, (int) q, AR_DATA32_RW + 0x60); for (i = 0; i &lt; datsiz; i++) &#123; q[esp + i] = p[dathrb + i]; &#125; start_app(0x1b, 1003 * 8, esp, 1004 * 8, &amp;(task-&gt;tss.esp0)); memman_free_4k(memman, (int) q, segsiz); &#125; else &#123; cons_putstr0(cons, &quot;.hrb file format error.\\n&quot;); &#125; memman_free_4k(memman, (int) p, finfo-&gt;size); cons_newline(cons); return 1; &#125; return 0;&#125; 显示窗口（harib19f）EDX = 5EBX = 窗口缓冲区ESI = 窗口宽度EDI = 窗口高度EAX = 透明色ECX = 窗口名称 调用之后，返回值为：EAX = 用于操作窗口的句柄 12345678910111213141516171819202122232425262728293031int *hrb_api(int edi, int esi, int ebp, int esp, int ebx, int edx, int ecx, int eax)&#123; int ds_base = *((int *) 0xfe8); struct TASK *task = task_now(); struct CONSOLE *cons = (struct CONSOLE *) *((int *) 0x0fec); struct SHTCTL *shtctl = (struct SHTCTL *) *((int *) 0x0fe4); struct SHEET *sht; int *reg = &amp;eax + 1; /* eax后面的地址 */ /* 强行改写PUSHAD保存的值 */ /* reg[0] : EDI, reg[1] : ESI, reg[2] : EBP, reg[3] : ESP */ /* reg[4] : EBX, reg[5] : EDX, reg[6] : ECX, reg[7] : EAX */ if (edx == 1) &#123; cons_putchar(cons, eax &amp; 0xff, 1); &#125; else if (edx == 2) &#123; cons_putstr0(cons, (char *) ebx + ds_base); &#125; else if (edx == 3) &#123; cons_putstr1(cons, (char *) ebx + ds_base, ecx); &#125; else if (edx == 4) &#123; return &amp;(task-&gt;tss.esp0); &#125; else if (edx == 5) &#123; sht = sheet_alloc(shtctl); sheet_setbuf(sht, (char *) ebx + ds_base, esi, edi, eax); make_window8((char *) ebx + ds_base, esi, edi, (char *) ecx + ds_base, 0); sheet_slide(sht, 100, 50); sheet_updown(sht, 3); reg[7] = (int) sht; &#125; return 0;&#125; 123456789101112131415_api_openwin: ; int api_openwin(char *buf, int xsiz, int ysiz, int col_inv, char *title); PUSH EDI PUSH ESI PUSH EBX MOV EDX,5 MOV EBX,[ESP+16] ; buf MOV ESI,[ESP+20] ; xsiz MOV EDI,[ESP+24] ; ysiz MOV EAX,[ESP+28] ; col_inv MOV ECX,[ESP+32] ; title INT 0x40 POP EBX POP ESI POP EDI RET 在窗口中描绘字符和方块（harib19g）在窗口上显示字符的API如下：EDX = 6EBX = 窗口句柄ESI = 显示位置的x坐标EDI = 显示位置的y坐标EAX = 色号ECX = 字符串长度EBP = 字符串 描绘方块的API如下：EDX = 7EBX = 窗口句柄EAX = x0ECX = y0ESI = x1EDI = y1EBP = 色号 123456789101112131415161718192021222324int *hrb_api(int edi, int esi, int ebp, int esp, int ebx, int edx, int ecx, int eax)&#123; if (edx == 1) &#123; &#125; else if (edx == 2) &#123; &#125; else if (edx == 3) &#123; &#125; else if (edx == 4) &#123; &#125; else if (edx == 5) &#123; &#125; else if (edx == 6) &#123; sht = (struct SHEET *) ebx; putfonts8_asc(sht-&gt;buf, sht-&gt;bxsize, esi, edi, eax, (char *) ebp + ds_base); sheet_refresh(sht, esi, edi, esi + ecx * 8, edi + 16); &#125; else if (edx == 7) &#123; sht = (struct SHEET *) ebx; boxfill8(sht-&gt;buf, sht-&gt;bxsize, ebp, eax, ecx, esi, edi); sheet_refresh(sht, eax, ecx, esi + 1, edi + 1); &#125; return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637_api_putstrwin: ; void api_putstrwin(int win, int x, int y, int col, int len, char *str); PUSH EDI PUSH ESI PUSH EBP PUSH EBX MOV EDX,6 MOV EBX,[ESP+20] ; win MOV ESI,[ESP+24] ; x MOV EDI,[ESP+28] ; y MOV EAX,[ESP+32] ; col MOV ECX,[ESP+36] ; len MOV EBP,[ESP+40] ; str INT 0x40 POP EBX POP EBP POP ESI POP EDI RET_api_boxfilwin: ; void api_boxfilwin(int win, int x0, int y0, int x1, int y1, int col); PUSH EDI PUSH ESI PUSH EBP PUSH EBX MOV EDX,7 MOV EBX,[ESP+20] ; win MOV EAX,[ESP+24] ; x0 MOV ECX,[ESP+28] ; y0 MOV ESI,[ESP+32] ; x1 MOV EDI,[ESP+36] ; y1 MOV EBP,[ESP+40] ; col INT 0x40 POP EBX POP EBP POP ESI POP EDI RET","tags":[{"name":"30天自制操作系统","slug":"30天自制操作系统","permalink":"http://yoursite.com/tags/30天自制操作系统/"},{"name":"C语言调用API","slug":"C语言调用API","permalink":"http://yoursite.com/tags/C语言调用API/"}]},{"title":"21 自制操作系统第二十一天","date":"2018-02-03T04:00:00.000Z","path":"2018/02/03/omake_21/","text":"项目地址 12345678主要内容：1. 字符串显示API（harib18a）2. 用C语言编写应用程序（harib18b）3. 保护操作系统（1）（harib18c)4. 保护操作系统（2)（harib18d）5. 对异常的支持（harib18e）6. 保护操作系统（3）（harib18f）7. 保护操作系统（4）（harib18g） 字符串显示API（harib17a）显示单个字符时，我们用[cs:ecx]的方式指定了CS，因此可以成功读取msg的内容。 1234567int cmd_app(struct CONSOLE *cons, int *fat, char *cmdline)&#123; if (finfo != 0) &#123; p = (char *) memman_alloc_4k(memman, finfo-&gt;size); *((int *) 0xfe8) = (int) p; &#125;&#125; 12345678910111213void hrb_api(int edi, int esi, int ebp, int esp, int ebx, int edx, int ecx, int eax)&#123; int cs_base = *((int *) 0xfe8); struct CONSOLE *cons = (struct CONSOLE *) *((int *) 0x0fec); if (edx == 1) &#123; cons_putchar(cons, eax &amp; 0xff, 1); &#125; else if (edx == 2) &#123; cons_putstr0(cons, (char *) ebx + cs_base); &#125; else if (edx == 3) &#123; cons_putstr1(cons, (char *) ebx + cs_base, ecx); &#125; return;&#125; 用C语言编写应用程序（harib17b）1234567891011121314151617181920212223242526272829303132333435a.c 文件void api_putchar(int c);void HariMain(void)&#123; api_putchar(&apos;A&apos;); return;&#125;a_nask.nas 文件[FORMAT &quot;WCOFF&quot;] [INSTRSET &quot;i486p&quot;] [BITS 32] [FILE &quot;a_nask.nas&quot;] GLOBAL _api_putchar[SECTION .text]_api_putchar: ; void api_putchar(int c); MOV EDX,1 MOV AL,[ESP+4] ; c INT 0x40 RETmakefile 文件a.bim : a.obj a_nask.obj Makefile $(OBJ2BIM) @$(RULEFILE) out:a.bim map:a.map a.obj a_nask.obja.hrb : a.bim Makefile $(BIM2HRB) a.bim a.hrb 0 然后把a.hrb文件开头的6个字节换成“E8 16 00 00 00 CB” 这6个字节其实就相当于下面三行代码123[BITS 32] CALL 0x1b RETF 也就是线调用0x1b这个地址的函数，从函数返回后再执行far-RET。这里的0x1b，其实就是.hrb文件中HariMain的地址。 如果每次增加一个文件，都要修改6个字节，有点麻烦。 1234567891011121314151617181920212223int cmd_app(struct CONSOLE *cons, int *fat, char *cmdline)&#123; if (finfo != 0) &#123; p = (char *) memman_alloc_4k(memman, finfo-&gt;size); *((int *) 0xfe8) = (int) p; file_loadfile(finfo-&gt;clustno, finfo-&gt;size, p, fat, (char *) (ADR_DISKIMG + 0x003e00)); set_segmdesc(gdt + 1003, finfo-&gt;size - 1, (int) p, AR_CODE32_ER); if (finfo-&gt;size &gt;= 8 &amp;&amp; strncmp(p + 4, &quot;Hari&quot;, 4) == 0) &#123; p[0] = 0xe8; p[1] = 0x16; p[2] = 0x00; p[3] = 0x00; p[4] = 0x00; p[5] = 0xcb; &#125; farcall(0, 1003 * 8); memman_free_4k(memman, (int) p, finfo-&gt;size); cons_newline(cons); return 1; &#125; return 0;&#125; 保护操作系统（1）（harib17c)1234567crack1.c 文件void HariMain(void)&#123; *((char *) 0x00102600) = 0; return;&#125; 执行之后，系统崩溃了。 保护操作系统（2）（harib18d)系统崩溃的原因是应用程序访问了本该由操作系统来管理的内存空间。 我们可以创建应用程序专用的数据段，并在应用程序运行期间，将DS和SS指向该段地址。 操作系统用 代码段 – 2 8操作系统用数据段 – 1 8应用程序用代码段 – 1003 8应用程序用数据段 – 1004 8(38 ~ 10028 为TSS所使用的段) 123456789101112131415int cmd_app(struct CONSOLE *cons, int *fat, char *cmdline)&#123; if (finfo != 0) &#123; set_segmdesc(gdt + 1003, finfo-&gt;size - 1, (int) p, AR_CODE32_ER); set_segmdesc(gdt + 1004, 64 * 1024 - 1, (int) q, AR_DATA32_RW); start_app(0, 1003 * 8, 64 * 1024, 1004 * 8); memman_free_4k(memman, (int) p, finfo-&gt;size); memman_free_4k(memman, (int) q, 64 * 1024); cons_newline(cons); return 1; &#125; return 0;&#125; 1234567891011121314151617181920212223242526272829303132_start_app: ; void start_app(int eip, int cs, int esp, int ds); PUSHAD MOV EAX,[ESP+36] ; 应用程序用のEIP MOV ECX,[ESP+40] ; 应用程序用CS MOV EDX,[ESP+44] ; 应用程序用ESP MOV EBX,[ESP+48] ; 应用程序用DS/SS MOV [0xfe4],ESP ; 操作系统用ESP CLI ; 切换过程中禁止中断请求 MOV ES,BX MOV SS,BX MOV DS,BX MOV FS,BX MOV GS,BX MOV ESP,EDX STI ; 切换完成后恢复中断请求 PUSH ECX ; 用于far-CALL的PUSH（cs） PUSH EAX ; 用于far-CALL的PUSH（eip） CALL FAR [ESP] ; 调用应用程序; 应用程序结束后返回此处 MOV EAX,1*8 ; OS用DS/SS CLI ; 再次切换，禁止中断请求 MOV ES,AX MOV SS,AX MOV DS,AX MOV FS,AX MOV GS,AX MOV ESP,[0xfe4] STI ; 切换完成后恢复中断请求 POPAD RET hrb_api这个函数是用C语言编写的操作系统程序，要将段地址设回操作系统用的段。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647_asm_hrb_api: ; 为方便起见从开头就禁止中断请求 PUSH DS PUSH ES PUSHAD MOV EAX,1*8 MOV DS,AX ; 先仅将DS设为操作系统用 MOV ECX,[0xfe4] ; 操作系统的ESP ADD ECX,-40 MOV [ECX+32],ESP ; 保存应用程序的ESP MOV [ECX+36],SS ; 保存应用程序的SS; 将PUSHAD后的值复制到系统栈 MOV EDX,[ESP ] MOV EBX,[ESP+ 4] MOV [ECX ],EDX ; 复制传递给hrb_api MOV [ECX+ 4],EBX ; 复制传递给hrb_api MOV EDX,[ESP+ 8] MOV EBX,[ESP+12] MOV [ECX+ 8],EDX ; 复制传递给hrb_api MOV [ECX+12],EBX ; 复制传递给hrb_api MOV EDX,[ESP+16] MOV EBX,[ESP+20] MOV [ECX+16],EDX ; 复制传递给hrb_api MOV [ECX+20],EBX ; 复制传递给hrb_api MOV EDX,[ESP+24] MOV EBX,[ESP+28] MOV [ECX+24],EDX ; 复制传递给hrb_api MOV [ECX+28],EBX ; 复制传递给hrb_api MOV ES,AX ; 将剩余的段寄存器也设为操作系统用 MOV SS,AX MOV ESP,ECX STI ; 恢复中断请求 CALL _hrb_api MOV ECX,[ESP+32] ; 取出应用程序的ESP MOV EAX,[ESP+36] ; 取出应用程序的SS CLI MOV SS,AX MOV ESP,ECX POPAD POP ES POP DS IRETD ; 这个命令会自动执行STI 12345678910111213141516171819202122232425262728293031323334353637383940_asm_inthandler20: PUSH ES PUSH DS PUSHAD MOV AX,SS CMP AX,1*8 JNE .from_app MOV EAX,ESP PUSH SS ; 保存中断时的SS PUSH EAX ; 保存中断时的ESP MOV AX,SS MOV DS,AX MOV ES,AX CALL _inthandler20 ADD ESP,8 POPAD POP DS POP ES IRETD.from_app:; 当应用程序活动中发生中断 MOV EAX,1*8 MOV DS,AX ; 先仅将DS设为操作系统用 MOV ECX,[0xfe4] ; 操作系统的ESP ADD ECX,-8 MOV [ECX+4],SS ; 保存中断时的SS MOV [ECX ],ESP ; 保存中断时的ESP MOV SS,AX MOV ES,AX MOV ESP,ECX CALL _inthandler20 POP ECX POP EAX MOV SS,AX ; 将SS设回应用程序使用 MOV ESP,ECX ; 将ESP设回应用程序使用 POPAD POP DS POP ES IRETD 类似的asm_inthandler21 和 asm_inthandler2c也和上面大同小异。 对异常的支持（harib18e）要想强制结束程序，只要在中断号0x0d中注册一个函数即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061_asm_inthandler0d: STI PUSH ES PUSH DS PUSHAD MOV AX,SS CMP AX,1*8 JNE .from_app MOV EAX,ESP PUSH SS ; 保存中断时的SS PUSH EAX ; 保存中断时的ESP MOV AX,SS MOV DS,AX MOV ES,AX CALL _inthandler0d ADD ESP,8 POPAD POP DS POP ES ADD ESP,4 ; INT 0x0d 中需要这一句 IRETD.from_app:; 当应用程序活动中发生中断 CLI MOV EAX,1*8 MOV DS,AX ; 先仅将DS设为操作系统用 MOV ECX,[0xfe4] ; 操作系统的ESP ADD ECX,-8 MOV [ECX+4],SS ; 保存中断时的SS MOV [ECX ],ESP ; 保存中断时的ESP MOV SS,AX MOV ES,AX MOV ESP,ECX STI CALL _inthandler0d CLI CMP EAX,0 JNE .kill POP ECX POP EAX MOV SS,AX ; 将SS设回应用程序使用 MOV ESP,ECX ; 将ESP设回应用程序使用 POPAD POP DS POP ES ADD ESP,4 ; INT 0x0d 中需要这一句 IRETD.kill:; 将应用程序强制结束 MOV EAX,1*8 ; 操作系统用的DS/SS MOV ES,AX MOV SS,AX MOV DS,AX MOV FS,AX MOV GS,AX MOV ESP,[0xfe4] ; 强制返回到start_app时的ESP STI POPAD RET 123456int inthandler0d(int *esp)&#123; struct CONSOLE *cons = (struct CONSOLE *) *((int *) 0x0fec); cons_putstr0(cons, &quot;\\nINT 0D :\\n General Protected Exception.\\n&quot;); return 1;&#125; 1234567891011void init_gdtidt(void)&#123; set_gatedesc(idt + 0x0d, (int) asm_inthandler0d, 2 * 8, AR_INTGATE32); set_gatedesc(idt + 0x20, (int) asm_inthandler20, 2 * 8, AR_INTGATE32); set_gatedesc(idt + 0x21, (int) asm_inthandler21, 2 * 8, AR_INTGATE32); set_gatedesc(idt + 0x27, (int) asm_inthandler27, 2 * 8, AR_INTGATE32); set_gatedesc(idt + 0x2c, (int) asm_inthandler2c, 2 * 8, AR_INTGATE32); set_gatedesc(idt + 0x40, (int) asm_hrb_api, 2 * 8, AR_INTGATE32); return;&#125; 保护操作系统（3）（harib18f）12345678crack2.nas[INSTRSET &quot;i486p&quot;][BITS 32] MOV EAX,1*8 MOV DS,AX MOV BYTE [0x102600],0 RETF 保护操作系统（4）（harib18g）应用程序擅自向DS存入了操作系统用的段地址。所以要让应用程序无法使用操作系统的段地址。 如果定义段的地方，将访问权限加上0x60的话，就可以将段地址设置为应用程序用。当CS中的段地址位应用程序用段地址时，CPU会认为“当前正在运行应用程序”，这时如果存入操作系统用的段地址就会产生异常。 1234567891011121314int cmd_app(struct CONSOLE *cons, int *fat, char *cmdline)&#123; if (finfo != 0) &#123; set_segmdesc(gdt + 1003, finfo-&gt;size - 1, (int) p, AR_CODE32_ER + 0x60); set_segmdesc(gdt + 1004, 64 * 1024 - 1, (int) q, AR_DATA32_RW + 0x60); start_app(0, 1003 * 8, 64 * 1024, 1004 * 8, &amp;(task-&gt;tss.esp0)); return 1; &#125; return 0;&#125; 123456789101112131415161718192021_start_app: ; void start_app(int eip, int cs, int esp, int ds, int *tss_esp0); PUSHAD MOV EAX,[ESP+36] ; EIP MOV ECX,[ESP+40] ; CS MOV EDX,[ESP+44] ; ESP MOV EBX,[ESP+48] ; S/SS MOV EBP,[ESP+52] ; tss.esp0地址 MOV [EBP ],ESP ; 保存操作系统用的ESP MOV [EBP+4],SS ; 保存操作系统用的SS MOV ES,BX MOV DS,BX MOV FS,BX MOV GS,BX; 调整栈，以免用RETF跳转到应用程序 OR ECX,3 OR EBX,3 PUSH EBX ; 应用程序SS PUSH EDX ; 应用程序ESP PUSH ECX ; 应用程序CS PUSH EAX ; 应用程序EIP RETF 12345678910111213141516171819202122_asm_hrb_api: STI PUSH DS PUSH ES PUSHAD PUSHAD MOV AX,SS MOV DS,AX ; 将操作系统用段地址存入DS和ES MOV ES,AX CALL _hrb_api CMP EAX,0 ; 当EAX不为0的时候程序结束 JNE end_app ADD ESP,32 POPAD POP ES POP DS IRETDend_app: MOV ESP,[EAX] POPAD RET 1234567891011121314151617int *hrb_api(int edi, int esi, int ebp, int esp, int ebx, int edx, int ecx, int eax)&#123; int cs_base = *((int *) 0xfe8); struct TASK *task = task_now(); struct CONSOLE *cons = (struct CONSOLE *) *((int *) 0x0fec); if (edx == 1) &#123; cons_putchar(cons, eax &amp; 0xff, 1); &#125; else if (edx == 2) &#123; cons_putstr0(cons, (char *) ebx + cs_base); &#125; else if (edx == 3) &#123; cons_putstr1(cons, (char *) ebx + cs_base, ecx); &#125; else if (edx == 4) &#123; return &amp;(task-&gt;tss.esp0); &#125; return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435_asm_inthandler20: PUSH ES PUSH DS PUSHAD MOV EAX,ESP PUSH EAX MOV AX,SS MOV DS,AX MOV ES,AX CALL _inthandler20 POP EAX POPAD POP DS POP ES IRETD _asm_inthandler0d: STI PUSH ES PUSH DS PUSHAD MOV EAX,ESP PUSH EAX MOV AX,SS MOV DS,AX MOV ES,AX CALL _inthandler0d CMP EAX,0 JNE end_app POP EAX POPAD POP DS POP ES ADD ESP,4 IRETD 123456789101112void init_gdtidt(void)&#123; set_gatedesc(idt + 0x0d, (int) asm_inthandler0d, 2 * 8, AR_INTGATE32); set_gatedesc(idt + 0x20, (int) asm_inthandler20, 2 * 8, AR_INTGATE32); set_gatedesc(idt + 0x21, (int) asm_inthandler21, 2 * 8, AR_INTGATE32); set_gatedesc(idt + 0x27, (int) asm_inthandler27, 2 * 8, AR_INTGATE32); set_gatedesc(idt + 0x2c, (int) asm_inthandler2c, 2 * 8, AR_INTGATE32); set_gatedesc(idt + 0x40, (int) asm_hrb_api, 2 * 8, AR_INTGATE32 + 0x60); return;&#125; 123456789101112131415161718hello.nas [INSTRSET &quot;i486p&quot;][BITS 32] MOV ECX,msg MOV EDX,1putloop: MOV AL,[CS:ECX] CMP AL,0 JE fin INT 0x40 ADD ECX,1 JMP putloopfin: RETFmsg: DB &quot;hello&quot;,0","tags":[{"name":"30天自制操作系统","slug":"30天自制操作系统","permalink":"http://yoursite.com/tags/30天自制操作系统/"},{"name":"保护操作系统","slug":"保护操作系统","permalink":"http://yoursite.com/tags/保护操作系统/"}]},{"title":"20 自制操作系统第二十天","date":"2018-02-03T01:00:00.000Z","path":"2018/02/03/omake_20/","text":"项目地址 123456789主要内容：1. 程序整理（harib17a）2. 显示单个字符的API（1）（harib17b）3. 显示单个字符的API（2）（harib17c)4. 结束应用程序（harib17d）5. 不随操作系统版本而改变的API（harib17e）6. 为应用程序自由命名（harib17f）7. 当心寄存器（harib17g）8. 用API显示字符串（harib17h） 程序整理（harib17a）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258/* console.c */struct CONSOLE &#123; struct SHEET *sht; int cur_x, cur_y, cur_c;&#125;;void console_task(struct SHEET *sheet, unsigned int memtotal)&#123; struct TIMER *timer; struct TASK *task = task_now(); struct MEMMAN *memman = (struct MEMMAN *) MEMMAN_ADDR; int i, fifobuf[128], *fat = (int *) memman_alloc_4k(memman, 4 * 2880); struct CONSOLE cons; char cmdline[30]; cons.sht = sheet; cons.cur_x = 8; cons.cur_y = 28; cons.cur_c = -1; fifo32_init(&amp;task-&gt;fifo, 128, fifobuf, task); timer = timer_alloc(); timer_init(timer, &amp;task-&gt;fifo, 1); timer_settime(timer, 50); file_readfat(fat, (unsigned char *) (ADR_DISKIMG + 0x000200)); cons_putchar(&amp;cons, &apos;&gt;&apos;, 1); for (;;) &#123; io_cli(); if (fifo32_status(&amp;task-&gt;fifo) == 0) &#123; task_sleep(task); io_sti(); &#125; else &#123; i = fifo32_get(&amp;task-&gt;fifo); io_sti(); if (i &lt;= 1) &#123; /* 光标定时器 */ if (i != 0) &#123; timer_init(timer, &amp;task-&gt;fifo, 0); if (cons.cur_c &gt;= 0) &#123; cons.cur_c = COL8_FFFFFF; &#125; &#125; else &#123; timer_init(timer, &amp;task-&gt;fifo, 1); if (cons.cur_c &gt;= 0) &#123; cons.cur_c = COL8_000000; &#125; &#125; timer_settime(timer, 50); &#125; if (i == 2) &#123; cons.cur_c = COL8_FFFFFF; &#125; if (i == 3) &#123; boxfill8(sheet-&gt;buf, sheet-&gt;bxsize, COL8_000000, cons.cur_x, cons.cur_y, cons.cur_x + 7, cons.cur_y + 15); cons.cur_c = -1; &#125; if (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; /* 键盘数据 */ if (i == 8 + 256) &#123; /* 退格键 */ if (cons.cur_x &gt; 16) &#123; cons_putchar(&amp;cons, &apos; &apos;, 0); cons.cur_x -= 8; &#125; &#125; else if (i == 10 + 256) &#123; /* Enter */ cons_putchar(&amp;cons, &apos; &apos;, 0); cmdline[cons.cur_x / 8 - 2] = 0; cons_newline(&amp;cons); cons_runcmd(cmdline, &amp;cons, fat, memtotal); cons_putchar(&amp;cons, &apos;&gt;&apos;, 1); &#125; else &#123; /* 一般字符 */ if (cons.cur_x &lt; 240) &#123; cmdline[cons.cur_x / 8 - 2] = i - 256; cons_putchar(&amp;cons, i - 256, 1); &#125; &#125; &#125; if (cons.cur_c &gt;= 0) &#123; boxfill8(sheet-&gt;buf, sheet-&gt;bxsize, cons.cur_c, cons.cur_x, cons.cur_y, cons.cur_x + 7, cons.cur_y + 15); &#125; sheet_refresh(sheet, cons.cur_x, cons.cur_y, cons.cur_x + 8, cons.cur_y + 16); &#125; &#125;&#125;void cons_putchar(struct CONSOLE *cons, int chr, char move)&#123; char s[2]; s[0] = chr; s[1] = 0; if (s[0] == 0x09) &#123; for (;;) &#123; putfonts8_asc_sht(cons-&gt;sht, cons-&gt;cur_x, cons-&gt;cur_y, COL8_FFFFFF, COL8_000000, &quot; &quot;, 1); cons-&gt;cur_x += 8; if (cons-&gt;cur_x == 8 + 240) &#123; cons_newline(cons); &#125; if (((cons-&gt;cur_x - 8) &amp; 0x1f) == 0) &#123; break; &#125; &#125; &#125; else if (s[0] == 0x0a) &#123; cons_newline(cons); &#125; else if (s[0] == 0x0d) &#123; &#125; else &#123; putfonts8_asc_sht(cons-&gt;sht, cons-&gt;cur_x, cons-&gt;cur_y, COL8_FFFFFF, COL8_000000, s, 1); if (move != 0) &#123; cons-&gt;cur_x += 8; if (cons-&gt;cur_x == 8 + 240) &#123; cons_newline(cons); &#125; &#125; &#125; return;&#125;void cons_newline(struct CONSOLE *cons)&#123; int x, y; struct SHEET *sheet = cons-&gt;sht; if (cons-&gt;cur_y &lt; 28 + 112) &#123; cons-&gt;cur_y += 16; &#125; else &#123; for (y = 28; y &lt; 28 + 112; y++) &#123; for (x = 8; x &lt; 8 + 240; x++) &#123; sheet-&gt;buf[x + y * sheet-&gt;bxsize] = sheet-&gt;buf[x + (y + 16) * sheet-&gt;bxsize]; &#125; &#125; for (y = 28 + 112; y &lt; 28 + 128; y++) &#123; for (x = 8; x &lt; 8 + 240; x++) &#123; sheet-&gt;buf[x + y * sheet-&gt;bxsize] = COL8_000000; &#125; &#125; sheet_refresh(sheet, 8, 28, 8 + 240, 28 + 128); &#125; cons-&gt;cur_x = 8; return;&#125;void cons_runcmd(char *cmdline, struct CONSOLE *cons, int *fat, unsigned int memtotal)&#123; if (strcmp(cmdline, &quot;mem&quot;) == 0) &#123; cmd_mem(cons, memtotal); &#125; else if (strcmp(cmdline, &quot;cls&quot;) == 0) &#123; cmd_cls(cons); &#125; else if (strcmp(cmdline, &quot;dir&quot;) == 0) &#123; cmd_dir(cons); &#125; else if (strncmp(cmdline, &quot;type &quot;, 5) == 0) &#123; cmd_type(cons, fat, cmdline); &#125; else if (strcmp(cmdline, &quot;hlt&quot;) == 0) &#123; cmd_hlt(cons, fat); &#125; else if (cmdline[0] != 0) &#123; putfonts8_asc_sht(cons-&gt;sht, 8, cons-&gt;cur_y, COL8_FFFFFF, COL8_000000, &quot;Bad command.&quot;, 12); cons_newline(cons); cons_newline(cons); &#125; return;&#125;void cmd_mem(struct CONSOLE *cons, unsigned int memtotal)&#123; struct MEMMAN *memman = (struct MEMMAN *) MEMMAN_ADDR; char s[30]; sprintf(s, &quot;total %dMB&quot;, memtotal / (1024 * 1024)); putfonts8_asc_sht(cons-&gt;sht, 8, cons-&gt;cur_y, COL8_FFFFFF, COL8_000000, s, 30); cons_newline(cons); sprintf(s, &quot;free %dKB&quot;, memman_total(memman) / 1024); putfonts8_asc_sht(cons-&gt;sht, 8, cons-&gt;cur_y, COL8_FFFFFF, COL8_000000, s, 30); cons_newline(cons); cons_newline(cons); return;&#125;void cmd_cls(struct CONSOLE *cons)&#123; int x, y; struct SHEET *sheet = cons-&gt;sht; for (y = 28; y &lt; 28 + 128; y++) &#123; for (x = 8; x &lt; 8 + 240; x++) &#123; sheet-&gt;buf[x + y * sheet-&gt;bxsize] = COL8_000000; &#125; &#125; sheet_refresh(sheet, 8, 28, 8 + 240, 28 + 128); cons-&gt;cur_y = 28; return;&#125;void cmd_dir(struct CONSOLE *cons)&#123; struct FILEINFO *finfo = (struct FILEINFO *) (ADR_DISKIMG + 0x002600); int i, j; char s[30]; for (i = 0; i &lt; 224; i++) &#123; if (finfo[i].name[0] == 0x00) &#123; break; &#125; if (finfo[i].name[0] != 0xe5) &#123; if ((finfo[i].type &amp; 0x18) == 0) &#123; sprintf(s, &quot;filename.ext %7d&quot;, finfo[i].size); for (j = 0; j &lt; 8; j++) &#123; s[j] = finfo[i].name[j]; &#125; s[ 9] = finfo[i].ext[0]; s[10] = finfo[i].ext[1]; s[11] = finfo[i].ext[2]; putfonts8_asc_sht(cons-&gt;sht, 8, cons-&gt;cur_y, COL8_FFFFFF, COL8_000000, s, 30); cons_newline(cons); &#125; &#125; &#125; cons_newline(cons); return;&#125;void cmd_type(struct CONSOLE *cons, int *fat, char *cmdline)&#123; struct MEMMAN *memman = (struct MEMMAN *) MEMMAN_ADDR; struct FILEINFO *finfo = file_search(cmdline + 5, (struct FILEINFO *) (ADR_DISKIMG + 0x002600), 224); char *p; int i; if (finfo != 0) &#123; p = (char *) memman_alloc_4k(memman, finfo-&gt;size); file_loadfile(finfo-&gt;clustno, finfo-&gt;size, p, fat, (char *) (ADR_DISKIMG + 0x003e00)); for (i = 0; i &lt; finfo-&gt;size; i++) &#123; cons_putchar(cons, p[i], 1); &#125; memman_free_4k(memman, (int) p, finfo-&gt;size); &#125; else &#123; putfonts8_asc_sht(cons-&gt;sht, 8, cons-&gt;cur_y, COL8_FFFFFF, COL8_000000, &quot;File not found.&quot;, 15); cons_newline(cons); &#125; cons_newline(cons); return;&#125;void cmd_hlt(struct CONSOLE *cons, int *fat)&#123; struct MEMMAN *memman = (struct MEMMAN *) MEMMAN_ADDR; struct FILEINFO *finfo = file_search(&quot;HLT.HRB&quot;, (struct FILEINFO *) (ADR_DISKIMG + 0x002600), 224); struct SEGMENT_DESCRIPTOR *gdt = (struct SEGMENT_DESCRIPTOR *) ADR_GDT; char *p; if (finfo != 0) &#123; p = (char *) memman_alloc_4k(memman, finfo-&gt;size); file_loadfile(finfo-&gt;clustno, finfo-&gt;size, p, fat, (char *) (ADR_DISKIMG + 0x003e00)); set_segmdesc(gdt + 1003, finfo-&gt;size - 1, (int) p, AR_CODE32_ER); farjmp(0, 1003 * 8); memman_free_4k(memman, (int) p, finfo-&gt;size); &#125; else &#123; putfonts8_asc_sht(cons-&gt;sht, 8, cons-&gt;cur_y, COL8_FFFFFF, COL8_000000, &quot;File not found.&quot;, 15); cons_newline(cons); &#125; cons_newline(cons); return;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940file.c 文件struct FILEINFO *file_search(char *name, struct FILEINFO *finfo, int max)&#123; int i, j; char s[12]; for (j = 0; j &lt; 11; j++) &#123; s[j] = &apos; &apos;; &#125; j = 0; for (i = 0; name[i] != 0; i++) &#123; if (j &gt;= 11) &#123; return 0; &#125; if (name[i] == &apos;.&apos; &amp;&amp; j &lt;= 8) &#123; j = 8; &#125; else &#123; s[j] = name[i]; if (&apos;a&apos; &lt;= s[j] &amp;&amp; s[j] &lt;= &apos;z&apos;) &#123; s[j] -= 0x20; &#125; j++; &#125; &#125; for (i = 0; i &lt; max; ) &#123; if (finfo[i].name[0] == 0x00) &#123; break; &#125; if ((finfo[i].type &amp; 0x18) == 0) &#123; for (j = 0; j &lt; 11; j++) &#123; if (finfo[i].name[j] != s[j]) &#123; goto next; &#125; &#125; return finfo + i; &#125;next: i++; &#125; return 0;&#125; 显示单个字符的API（1）（harib17b）给应用程序做一个API。 应用程序调用 asm_cons_putchar，asm_asm_putchar调用cons_putchar。 为什么要加一层，因为需要把参数推到栈里面。 1234567891011121314151617181920212223242526naskfunc.nas 文件_asm_cons_putchar: PUSH 1 AND EAX,0xff PUSH EAX PUSH DWORD [0x0fec] ; cons的地址 CALL _cons_putchar ADD ESP,12 ; 将栈中的数据丢弃 RET console.c 文件void console_task(struct SHEET *sheet, unsigned int memtotal)&#123; struct CONSOLE cons; char cmdline[30]; cons.sht = sheet; cons.cur_x = 8; cons.cur_y = 28; cons.cur_c = -1; *((int *) 0x0fec) = (int) &amp;cons; &#125; 123456[BITS 32] MOV AL,&apos;A&apos; CALL 0xbe3fin: HLT JMP fin 为什么是0xbe3呢，这个需要打开haribote.map文件，找到_asm_cons_putchar的地址。 显示单个字符的API（2）（harib17c)这样会造成模拟器出错，原因是调用的时候没有加上段地址，程序所在的段号是1003 8，而操作系统所在的段号位2 8 123456[BITS 32] MOV AL,&apos;A&apos; CALL 2*8:0xbe3fin: HLT JMP fin 结束应用程序（harib17d）执行程序后，我们应该让它再跳回到操作系统。 应用程序中的hlt改成RET，就可以返回了。相应地，操作系统应该用call代替jmp，应用程序也要相应地使用RETF。 1234567891011121314151617181920212223242526272829303132333435363738394041naskfunc.nas文件_farcall: ; void farcall(int eip, int cs); CALL FAR [ESP+4] ; eip, cs RET _asm_cons_putchar: PUSH 1 AND EAX,0xff PUSH EAX PUSH DWORD [0x0fec] CALL _cons_putchar ADD ESP,12 RETF console.c文件void cmd_hlt(struct CONSOLE *cons, int *fat)&#123; if (finfo != 0) &#123; farcall(0, 1003 * 8); &#125; else &#123; &#125;&#125;hlt.nas 文件[BITS 32] MOV AL,&apos;h&apos; CALL 2*8:0xbe8 MOV AL,&apos;e&apos; CALL 2*8:0xbe8 MOV AL,&apos;l&apos; CALL 2*8:0xbe8 MOV AL,&apos;l&apos; CALL 2*8:0xbe8 MOV AL,&apos;o&apos; CALL 2*8:0xbe8 RETF 不随操作系统版本而改变的API（harib17e）每次console的代码改变之后，_asm_cons_putchar的地址就会变化。 IDT是用来注册中断的。我们用0x40来调用API。 12345678910111213141516171819202122232425262728293031323334void init_gdtidt(void)&#123; set_gatedesc(idt + 0x20, (int) asm_inthandler20, 2 * 8, AR_INTGATE32); set_gatedesc(idt + 0x21, (int) asm_inthandler21, 2 * 8, AR_INTGATE32); set_gatedesc(idt + 0x27, (int) asm_inthandler27, 2 * 8, AR_INTGATE32); set_gatedesc(idt + 0x2c, (int) asm_inthandler2c, 2 * 8, AR_INTGATE32); set_gatedesc(idt + 0x40, (int) asm_cons_putchar, 2 * 8, AR_INTGATE32); return;&#125;_asm_cons_putchar: STI PUSH 1 AND EAX,0xff PUSH EAX PUSH DWORD [0x0fec] CALL _cons_putchar ADD ESP,12 IRETD [BITS 32] MOV AL,&apos;h&apos; INT 0x40 MOV AL,&apos;e&apos; INT 0x40 MOV AL,&apos;l&apos; INT 0x40 MOV AL,&apos;l&apos; INT 0x40 MOV AL,&apos;o&apos; INT 0x40 RETF 为应用程序自由命名（harib17f）现在只能执行hlt文件，换个其他名字就不可以了，所以这次解决这个问题。 1234567891011121314151617181920212223242526272829303132333435363738int cmd_app(struct CONSOLE *cons, int *fat, char *cmdline)&#123; struct MEMMAN *memman = (struct MEMMAN *) MEMMAN_ADDR; struct FILEINFO *finfo; struct SEGMENT_DESCRIPTOR *gdt = (struct SEGMENT_DESCRIPTOR *) ADR_GDT; char name[18], *p; int i; for (i = 0; i &lt; 13; i++) &#123; if (cmdline[i] &lt;= &apos; &apos;) &#123; break; &#125; name[i] = cmdline[i]; &#125; name[i] = 0; finfo = file_search(name, (struct FILEINFO *) (ADR_DISKIMG + 0x002600), 224); if (finfo == 0 &amp;&amp; name[i - 1] != &apos;.&apos;) &#123; name[i ] = &apos;.&apos;; name[i + 1] = &apos;H&apos;; name[i + 2] = &apos;R&apos;; name[i + 3] = &apos;B&apos;; name[i + 4] = 0; finfo = file_search(name, (struct FILEINFO *) (ADR_DISKIMG + 0x002600), 224); &#125; if (finfo != 0) &#123; p = (char *) memman_alloc_4k(memman, finfo-&gt;size); file_loadfile(finfo-&gt;clustno, finfo-&gt;size, p, fat, (char *) (ADR_DISKIMG + 0x003e00)); set_segmdesc(gdt + 1003, finfo-&gt;size - 1, (int) p, AR_CODE32_ER); farcall(0, 1003 * 8); memman_free_4k(memman, (int) p, finfo-&gt;size); cons_newline(cons); return 1; &#125; return 0;&#125; 当心寄存器（harib17g）1234567891011121314[INSTRSET &quot;i486p&quot;][BITS 32] MOV ECX,msgputloop: MOV AL,[CS:ECX] CMP AL,0 JE fin INT 0x40 ADD ECX,1 JMP putloopfin: RETFmsg: DB &quot;hello&quot;,0 这样的显示结果只有h 修改代码 1234567891011_asm_cons_putchar: STI PUSHAD PUSH 1 AND EAX,0xff PUSH EAX PUSH DWORD [0x0fec] CALL _cons_putchar ADD ESP,12 POPAD IRETD 调用 0x40之后，ECX寄存器的值发生了变化，所以加上PUDHAD和POPAD保证全部寄存器的值还原，这样就可以正常执行了。 用API显示字符串（harib17h）12345678910111213141516void cons_putstr0(struct CONSOLE *cons, char *s)&#123; for (; *s != 0; s++) &#123; cons_putchar(cons, *s, 1); &#125; return;&#125;void cons_putstr1(struct CONSOLE *cons, char *s, int l)&#123; int i; for (i = 0; i &lt; l; i++) &#123; cons_putchar(cons, s[i], 1); &#125; return;&#125; 现在有三个函数了，用EDX存放功能号，判断调用哪个函数。 123456789101112131415161718192021222324252627282930313233_asm_hrb_api: STI PUSHAD ; PUSHAD ; hrb_api传值的push CALL _hrb_api ADD ESP,32 POPAD IRETD void hrb_api(int edi, int esi, int ebp, int esp, int ebx, int edx, int ecx, int eax)&#123; struct CONSOLE *cons = (struct CONSOLE *) *((int *) 0x0fec); if (edx == 1) &#123; cons_putchar(cons, eax &amp; 0xff, 1); &#125; else if (edx == 2) &#123; cons_putstr0(cons, (char *) ebx); &#125; else if (edx == 3) &#123; cons_putstr1(cons, (char *) ebx, ecx); &#125; return;&#125;void init_gdtidt(void)&#123; set_gatedesc(idt + 0x20, (int) asm_inthandler20, 2 * 8, AR_INTGATE32); set_gatedesc(idt + 0x21, (int) asm_inthandler21, 2 * 8, AR_INTGATE32); set_gatedesc(idt + 0x27, (int) asm_inthandler27, 2 * 8, AR_INTGATE32); set_gatedesc(idt + 0x2c, (int) asm_inthandler2c, 2 * 8, AR_INTGATE32); set_gatedesc(idt + 0x40, (int) asm_hrb_api, 2 * 8, AR_INTGATE32); return;&#125; 12345678910hello2.nas[INSTRSET &quot;i486p&quot;][BITS 32] MOV EDX,2 MOV EBX,msg INT 0x40 RETFmsg: DB &quot;hello&quot;,0 显示失败 123456789101112131415[INSTRSET &quot;i486p&quot;][BITS 32] MOV ECX,msg MOV EDX,1putloop: MOV AL,[CS:ECX] CMP AL,0 JE fin INT 0x40 ADD ECX,1 JMP putloopfin: RETFmsg: DB &quot;hello&quot;,0 显示成功。","tags":[{"name":"30天自制操作系统","slug":"30天自制操作系统","permalink":"http://yoursite.com/tags/30天自制操作系统/"},{"name":"单个字符的API","slug":"单个字符的API","permalink":"http://yoursite.com/tags/单个字符的API/"},{"name":"字符串的API","slug":"字符串的API","permalink":"http://yoursite.com/tags/字符串的API/"}]},{"title":"19 自制操作系统第十九天","date":"2018-02-02T09:00:00.000Z","path":"2018/02/02/omake_19/","text":"项目地址 123456主要内容：1. type命令（harib16a）2. type命令改良（harib16b）3. 对FAT的支持（harib16c)4. 代码整理（harib16d）5. 第一个应用程序（harib16e） type命令（harib16a）把文件内容打印出来。 磁盘影像中的地址 = clustno * 512 + 0x003e00 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596void console_task(struct SHEET *sheet, unsigned int memtotal)&#123; for (;;) &#123; io_cli(); if (fifo32_status(&amp;task-&gt;fifo) == 0) &#123; &#125; else &#123; if (i &lt;= 1) &#123; &#125; if (i == 2) &#123; &#125; if (i == 3) &#123; &#125; if (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; if (i == 8 + 256) &#123; &#125; else if (i == 10 + 256) &#123; /* Enter */ putfonts8_asc_sht(sheet, cursor_x, cursor_y, COL8_FFFFFF, COL8_000000, &quot; &quot;, 1); cmdline[cursor_x / 8 - 2] = 0; cursor_y = cons_newline(cursor_y, sheet); if (strcmp(cmdline, &quot;mem&quot;) == 0) &#123; &#125; else if (strcmp(cmdline, &quot;cls&quot;) == 0) &#123; &#125; else if (strcmp(cmdline, &quot;dir&quot;) == 0) &#123; &#125; else if (cmdline[0] == &apos;t&apos; &amp;&amp; cmdline[1] == &apos;y&apos; &amp;&amp; cmdline[2] == &apos;p&apos; &amp;&amp; cmdline[3] == &apos;e&apos; &amp;&amp; cmdline[4] == &apos; &apos;) &#123; for (y = 0; y &lt; 11; y++) &#123; s[y] = &apos; &apos;; &#125; y = 0; for (x = 5; y &lt; 11 &amp;&amp; cmdline[x] != 0; x++) &#123; if (cmdline[x] == &apos;.&apos; &amp;&amp; y &lt;= 8) &#123; y = 8; &#125; else &#123; s[y] = cmdline[x]; if (&apos;a&apos; &lt;= s[y] &amp;&amp; s[y] &lt;= &apos;z&apos;) &#123; s[y] -= 0x20; &#125; y++; &#125; &#125; for (x = 0; x &lt; 224; ) &#123; if (finfo[x].name[0] == 0x00) &#123; break; &#125; if ((finfo[x].type &amp; 0x18) == 0) &#123; for (y = 0; y &lt; 11; y++) &#123; if (finfo[x].name[y] != s[y]) &#123; goto type_next_file; &#125; &#125; break; &#125; type_next_file: x++; &#125; if (x &lt; 224 &amp;&amp; finfo[x].name[0] != 0x00) &#123; y = finfo[x].size; p = (char *) (finfo[x].clustno * 512 + 0x003e00 + ADR_DISKIMG); cursor_x = 8; for (x = 0; x &lt; y; x++) &#123; s[0] = p[x]; s[1] = 0; putfonts8_asc_sht(sheet, cursor_x, cursor_y, COL8_FFFFFF, COL8_000000, s, 1); cursor_x += 8; if (cursor_x == 8 + 240) &#123; cursor_x = 8; cursor_y = cons_newline(cursor_y, sheet); &#125; &#125; &#125; else &#123; putfonts8_asc_sht(sheet, 8, cursor_y, COL8_FFFFFF, COL8_000000, &quot;File not found.&quot;, 15); cursor_y = cons_newline(cursor_y, sheet); &#125; cursor_y = cons_newline(cursor_y, sheet); &#125; else if (cmdline[0] != 0) &#123; &#125; &#125; else &#123; &#125; &#125; &#125; &#125;&#125; type命令改良（harib16b）0x09 制表符：显示空格直到x被4整除为止0x0a 换行符：换行0x0d 回车符：暂时忽略 windows 回车换行用两个字节表示即 0x0d 0x0alinux 回车换行用一个字节表示即 0x0a 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980void console_task(struct SHEET *sheet, unsigned int memtotal)&#123; for (;;) &#123; io_cli(); if (fifo32_status(&amp;task-&gt;fifo) == 0) &#123; &#125; else &#123; if (i &lt;= 1) &#123; &#125; if (i == 2) &#123; &#125; if (i == 3) &#123; &#125; if (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; if (i == 8 + 256) &#123; &#125; else if (i == 10 + 256) &#123; /* Enter */ putfonts8_asc_sht(sheet, cursor_x, cursor_y, COL8_FFFFFF, COL8_000000, &quot; &quot;, 1); cmdline[cursor_x / 8 - 2] = 0; cursor_y = cons_newline(cursor_y, sheet); if (strcmp(cmdline, &quot;mem&quot;) == 0) &#123; &#125; else if (strcmp(cmdline, &quot;cls&quot;) == 0) &#123; &#125; else if (strcmp(cmdline, &quot;dir&quot;) == 0) &#123; &#125; else if (strncmp(cmdline, &quot;type &quot;, 5) == 0) &#123; if (x &lt; 224 &amp;&amp; finfo[x].name[0] != 0x00) &#123; y = finfo[x].size; p = (char *) (finfo[x].clustno * 512 + 0x003e00 + ADR_DISKIMG); cursor_x = 8; for (x = 0; x &lt; y; x++) &#123; s[0] = p[x]; s[1] = 0; if (s[0] == 0x09) &#123; for (;;) &#123; putfonts8_asc_sht(sheet, cursor_x, cursor_y, COL8_FFFFFF, COL8_000000, &quot; &quot;, 1); cursor_x += 8; if (cursor_x == 8 + 240) &#123; cursor_x = 8; cursor_y = cons_newline(cursor_y, sheet); &#125; if (((cursor_x - 8) &amp; 0x1f) == 0) &#123; break; &#125; &#125; &#125; else if (s[0] == 0x0a) &#123; cursor_x = 8; cursor_y = cons_newline(cursor_y, sheet); &#125; else if (s[0] == 0x0d) &#123; &#125; else &#123; putfonts8_asc_sht(sheet, cursor_x, cursor_y, COL8_FFFFFF, COL8_000000, s, 1); cursor_x += 8; if (cursor_x == 8 + 240) &#123; cursor_x = 8; cursor_y = cons_newline(cursor_y, sheet); &#125; &#125; &#125; &#125; else &#123; &#125; &#125; else if (cmdline[0] != 0) &#123; &#125; &#125; else &#123; &#125; &#125; &#125; &#125;&#125; 对FAT的支持（harib16c)如果文件的大小大于512字节的话，读的内容有可能是别的文件的内容，因为文件存放的位置可能不是连续的。 FAT是文件分配表。 FAT用三个字节表示2个扇区 12F0 FF FF -&gt; FF0 FFFab cd ef -&gt; dab efc hariboty.sys文件的扇区是2，FAT的第2号记录是3，也就是说下面的部分放在3扇区，然后依次往后读。如果遇到FF8~FFF的值，这就代表文件数据到此结束。 FAT文件放在磁盘的0x00200~0x0013ff 1234567891011void file_readfat(int *fat, unsigned char *img)/* FAT解压缩 */&#123; int i, j = 0; for (i = 0; i &lt; 2880; i += 2) &#123; fat[i + 0] = (img[j + 0] | img[j + 1] &lt;&lt; 8) &amp; 0xfff; fat[i + 1] = (img[j + 1] &gt;&gt; 4 | img[j + 2] &lt;&lt; 4) &amp; 0xfff; j += 3; &#125; return;&#125; 12345678910111213141516171819void file_loadfile(int clustno, int size, char *buf, int *fat, char *img)&#123; int i; for (;;) &#123; if (size &lt;= 512) &#123; for (i = 0; i &lt; size; i++) &#123; buf[i] = img[clustno * 512 + i]; &#125; break; &#125; for (i = 0; i &lt; 512; i++) &#123; buf[i] = img[clustno * 512 + i]; &#125; size -= 512; buf += 512; clustno = fat[clustno]; &#125; return;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657void console_task(struct SHEET *sheet, unsigned int memtotal)&#123; for (;;) &#123; io_cli(); if (fifo32_status(&amp;task-&gt;fifo) == 0) &#123; &#125; else &#123; if (i &lt;= 1) &#123; &#125; if (i == 2) &#123; &#125; if (i == 3) &#123; &#125; if (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; if (i == 8 + 256) &#123; &#125; else if (i == 10 + 256) &#123; /* Enter */ putfonts8_asc_sht(sheet, cursor_x, cursor_y, COL8_FFFFFF, COL8_000000, &quot; &quot;, 1); cmdline[cursor_x / 8 - 2] = 0; cursor_y = cons_newline(cursor_y, sheet); if (strcmp(cmdline, &quot;mem&quot;) == 0) &#123; &#125; else if (strcmp(cmdline, &quot;cls&quot;) == 0) &#123; &#125; else if (strcmp(cmdline, &quot;dir&quot;) == 0) &#123; &#125; else if (strncmp(cmdline, &quot;type &quot;, 5) == 0) &#123; if (x &lt; 224 &amp;&amp; finfo[x].name[0] != 0x00) &#123; p = (char *) memman_alloc_4k(memman, finfo[x].size); file_loadfile(finfo[x].clustno, finfo[x].size, p, fat, (char *) (ADR_DISKIMG + 0x003e00)); cursor_x = 8; for (y = 0; y &lt; finfo[x].size; y++) &#123; s[0] = p[y]; s[1] = 0; &#125; memman_free_4k(memman, (int) p, finfo[x].size); &#125; else &#123; &#125; &#125; else if (cmdline[0] != 0) &#123; &#125; &#125; else &#123; &#125; &#125; &#125; &#125;&#125; 代码整理（harib16d）窗口相关函数 -&gt; window.c命令行窗口相关函数 -&gt; console.c文件相关函数 -&gt; file.c 第一个应用程序（harib16e）hlt.hrb 成功读入内存之后，将其注册为GDT的103号，使用farjmp跳转并运行。 123456第一个程序如下：[BITS 32]fin: HLT JMP fin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384void console_task(struct SHEET *sheet, unsigned int memtotal)&#123; for (;;) &#123; io_cli(); if (fifo32_status(&amp;task-&gt;fifo) == 0) &#123; &#125; else &#123; if (i &lt;= 1) &#123; &#125; if (i == 2) &#123; &#125; if (i == 3) &#123; &#125; if (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; if (i == 8 + 256) &#123; &#125; else if (i == 10 + 256) &#123; /* Enter */ putfonts8_asc_sht(sheet, cursor_x, cursor_y, COL8_FFFFFF, COL8_000000, &quot; &quot;, 1); cmdline[cursor_x / 8 - 2] = 0; cursor_y = cons_newline(cursor_y, sheet); if (strcmp(cmdline, &quot;mem&quot;) == 0) &#123; &#125; else if (strcmp(cmdline, &quot;cls&quot;) == 0) &#123; &#125; else if (strcmp(cmdline, &quot;dir&quot;) == 0) &#123; &#125; else if (strncmp(cmdline, &quot;type &quot;, 5) == 0) &#123; &#125; else if (strcmp(cmdline, &quot;hlt&quot;) == 0) &#123; for (y = 0; y &lt; 11; y++) &#123; s[y] = &apos; &apos;; &#125; s[0] = &apos;H&apos;; s[1] = &apos;L&apos;; s[2] = &apos;T&apos;; s[8] = &apos;H&apos;; s[9] = &apos;R&apos;; s[10] = &apos;B&apos;; for (x = 0; x &lt; 224; ) &#123; if (finfo[x].name[0] == 0x00) &#123; break; &#125; if ((finfo[x].type &amp; 0x18) == 0) &#123; for (y = 0; y &lt; 11; y++) &#123; if (finfo[x].name[y] != s[y]) &#123; goto hlt_next_file; &#125; &#125; break; &#125; hlt_next_file: x++; &#125; if (x &lt; 224 &amp;&amp; finfo[x].name[0] != 0x00) &#123; p = (char *) memman_alloc_4k(memman, finfo[x].size); file_loadfile(finfo[x].clustno, finfo[x].size, p, fat, (char *) (ADR_DISKIMG + 0x003e00)); set_segmdesc(gdt + 1003, finfo[x].size - 1, (int) p, AR_CODE32_ER); farjmp(0, 1003 * 8); memman_free_4k(memman, (int) p, finfo[x].size); &#125; else &#123; putfonts8_asc_sht(sheet, 8, cursor_y, COL8_FFFFFF, COL8_000000, &quot;File not found.&quot;, 15); cursor_y = cons_newline(cursor_y, sheet); &#125; cursor_y = cons_newline(cursor_y, sheet); &#125; else if (cmdline[0] != 0) &#123; &#125; &#125; else &#123; &#125; &#125; &#125; &#125;&#125;","tags":[{"name":"30天自制操作系统","slug":"30天自制操作系统","permalink":"http://yoursite.com/tags/30天自制操作系统/"},{"name":"type命令","slug":"type命令","permalink":"http://yoursite.com/tags/type命令/"}]},{"title":"18 自制操作系统第十八天","date":"2018-02-02T04:00:00.000Z","path":"2018/02/02/omake_18/","text":"项目地址 12345678主要内容：1. 控制光标闪烁（1）（harib15a）2. 控制光标闪烁（2）（harib15b）3. 对回车键的支持（harib15c)4. 对窗口滚动的支持（harib15d）5. mem命令（harib15e）6. cls命令(harib15f)7. dir命令（harib15g) 控制光标闪烁（1）（harib15a）当 当前窗口不是taska的时候，光标停止闪烁 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748void HariMain(void)&#123; for (;;) &#123; if (fifo32_status(&amp;fifo) == 0) &#123; task_sleep(task_a); io_sti(); &#125; else &#123; if (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; if (i == 256 + 0x0f) &#123; /* Tab键 */ if (key_to == 0) &#123; key_to = 1; make_wtitle8(buf_win, sht_win-&gt;bxsize, &quot;task_a&quot;, 0); make_wtitle8(buf_cons, sht_cons-&gt;bxsize, &quot;console&quot;, 1); cursor_c = -1; boxfill8(sht_win-&gt;buf, sht_win-&gt;bxsize, COL8_FFFFFF, cursor_x, 28, cursor_x + 7, 43); &#125; else &#123; key_to = 0; make_wtitle8(buf_win, sht_win-&gt;bxsize, &quot;task_a&quot;, 1); make_wtitle8(buf_cons, sht_cons-&gt;bxsize, &quot;console&quot;, 0); cursor_c = COL8_000000; &#125; sheet_refresh(sht_win, 0, 0, sht_win-&gt;bxsize, 21); sheet_refresh(sht_cons, 0, 0, sht_cons-&gt;bxsize, 21); &#125; &#125; else if (512 &lt;= i &amp;&amp; i &lt;= 767) &#123; &#125; else if (i &lt;= 1)&#123; if (i != 0) &#123; timer_init(timer, &amp;fifo, 0); if (cursor_c &gt;= 0) &#123; cursor_c = COL8_000000; &#125; &#125; else &#123; timer_init(timer, &amp;fifo, 1); if (cursor_c &gt;= 0) &#123; cursor_c = COL8_FFFFFF; &#125; &#125; timer_settime(timer, 50); if (cursor_c &gt;= 0) &#123; boxfill8(sht_win-&gt;buf, sht_win-&gt;bxsize, cursor_c, cursor_x, 28, cursor_x + 7, 43); sheet_refresh(sht_win, cursor_x, 28, cursor_x + 8, 44); &#125; &#125; &#125; &#125;&#125; 控制光标闪烁（2）（harib15b）任务A向console_task传递消息，然后console_task只是在当前窗口才闪烁。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950void HariMain(void)&#123; for (;;) &#123; if (fifo32_status(&amp;fifo) == 0) &#123; task_sleep(task_a); io_sti(); &#125; else &#123; if (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; if (i == 256 + 0x0f) &#123; /* Tab键 */ if (key_to == 0) &#123; key_to = 1; make_wtitle8(buf_win, sht_win-&gt;bxsize, &quot;task_a&quot;, 0); make_wtitle8(buf_cons, sht_cons-&gt;bxsize, &quot;console&quot;, 1); cursor_c = -1; boxfill8(sht_win-&gt;buf, sht_win-&gt;bxsize, COL8_FFFFFF, cursor_x, 28, cursor_x + 7, 43); fifo32_put(&amp;task_cons-&gt;fifo, 2); /* 命令行窗口on */ &#125; else &#123; key_to = 0; make_wtitle8(buf_win, sht_win-&gt;bxsize, &quot;task_a&quot;, 1); make_wtitle8(buf_cons, sht_cons-&gt;bxsize, &quot;console&quot;, 0); cursor_c = COL8_000000; fifo32_put(&amp;task_cons-&gt;fifo, 3);/* 命令窗口off */ &#125; sheet_refresh(sht_win, 0, 0, sht_win-&gt;bxsize, 21); sheet_refresh(sht_cons, 0, 0, sht_cons-&gt;bxsize, 21); &#125; &#125; else if (512 &lt;= i &amp;&amp; i &lt;= 767) &#123; &#125; else if (i &lt;= 1)&#123; if (i != 0) &#123; timer_init(timer, &amp;fifo, 0); if (cursor_c &gt;= 0) &#123; cursor_c = COL8_000000; &#125; &#125; else &#123; timer_init(timer, &amp;fifo, 1); if (cursor_c &gt;= 0) &#123; cursor_c = COL8_FFFFFF; &#125; &#125; timer_settime(timer, 50); if (cursor_c &gt;= 0) &#123; boxfill8(sht_win-&gt;buf, sht_win-&gt;bxsize, cursor_c, cursor_x, 28, cursor_x + 7, 43); sheet_refresh(sht_win, cursor_x, 28, cursor_x + 8, 44); &#125; &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859void console_task(struct SHEET *sheet)&#123; struct TIMER *timer; struct TASK *task = task_now(); int i, fifobuf[128], cursor_x = 16, cursor_c = -1; char s[2]; for (;;) &#123; io_cli(); if (fifo32_status(&amp;task-&gt;fifo) == 0) &#123; task_sleep(task); io_sti(); &#125; else &#123; i = fifo32_get(&amp;task-&gt;fifo); io_sti(); if (i &lt;= 1) &#123; if (i != 0) &#123; timer_init(timer, &amp;task-&gt;fifo, 0); if (cursor_c &gt;= 0) &#123; cursor_c = COL8_FFFFFF; &#125; &#125; else &#123; timer_init(timer, &amp;task-&gt;fifo, 1); if (cursor_c &gt;= 0) &#123; cursor_c = COL8_000000; &#125; &#125; timer_settime(timer, 50); &#125; if (i == 2) &#123; cursor_c = COL8_FFFFFF; &#125; if (i == 3) &#123; boxfill8(sheet-&gt;buf, sheet-&gt;bxsize, COL8_000000, cursor_x, 28, cursor_x + 7, 43); cursor_c = -1; &#125; if (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; if (i == 8 + 256) &#123; if (cursor_x &gt; 16) &#123; putfonts8_asc_sht(sheet, cursor_x, 28, COL8_FFFFFF, COL8_000000, &quot; &quot;, 1); cursor_x -= 8; &#125; &#125; else &#123; if (cursor_x &lt; 240) &#123; s[0] = i - 256; s[1] = 0; putfonts8_asc_sht(sheet, cursor_x, 28, COL8_FFFFFF, COL8_000000, s, 1); cursor_x += 8; &#125; &#125; &#125; if (cursor_c &gt;= 0) &#123; boxfill8(sheet-&gt;buf, sheet-&gt;bxsize, cursor_c, cursor_x, 28, cursor_x + 7, 43); &#125; sheet_refresh(sheet, cursor_x, 28, cursor_x + 8, 44); &#125; &#125;&#125; 对回车键的支持（harib15c)123456789101112131415161718192021void HariMain(void)&#123; for (;;) &#123; if (fifo32_status(&amp;fifo) == 0) &#123; task_sleep(task_a); io_sti(); &#125; else &#123; if (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; if (i == 256 + 0x1c) &#123; /* Enter */ if (key_to != 0) &#123; fifo32_put(&amp;task_cons-&gt;fifo, 10 + 256); &#125; &#125; &#125; else if (512 &lt;= i &amp;&amp; i &lt;= 767) &#123; &#125; else if (i &lt;= 1)&#123; &#125; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445void console_task(struct SHEET *sheet)&#123; struct TIMER *timer; struct TASK *task = task_now(); int i, fifobuf[128], cursor_x = 16, cursor_c = -1; char s[2]; for (;;) &#123; io_cli(); if (fifo32_status(&amp;task-&gt;fifo) == 0) &#123; task_sleep(task); io_sti(); &#125; else &#123; i = fifo32_get(&amp;task-&gt;fifo); io_sti(); if (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; if (i == 8 + 256) &#123; if (cursor_x &gt; 16) &#123; putfonts8_asc_sht(sheet, cursor_x, 28, COL8_FFFFFF, COL8_000000, &quot; &quot;, 1); cursor_x -= 8; &#125; &#125; else if (i == 10 + 256) &#123; /* Enter */ if (cursor_y &lt; 28 + 112) &#123; /* 用空格把光标擦除 */ putfonts8_asc_sht(sheet, cursor_x, cursor_y, COL8_FFFFFF, COL8_000000, &quot; &quot;, 1); cursor_y += 16; /* 显示提示符 */ putfonts8_asc_sht(sheet, 8, cursor_y, COL8_FFFFFF, COL8_000000, &quot;&gt;&quot;, 1); cursor_x = 16; &#125; &#125; else &#123; &#125; &#125; if (cursor_c &gt;= 0) &#123; boxfill8(sheet-&gt;buf, sheet-&gt;bxsize, cursor_c, cursor_x, 28, cursor_x + 7, 43); &#125; sheet_refresh(sheet, cursor_x, 28, cursor_x + 8, 44); &#125; &#125;&#125; 对窗口滚动的支持（harib15d）实现窗口滚动，只要将所有的像素向上移动一行，然后将最后一行涂黑就可以了。 12345678910111213141516171819202122232425262728293031323334353637383940414243void console_task(struct SHEET *sheet)&#123; int x, y; for (;;) &#123; io_cli(); if (fifo32_status(&amp;task-&gt;fifo) == 0) &#123; &#125; else &#123; if (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; if (i == 8 + 256) &#123; &#125; else if (i == 10 + 256) &#123; /* Enter */ putfonts8_asc_sht(sheet, cursor_x, cursor_y, COL8_FFFFFF, COL8_000000, &quot; &quot;, 1); if (cursor_y &lt; 28 + 112) &#123; cursor_y += 16; &#125; else &#123; for (y = 28; y &lt; 28 + 112; y++) &#123; for (x = 8; x &lt; 8 + 240; x++) &#123; sheet-&gt;buf[x + y * sheet-&gt;bxsize] = sheet-&gt;buf[x + (y + 16) * sheet-&gt;bxsize]; &#125; &#125; for (y = 28 + 112; y &lt; 28 + 128; y++) &#123; for (x = 8; x &lt; 8 + 240; x++) &#123; sheet-&gt;buf[x + y * sheet-&gt;bxsize] = COL8_000000; &#125; &#125; sheet_refresh(sheet, 8, 28, 8 + 240, 28 + 128); &#125; putfonts8_asc_sht(sheet, 8, cursor_y, COL8_FFFFFF, COL8_000000, &quot;&gt;&quot;, 1); cursor_x = 16; &#125; else &#123; &#125; &#125; &#125; &#125;&#125; mem命令（harib15e）既然可以显示出字母了，那就试试把它当成一个命令来使用。 1234567void HariMain(void)&#123; task_cons-&gt;tss.esp = memman_alloc_4k(memman, 64 * 1024) + 64 * 1024 - 12; *((int *) (task_cons-&gt;tss.esp + 4)) = (int) sht_cons; *((int *) (task_cons-&gt;tss.esp + 8)) = memtotal;&#125; 123456789101112131415161718192021int cons_newline(int cursor_y, struct SHEET *sheet)&#123; int x, y; if (cursor_y &lt; 28 + 112) &#123; cursor_y += 16; &#125; else &#123; for (y = 28; y &lt; 28 + 112; y++) &#123; for (x = 8; x &lt; 8 + 240; x++) &#123; sheet-&gt;buf[x + y * sheet-&gt;bxsize] = sheet-&gt;buf[x + (y + 16) * sheet-&gt;bxsize]; &#125; &#125; for (y = 28 + 112; y &lt; 28 + 128; y++) &#123; for (x = 8; x &lt; 8 + 240; x++) &#123; sheet-&gt;buf[x + y * sheet-&gt;bxsize] = COL8_000000; &#125; &#125; sheet_refresh(sheet, 8, 28, 8 + 240, 28 + 128); &#125; return cursor_y;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647void console_task(struct SHEET *sheet, unsigned int memtotal)&#123; char s[30], cmdline[30]; struct MEMMAN *memman = (struct MEMMAN *) MEMMAN_ADDR; for (;;) &#123; io_cli(); if (fifo32_status(&amp;task-&gt;fifo) == 0) &#123; &#125; else &#123; if (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; if (i == 8 + 256) &#123; &#125; else if (i == 10 + 256) &#123; cmdline[cursor_x / 8 - 2] = 0; cursor_y = cons_newline(cursor_y, sheet); if (cmdline[0] == &apos;m&apos; &amp;&amp; cmdline[1] == &apos;e&apos; &amp;&amp; cmdline[2] == &apos;m&apos; &amp;&amp; cmdline[3] == 0) &#123; sprintf(s, &quot;total %dMB&quot;, memtotal / (1024 * 1024)); putfonts8_asc_sht(sheet, 8, cursor_y, COL8_FFFFFF, COL8_000000, s, 30); cursor_y = cons_newline(cursor_y, sheet); sprintf(s, &quot;free %dKB&quot;, memman_total(memman) / 1024); putfonts8_asc_sht(sheet, 8, cursor_y, COL8_FFFFFF, COL8_000000, s, 30); cursor_y = cons_newline(cursor_y, sheet); cursor_y = cons_newline(cursor_y, sheet); &#125; else if (cmdline[0] != 0) &#123; putfonts8_asc_sht(sheet, 8, cursor_y, COL8_FFFFFF, COL8_000000, &quot;Bad command.&quot;, 12); cursor_y = cons_newline(cursor_y, sheet); cursor_y = cons_newline(cursor_y, sheet); &#125; &#125; else &#123; if (cursor_x &lt; 240) &#123; s[0] = i - 256; s[1] = 0; cmdline[cursor_x / 8 - 2] = i - 256; putfonts8_asc_sht(sheet, cursor_x, cursor_y, COL8_FFFFFF, COL8_000000, s, 1); cursor_x += 8; &#125; &#125; &#125; &#125; &#125;&#125; cls命令(harib15f)cls 就是把屏幕清空 1234567891011121314151617181920212223242526272829303132333435363738void console_task(struct SHEET *sheet, unsigned int memtotal)&#123; char s[30], cmdline[30]; struct MEMMAN *memman = (struct MEMMAN *) MEMMAN_ADDR; for (;;) &#123; io_cli(); if (fifo32_status(&amp;task-&gt;fifo) == 0) &#123; &#125; else &#123; if (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; if (i == 8 + 256) &#123; &#125; else if (i == 10 + 256) &#123; if (strcmp(cmdline, &quot;mem&quot;) == 0) &#123; &#125; else if (strcmp(cmdline, &quot;cls&quot;) == 0) &#123; for (y = 28; y &lt; 28 + 128; y++) &#123; for (x = 8; x &lt; 8 + 240; x++) &#123; sheet-&gt;buf[x + y * sheet-&gt;bxsize] = COL8_000000; &#125; &#125; sheet_refresh(sheet, 8, 28, 8 + 240, 28 + 128); cursor_y = 28; &#125; else if (cmdline[0] != 0) &#123; putfonts8_asc_sht(sheet, 8, cursor_y, COL8_FFFFFF, COL8_000000, &quot;Bad command.&quot;, 12); cursor_y = cons_newline(cursor_y, sheet); cursor_y = cons_newline(cursor_y, sheet); &#125; else &#123; &#125; &#125; &#125; &#125;&#125; dir命令（harib15g)磁盘的10个柱面的文件放到0x00100000~0x00267fff，文件信息放在0x002600之后，也就是内存地址的0x00102600 作为实验，把三个文件放到磁盘中 123456789makefile 文件haribote.img : ipl10.bin haribote.sys Makefile $(EDIMG) imgin:../z_tools/fdimg0at.tek \\ wbinimg src:ipl10.bin len:512 from:0 to:0 \\ copy from:haribote.sys to:@: \\ copy from:ipl10.nas to:@: \\ copy from:make.bat to:@: \\ imgout:haribote.img 文件信息是以32个字节为单元循环的 123456struct FILEINFO &#123; unsigned char name[8], ext[3], type; char reserve[10]; unsigned short time, date, clustno; unsigned int size;&#125;; 开始的8个字节是文件名。如果文件名的第一个字节为0xe5，代表这个文件被删除了；文件名第一个字节为0x00，代表这一段不包含任何文件名信息。文件信息最多可以放224个。 接下来三个字节是扩展名。 后面1个字节是文件的属性。一般不是0x20，即使0x00，其他的值如下：0x01 只读文件0x02 隐藏文件0x04 系统文件0x08 非文件信息0x00 目录 接下来的10个字节作为保留。 下面2个字节是Word整数，存放文件的时间。在下面的2个字节存放文件的日期。接下来的2个字节是这个文件的内容从磁盘上哪个扇区开始存放。 最后四个字节存放文件的大小 123bootpack.h 文件#define ADR_DISKIMG 0x00100000 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152void console_task(struct SHEET *sheet, unsigned int memtotal)&#123; char s[30], cmdline[30]; struct MEMMAN *memman = (struct MEMMAN *) MEMMAN_ADDR; for (;;) &#123; io_cli(); if (fifo32_status(&amp;task-&gt;fifo) == 0) &#123; &#125; else &#123; if (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; if (i == 8 + 256) &#123; &#125; else if (i == 10 + 256) &#123; if (strcmp(cmdline, &quot;mem&quot;) == 0) &#123; &#125; else if (strcmp(cmdline, &quot;cls&quot;) == 0) &#123; &#125; else if (strcmp(cmdline, &quot;dir&quot;) == 0) &#123; for (x = 0; x &lt; 224; x++) &#123; if (finfo[x].name[0] == 0x00) &#123; break; &#125; if (finfo[x].name[0] != 0xe5) &#123; if ((finfo[x].type &amp; 0x18) == 0) &#123; sprintf(s, &quot;filename.ext %7d&quot;, finfo[x].size); for (y = 0; y &lt; 8; y++) &#123; s[y] = finfo[x].name[y]; &#125; s[ 9] = finfo[x].ext[0]; s[10] = finfo[x].ext[1]; s[11] = finfo[x].ext[2]; putfonts8_asc_sht(sheet, 8, cursor_y, COL8_FFFFFF, COL8_000000, s, 30); cursor_y = cons_newline(cursor_y, sheet); &#125; &#125; &#125; cursor_y = cons_newline(cursor_y, sheet); &#125; else if (cmdline[0] != 0) &#123; putfonts8_asc_sht(sheet, 8, cursor_y, COL8_FFFFFF, COL8_000000, &quot;Bad command.&quot;, 12); cursor_y = cons_newline(cursor_y, sheet); cursor_y = cons_newline(cursor_y, sheet); &#125; else &#123; &#125; &#125; &#125; &#125;&#125;","tags":[{"name":"30天自制操作系统","slug":"30天自制操作系统","permalink":"http://yoursite.com/tags/30天自制操作系统/"},{"name":"窗口控制","slug":"窗口控制","permalink":"http://yoursite.com/tags/窗口控制/"},{"name":"窗口命令","slug":"窗口命令","permalink":"http://yoursite.com/tags/窗口命令/"}]},{"title":"17 自制操作系统第十七天","date":"2018-01-30T16:00:00.000Z","path":"2018/01/31/omake_17/","text":"项目地址 12345678主要内容：1. 闲置任务（harib14a）2. 创建命令行窗口（harib14b）3. 切换输入窗口（harib14c)4. 实现字符输入（harib14d）5. 符号的输入（harib14e）6. 大写字母与小写字母(harib14f)7. 对各种锁定键的支持（harib14g) 闲置任务（harib14a）如果只有任务A，没有键盘和鼠标的触发的时候，任务A进行休眠，然后去找其他任务，发现没有任务，程序会出错。 定义一个最低级的任务，它的职能就是休眠，这样总会有一个任务再执行。 12345void task_idle(void) &#123; for (;;) &#123; io_hlt(); &#125;&#125; 12345678910111213141516struct TASK *task_init(struct MEMMAN *memman) &#123; struct TASK *task, *idle; idle = task_alloc(); idle-&gt;tss.esp = memman_alloc_4k(memman, 64 * 1024) + 64 * 1024; idle-&gt;tss.eip = (int) &amp;task_idle; idle-&gt;tss.es = 1 * 8; idle-&gt;tss.cs = 2 * 8; idle-&gt;tss.ss = 1 * 8; idle-&gt;tss.ds = 1 * 8; idle-&gt;tss.fs = 1 * 8; idle-&gt;tss.gs = 1 * 8; task_run(idle, MAX_TASKLEVELS - 1, 1); return task; &#125; 创建命令行窗口（harib14b）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576void HariMain(void)&#123; /* sht_cons */ sht_cons = sheet_alloc(shtctl); buf_cons = (unsigned char *) memman_alloc_4k(memman, 256 * 165); sheet_setbuf(sht_cons, buf_cons, 256, 165, -1); /* ??????? */ make_window8(buf_cons, 256, 165, &quot;console&quot;, 0); make_textbox8(sht_cons, 8, 28, 240, 128, COL8_000000); task_cons = task_alloc(); task_cons-&gt;tss.esp = memman_alloc_4k(memman, 64 * 1024) + 64 * 1024 - 8; task_cons-&gt;tss.eip = (int) &amp;console_task; task_cons-&gt;tss.es = 1 * 8; task_cons-&gt;tss.cs = 2 * 8; task_cons-&gt;tss.ss = 1 * 8; task_cons-&gt;tss.ds = 1 * 8; task_cons-&gt;tss.fs = 1 * 8; task_cons-&gt;tss.gs = 1 * 8; *((int *) (task_cons-&gt;tss.esp + 4)) = (int) sht_cons; task_run(task_cons, 2, 2); /* level=2, priority=2 */ sheet_slide(sht_back, 0, 0); sheet_slide(sht_cons, 32, 4); sheet_slide(sht_win, 8, 56); sheet_slide(sht_mouse, mx, my); sheet_updown(sht_back, 0); sheet_updown(sht_cons, 1); sheet_updown(sht_win, 4); sheet_updown(sht_mouse, 5); &#125;void console_task (struct SHEET *sheet) &#123; struct FIFO32 fifo; struct TIMER *timer; struct TASK *task = task_now(); int i, fifobuf[128], cursor_x = 8, cursor_c = COL8_000000; fifo32_init(&amp;fifo, 128, fifobuf, task); timer = timer_alloc(); timer_init(timer, &amp;fifo, 1); timer_settime(timer, 50); for (;;) &#123; io_cli(); if (fifo32_status(&amp;fifo) == 0) &#123; task_sleep(task); io_sti(); &#125; else &#123; i = fifo32_get(&amp;fifo); io_sti(); if (i &lt;= 1)&#123; if (i != 0) &#123; timer_init(timer, &amp;fifo, 0); cursor_c = COL8_FFFFFF; &#125; else &#123; timer_init(timer, &amp;fifo, 1); cursor_c = COL8_000000; &#125; timer_settime(timer, 50); boxfill8(sheet-&gt;buf, sheet-&gt;bxsize, cursor_c, cursor_x, 28, cursor_x + 7, 43); sheet_refresh(sheet, cursor_x, 28, cursor_x + 8, 44); &#125; &#125; &#125;&#125; 切换输入窗口（harib14c)123456789101112131415161718192021222324252627282930313233343536373839void HariMain(void)&#123; int key_to = 0; for (;;) &#123; io_cli(); if (fifo32_status(&amp;fifo) == 0) &#123; task_sleep(task_a); io_sti(); &#125; else &#123; i = fifo32_get(&amp;fifo); io_sti(); if (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; if (i == 256 + 0x0f) &#123; /* Tab */ if (key_to == 0) &#123; key_to = 1; make_wtitle8(buf_win, sht_win-&gt;bxsize, &quot;task_a&quot;, 0); make_wtitle8(buf_cons, sht_cons-&gt;bxsize, &quot;console&quot;, 1); &#125; else &#123; key_to = 0; make_wtitle8(buf_win, sht_win-&gt;bxsize, &quot;task_a&quot;, 1); make_wtitle8(buf_cons, sht_cons-&gt;bxsize, &quot;console&quot;, 0); &#125; sheet_refresh(sht_win, 0, 0, sht_win-&gt;bxsize, 21); sheet_refresh(sht_cons, 0, 0, sht_cons-&gt;bxsize, 21); &#125; boxfill8(sht_win-&gt;buf, sht_win-&gt;bxsize, cursor_c, cursor_x, 28, cursor_x + 7, 43); sheet_refresh(sht_win, cursor_x, 28, cursor_x + 8, 44); &#125; else if (512 &lt;= i &amp;&amp; i &lt;= 767) &#123; &#125; else if (i &lt;= 1) &#123; &#125; &#125; &#125;&#125; 实现字符输入（harib14d）123456struct TASK &#123; int sel, flags; int level, priority; struct FIFO32 fifo; struct TSS32 tss;&#125;; 123456789101112131415161718192021222324252627282930void HariMain(void)&#123; for (;;) &#123; if (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; /* 键盘数据 */ if (i &lt; 0x54 + 256 &amp;&amp; keytable[i - 256] != 0) &#123; * 一般字符 */ if (key_to == 0) &#123; if (cursor_x &lt; 128) &#123; s[0] = keytable[i - 256]; s[1] = 0; putfonts8_asc_sht(sht_win, cursor_x, 28, COL8_000000, COL8_FFFFFF, s, 1); cursor_x += 8; &#125; &#125; else &#123; fifo32_put(&amp;task_cons-&gt;fifo, keytable[i - 256] + 256); &#125; &#125; if (i == 256 + 0x0e) &#123; /* 退格键 */ if (key_to == 0) &#123; if (cursor_x &gt; 8) &#123; putfonts8_asc_sht(sht_win, cursor_x, 28, COL8_000000, COL8_FFFFFF, &quot; &quot;, 1); cursor_x -= 8; &#125; &#125; else &#123; fifo32_put(&amp;task_cons-&gt;fifo, 8 + 256); &#125; &#125; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536void console_task(struct SHEET *sheet)&#123; struct TASK *task = task_now(); int i, fifobuf[128], cursor_x = 16, cursor_c = COL8_000000; fifo32_init(&amp;task-&gt;fifo, 128, fifobuf, task); for (;;) &#123; io_cli(); if (fifo32_status(&amp;task-&gt;fifo) == 0) &#123; task_sleep(task); io_sti(); &#125; else &#123; i = fifo32_get(&amp;task-&gt;fifo); io_sti(); if (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; if (i == 8 + 256) &#123; if (cursor_x &gt; 16) &#123; putfonts8_asc_sht(sheet, cursor_x, 28, COL8_FFFFFF, COL8_000000, &quot; &quot;, 1); cursor_x -= 8; &#125; &#125; else &#123; if (cursor_x &lt; 240) &#123; s[0] = i - 256; s[1] = 0; putfonts8_asc_sht(sheet, cursor_x, 28, COL8_FFFFFF, COL8_000000, s, 1); cursor_x += 8; &#125; &#125; &#125; boxfill8(sheet-&gt;buf, sheet-&gt;bxsize, cursor_c, cursor_x, 28, cursor_x + 7, 43); sheet_refresh(sheet, cursor_x, 28, cursor_x + 8, 44); &#125; &#125;&#125; 符号的输入（harib14e）如果想输入！@ #等符号，必须按下shift键 按键 按下 抬起 左shift 0x2a 0xaa 右shift 0x36 0xb6 左shift按下置为1，右shift按下使置为2，两个都不按时置为0，两个都按下置为3 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354void HariMain(void)&#123; static char keytable0[0x80] = &#123; 0, 0, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;0&apos;, &apos;-&apos;, &apos;^&apos;, 0, 0, &apos;Q&apos;, &apos;W&apos;, &apos;E&apos;, &apos;R&apos;, &apos;T&apos;, &apos;Y&apos;, &apos;U&apos;, &apos;I&apos;, &apos;O&apos;, &apos;P&apos;, &apos;@&apos;, &apos;[&apos;, 0, 0, &apos;A&apos;, &apos;S&apos;, &apos;D&apos;, &apos;F&apos;, &apos;G&apos;, &apos;H&apos;, &apos;J&apos;, &apos;K&apos;, &apos;L&apos;, &apos;;&apos;, &apos;:&apos;, 0, 0, &apos;]&apos;, &apos;Z&apos;, &apos;X&apos;, &apos;C&apos;, &apos;V&apos;, &apos;B&apos;, &apos;N&apos;, &apos;M&apos;, &apos;,&apos;, &apos;.&apos;, &apos;/&apos;, 0, &apos;*&apos;, 0, &apos; &apos;, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;-&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;+&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;0&apos;, &apos;.&apos;, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x5c, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x5c, 0, 0 &#125;; static char keytable1[0x80] = &#123; 0, 0, &apos;!&apos;, 0x22, &apos;#&apos;, &apos;$&apos;, &apos;%&apos;, &apos;&amp;&apos;, 0x27, &apos;(&apos;, &apos;)&apos;, &apos;~&apos;, &apos;=&apos;, &apos;~&apos;, 0, 0, &apos;Q&apos;, &apos;W&apos;, &apos;E&apos;, &apos;R&apos;, &apos;T&apos;, &apos;Y&apos;, &apos;U&apos;, &apos;I&apos;, &apos;O&apos;, &apos;P&apos;, &apos;`&apos;, &apos;&#123;&apos;, 0, 0, &apos;A&apos;, &apos;S&apos;, &apos;D&apos;, &apos;F&apos;, &apos;G&apos;, &apos;H&apos;, &apos;J&apos;, &apos;K&apos;, &apos;L&apos;, &apos;+&apos;, &apos;*&apos;, 0, 0, &apos;&#125;&apos;, &apos;Z&apos;, &apos;X&apos;, &apos;C&apos;, &apos;V&apos;, &apos;B&apos;, &apos;N&apos;, &apos;M&apos;, &apos;&lt;&apos;, &apos;&gt;&apos;, &apos;?&apos;, 0, &apos;*&apos;, 0, &apos; &apos;, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;-&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;+&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;0&apos;, &apos;.&apos;, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, &apos;_&apos;, 0, 0, 0, 0, 0, 0, 0, 0, 0, &apos;|&apos;, 0, 0 &#125;; int key_to = 0, key_shift = 0; for (;;) &#123; if (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; if (i &lt; 0x80 + 256) &#123; if (key_shift == 0) &#123; s[0] = keytable0[i - 256]; &#125; else &#123; s[0] = keytable1[i - 256]; &#125; &#125; else &#123; s[0] = 0; &#125; if (i == 256 + 0x2a) &#123; /* 左shift ON */ key_shift |= 1; &#125; if (i == 256 + 0x36) &#123; /* 右shift ON */ key_shift |= 2; &#125; if (i == 256 + 0xaa) &#123; /* 左shift OFF */ key_shift &amp;= ~1; &#125; if (i == 256 + 0xb6) &#123; /* 右shift OFF */ key_shift &amp;= ~2; &#125; &#125; &#125; &#125; 大写字母与小写字母(harib14f)CapsLock为off &amp; shift键为off 小写字母CapsLock为off &amp; shift键为on 大写字母CapsLock为on &amp; shift键为off 大写字母CapsLock为on &amp; shift键为on 小写字母 binfo-&gt;leds的第四位是ScrollLock状态binfo-&gt;leds的第五位是NumLock状态binfo-&gt;leds的第六位是CapsLock状态 1234567891011121314151617void HariMain(void)&#123; int key_to = 0, key_shift = 0, key_leds = (binfo-&gt;leds &gt;&gt; 4) &amp; 7; for (;;) &#123; if (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; if (&apos;A&apos; &lt;= s[0] &amp;&amp; s[0] &lt;= &apos;Z&apos;) &#123; if (((key_leds &amp; 4) == 0 &amp;&amp; key_shift == 0) || ((key_leds &amp; 4) != 0 &amp;&amp; key_shift != 0)) &#123; s[0] += 0x20; &#125; &#125; &#125; &#125; &#125; 这个状态只是获得初始状态的CapsLock 对各种锁定键的支持（harib14g)对三个按键的切换和指示灯的控制。 CapLock：0x3aNumLock: 0x45ScrollLock: 0x46 对于指示灯的控制，流程如下： 读取状态寄存器，等待bit 1的值变为0项数据输出（0x0060）写入要发送的1个字节数据等待键盘返回一个字节的信息返回的信息如果为0xfa，表明成功；如果为0xfe，需要重新发送 要控制LED的状态，需要按上次方法执行两次，向键盘发送EDXX数据。其中，XX的bit0代表ScrollLock，bit 1代表Numlock，bit 2代表CapsLock（0代表熄灭，1表示点亮）。bit3~7位保留位，置0即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#define KEYCMD_LED 0xedvoid HariMain(void)&#123; fifo32_put(&amp;keycmd, KEYCMD_LED); fifo32_put(&amp;keycmd, key_leds); for (;;) &#123; if (fifo32_status(&amp;keycmd) &gt; 0 &amp;&amp; keycmd_wait &lt; 0) &#123; keycmd_wait = fifo32_get(&amp;keycmd); wait_KBC_sendready(); io_out8(PORT_KEYDAT, keycmd_wait); &#125; io_cli(); if (fifo32_status(&amp;fifo) == 0) &#123; task_sleep(task_a); io_sti(); &#125; else &#123; i = fifo32_get(&amp;fifo); io_sti(); if (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; if (i == 256 + 0x3a) &#123; /* CapsLock */ key_leds ^= 4; fifo32_put(&amp;keycmd, KEYCMD_LED); fifo32_put(&amp;keycmd, key_leds); &#125; if (i == 256 + 0x45) &#123; /* NumLock */ key_leds ^= 2; fifo32_put(&amp;keycmd, KEYCMD_LED); fifo32_put(&amp;keycmd, key_leds); &#125; if (i == 256 + 0x46) &#123; /* ScrollLock */ key_leds ^= 1; fifo32_put(&amp;keycmd, KEYCMD_LED); fifo32_put(&amp;keycmd, key_leds); &#125; if (i == 256 + 0xfa) &#123; keycmd_wait = -1; &#125; if (i == 256 + 0xfe) &#123; wait_KBC_sendready(); io_out8(PORT_KEYDAT, keycmd_wait); &#125; &#125; &#125; &#125;&#125;","tags":[{"name":"30天自制操作系统","slug":"30天自制操作系统","permalink":"http://yoursite.com/tags/30天自制操作系统/"},{"name":"字符输入","slug":"字符输入","permalink":"http://yoursite.com/tags/字符输入/"}]},{"title":"16 自制操作系统第十六天","date":"2018-01-29T16:00:00.000Z","path":"2018/01/30/omake_16/","text":"项目地址 123456主要内容：1. 任务管理自动化（harib13a）2. 让任务休眠（harib13b）3. 增加窗口数量（harib13c)4. 设定任务优先级（1）（harib13d）5. 设定任务优先级（2）（harib13e） 任务管理自动化（harib13a）123456789101112131415161718#define MAX_TASKS 1000 /* 最大任务数量 */#define TASK_GDT0 3 /* 定义从GDT的几号开始分配给TSS */struct TSS32 &#123; int backlink, esp0, ss0, esp1, ss1, esp2, ss2, cr3; int eip, eflags, eax, ecx, edx, ebx, esp, ebp, esi, edi; int es, cs, ss, ds, fs, gs; int ldtr, iomap;&#125;;struct TASK &#123; int sel, flags; /* sel用来存放GDT的编号 */ struct TSS32 tss;&#125;;struct TASKCTL &#123; int running; /* 正在运行的任务数量 */ int now; /* 用来记录当前正在运行的是哪个任务 */ struct TASK *tasks[MAX_TASKS]; struct TASK tasks0[MAX_TASKS];&#125;; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273struct TASKCTL *taskctl;struct TIMER *task_timer;struct TASK *task_init(struct MEMMAN *memman)&#123; int i; struct TASK *task; struct SEGMENT_DESCRIPTOR *gdt = (struct SEGMENT_DESCRIPTOR *) ADR_GDT; taskctl = (struct TASKCTL *) memman_alloc_4k(memman, sizeof (struct TASKCTL)); for (i = 0; i &lt; MAX_TASKS; i++) &#123; taskctl-&gt;tasks0[i].flags = 0; taskctl-&gt;tasks0[i].sel = (TASK_GDT0 + i) * 8; set_segmdesc(gdt + TASK_GDT0 + i, 103, (int) &amp;taskctl-&gt;tasks0[i].tss, AR_TSS32); &#125; task = task_alloc(); task-&gt;flags = 2; /* 活动中标志 */ taskctl-&gt;running = 1; taskctl-&gt;now = 0; taskctl-&gt;tasks[0] = task; load_tr(task-&gt;sel); task_timer = timer_alloc(); timer_settime(task_timer, 2); return task;&#125;struct TASK *task_alloc(void)&#123; int i; struct TASK *task; for (i = 0; i &lt; MAX_TASKS; i++) &#123; if (taskctl-&gt;tasks0[i].flags == 0) &#123; task = &amp;taskctl-&gt;tasks0[i]; task-&gt;flags = 1; /* 正在使用的标志 */ task-&gt;tss.eflags = 0x00000202; /* IF = 1; */ task-&gt;tss.eax = 0; task-&gt;tss.ecx = 0; task-&gt;tss.edx = 0; task-&gt;tss.ebx = 0; task-&gt;tss.ebp = 0; task-&gt;tss.esi = 0; task-&gt;tss.edi = 0; task-&gt;tss.es = 0; task-&gt;tss.ds = 0; task-&gt;tss.fs = 0; task-&gt;tss.gs = 0; task-&gt;tss.ldtr = 0; task-&gt;tss.iomap = 0x40000000; return task; &#125; &#125; return 0; &#125;void task_run(struct TASK *task)&#123; task-&gt;flags = 2; /* 活动中标志 */ taskctl-&gt;tasks[taskctl-&gt;running] = task; taskctl-&gt;running++; return;&#125;void task_switch(void)&#123; timer_settime(task_timer, 2); if (taskctl-&gt;running &gt;= 2) &#123; taskctl-&gt;now++; if (taskctl-&gt;now == taskctl-&gt;running) &#123; taskctl-&gt;now = 0; &#125; farjmp(0, taskctl-&gt;tasks[taskctl-&gt;now]-&gt;sel); &#125; return;&#125; 12345678910111213141516171819void HariMain(void)&#123; struct TASK *task_b; task_init(memman); task_b = task_alloc(); task_b-&gt;tss.esp = memman_alloc_4k(memman, 64 * 1024) + 64 * 1024 - 8; task_b-&gt;tss.eip = (int) &amp;task_b_main; task_b-&gt;tss.es = 1 * 8; task_b-&gt;tss.cs = 2 * 8; task_b-&gt;tss.ss = 1 * 8; task_b-&gt;tss.ds = 1 * 8; task_b-&gt;tss.fs = 1 * 8; task_b-&gt;tss.gs = 1 * 8; *((int *) (task_b-&gt;tss.esp + 4)) = (int) sht_back; task_run(task_b);&#125; 让任务休眠（harib13b）因为任务a大多数是没有在工作状态的，所以在没有接收键盘和鼠标数据的数据的时候，让其休眠。 当有鼠标数据或键盘数据时，再唤起它。 123456789101112131415161718192021222324252627282930313233void task_sleep(struct TASK *task)&#123; int i; char ts = 0; if (task-&gt;flags == 2) &#123; if (task == taskctl-&gt;tasks[taskctl-&gt;now]) &#123; ts = 1; &#125; /* 寻找task所在的位置 */ for (i = 0; i &lt; taskctl-&gt;running; i++) &#123; if (taskctl-&gt;tasks[i] == task) &#123; break; &#125; &#125; taskctl-&gt;running--; if (i &lt; taskctl-&gt;now) &#123; taskctl-&gt;now--; &#125; /* 移动成员 */ for (; i &lt; taskctl-&gt;running; i++) &#123; taskctl-&gt;tasks[i] = taskctl-&gt;tasks[i + 1]; &#125; task-&gt;flags = 1; /* 不工作的状态 */ if (ts != 0) &#123; /* 自己让自己休眠，需要切换任务 */ if (taskctl-&gt;now &gt;= taskctl-&gt;running) &#123; taskctl-&gt;now = 0; &#125; farjmp(0, taskctl-&gt;tasks[taskctl-&gt;now]-&gt;sel); &#125; &#125; return;&#125; 1234567891011121314151617181920212223242526272829303132333435363738struct FIFO32 &#123; int *buf; int p, q, size, free, flags; struct TASK *task;&#125;;void fifo32_init(struct FIFO32 *fifo, int size, int *buf, struct TASK *task)&#123; fifo-&gt;size = size; fifo-&gt;buf = buf; fifo-&gt;free = size; fifo-&gt;flags = 0; fifo-&gt;p = 0; fifo-&gt;q = 0; fifo-&gt;task = task; return;&#125;int fifo32_put(struct FIFO32 *fifo, int data)&#123; if (fifo-&gt;free == 0) &#123; fifo-&gt;flags |= FLAGS_OVERRUN; return -1; &#125; fifo-&gt;buf[fifo-&gt;p] = data; fifo-&gt;p++; if (fifo-&gt;p == fifo-&gt;size) &#123; fifo-&gt;p = 0; &#125; fifo-&gt;free--; if (fifo-&gt;task != 0) &#123; if (fifo-&gt;task-&gt;flags != 2) &#123; task_run(fifo-&gt;task); /* 将任务唤醒 */ &#125; &#125; return 0;&#125; 12345678910111213141516171819202122232425void HariMain(void)&#123; struct TASK *task_a, *task_b; fifo32_init(&amp;fifo, 128, fifobuf, 0); task_a = task_init(memman); fifo.task = task_a; for (;;) &#123; io_cli(); if (fifo32_status(&amp;fifo) == 0) &#123; task_sleep(task_a); io_sti(); &#125; else &#123; &#125; &#125;&#125;void task_b_main(struct SHEET *sht_back)&#123; fifo32_init(&amp;fifo, 128, fifobuf, 0);&#125; 增加窗口数量（harib13c)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142void HariMain(void)&#123; unsigned char *buf_back, buf_mouse[256], *buf_win, *buf_win_b; struct SHEET *sht_back, *sht_mouse, *sht_win, *sht_win_b[3]; struct TASK *task_a, *task_b[3]; struct TIMER *timer; task_a = task_init(memman); fifo.task = task_a; /* sht_back */ sht_back = sheet_alloc(shtctl); buf_back = (unsigned char *) memman_alloc_4k(memman, binfo-&gt;scrnx * binfo-&gt;scrny); sheet_setbuf(sht_back, buf_back, binfo-&gt;scrnx, binfo-&gt;scrny, -1); init_screen8(buf_back, binfo-&gt;scrnx, binfo-&gt;scrny); /* sht_win_b */ for (i = 0; i &lt; 3; i++) &#123; sht_win_b[i] = sheet_alloc(shtctl); buf_win_b = (unsigned char *) memman_alloc_4k(memman, 144 * 52); sheet_setbuf(sht_win_b[i], buf_win_b, 144, 52, -1); sprintf(s, &quot;task_b%d&quot;, i); make_window8(buf_win_b, 144, 52, s, 0); task_b[i] = task_alloc(); task_b[i]-&gt;tss.esp = memman_alloc_4k(memman, 64 * 1024) + 64 * 1024 - 8; task_b[i]-&gt;tss.eip = (int) &amp;task_b_main; task_b[i]-&gt;tss.es = 1 * 8; task_b[i]-&gt;tss.cs = 2 * 8; task_b[i]-&gt;tss.ss = 1 * 8; task_b[i]-&gt;tss.ds = 1 * 8; task_b[i]-&gt;tss.fs = 1 * 8; task_b[i]-&gt;tss.gs = 1 * 8; *((int *) (task_b[i]-&gt;tss.esp + 4)) = (int) sht_win_b[i]; task_run(task_b[i]); &#125; /* sht_win */ sht_win = sheet_alloc(shtctl); buf_win = (unsigned char *) memman_alloc_4k(memman, 160 * 52); sheet_setbuf(sht_win, buf_win, 144, 52, -1); make_window8(buf_win, 144, 52, &quot;task_a&quot;, 1); make_textbox8(sht_win, 8, 28, 128, 16, COL8_FFFFFF); cursor_x = 8; cursor_c = COL8_FFFFFF; timer = timer_alloc(); timer_init(timer, &amp;fifo, 1); timer_settime(timer, 50); /* sht_mouse */ sht_mouse = sheet_alloc(shtctl); sheet_setbuf(sht_mouse, buf_mouse, 16, 16, 99); init_mouse_cursor8(buf_mouse, 99); mx = (binfo-&gt;scrnx - 16) / 2; my = (binfo-&gt;scrny - 28 - 16) / 2; sheet_slide(sht_back, 0, 0); sheet_slide(sht_win_b[0], 168, 56); sheet_slide(sht_win_b[1], 8, 116); sheet_slide(sht_win_b[2], 168, 116); sheet_slide(sht_win, 8, 56); sheet_slide(sht_mouse, mx, my); sheet_updown(sht_back, 0); sheet_updown(sht_win_b[0], 1); sheet_updown(sht_win_b[1], 2); sheet_updown(sht_win_b[2], 3); sheet_updown(sht_win, 4); sheet_updown(sht_mouse, 5); sprintf(s, &quot;(%3d, %3d)&quot;, mx, my); putfonts8_asc_sht(sht_back, 0, 0, COL8_FFFFFF, COL8_008484, s, 10); sprintf(s, &quot;memory %dMB free : %dKB&quot;, memtotal / (1024 * 1024), memman_total(memman) / 1024); putfonts8_asc_sht(sht_back, 0, 32, COL8_FFFFFF, COL8_008484, s, 40); for (;;) &#123; io_cli(); if (fifo32_status(&amp;fifo) == 0) &#123; task_sleep(task_a); io_sti(); &#125; else &#123; i = fifo32_get(&amp;fifo); io_sti(); if (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; &#125; else if (512 &lt;= i &amp;&amp; i &lt;= 767) &#123; &#125; else if (i &lt;= 1) &#123; &#125; &#125; &#125;&#125;void make_window8(unsigned char *buf, int xsize, int ysize, char *title, char act)&#123; char c, tc, tbc; if (act != 0) &#123; /* 标题栏为亮色 */ tc = COL8_FFFFFF; tbc = COL8_000084; &#125; else &#123; /* 标题栏为灰色 */ tc = COL8_C6C6C6; tbc = COL8_848484; &#125; boxfill8(buf, xsize, tbc, 3, 3, xsize - 4, 20 ); putfonts8_asc(buf, xsize, 24, 4, tc, title); for (y = 0; y &lt; 14; y++) &#123; &#125; return;&#125;void task_b_main(struct SHEET *sht_win_b)&#123; struct FIFO32 fifo; struct TIMER *timer_1s; int i, fifobuf[128], count = 0, count0 = 0; char s[12]; fifo32_init(&amp;fifo, 128, fifobuf, 0); timer_1s = timer_alloc(); timer_init(timer_1s, &amp;fifo, 100); timer_settime(timer_1s, 100); for (;;) &#123; count++; io_cli(); if (fifo32_status(&amp;fifo) == 0) &#123; io_sti(); &#125; else &#123; i = fifo32_get(&amp;fifo); io_sti(); if (i == 100) &#123; sprintf(s, &quot;%11d&quot;, count - count0); putfonts8_asc_sht(sht_win_b, 24, 28, COL8_000000, COL8_C6C6C6, s, 11); count0 = count; timer_settime(timer_1s, 100); &#125; &#125; &#125;&#125; 设定任务优先级（1）（harib13d）12345struct TASK &#123; int sel, flags; int priority; struct TSS32 tss;&#125;; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152struct TASK *task_init(struct MEMMAN *memman)&#123; int i; struct TASK *task; struct SEGMENT_DESCRIPTOR *gdt = (struct SEGMENT_DESCRIPTOR *) ADR_GDT; taskctl = (struct TASKCTL *) memman_alloc_4k(memman, sizeof (struct TASKCTL)); for (i = 0; i &lt; MAX_TASKS; i++) &#123; taskctl-&gt;tasks0[i].flags = 0; taskctl-&gt;tasks0[i].sel = (TASK_GDT0 + i) * 8; set_segmdesc(gdt + TASK_GDT0 + i, 103, (int) &amp;taskctl-&gt;tasks0[i].tss, AR_TSS32); &#125; task = task_alloc(); task-&gt;flags = 2; task-&gt;priority = 2; /* 0.02秒 */ taskctl-&gt;running = 1; taskctl-&gt;now = 0; taskctl-&gt;tasks[0] = task; load_tr(task-&gt;sel); task_timer = timer_alloc(); timer_settime(task_timer, task-&gt;priority); return task;&#125;void task_run(struct TASK *task, int priority)&#123; if (priority &gt; 0) &#123; task-&gt;priority = priority; &#125; if (task-&gt;flags != 2) &#123; task-&gt;flags = 2; taskctl-&gt;tasks[taskctl-&gt;running] = task; taskctl-&gt;running++; &#125; return;&#125;void task_switch(void)&#123; struct TASK *task; taskctl-&gt;now++; if (taskctl-&gt;now == taskctl-&gt;running) &#123; taskctl-&gt;now = 0; &#125; task = taskctl-&gt;tasks[taskctl-&gt;now]; timer_settime(task_timer, task-&gt;priority); if (taskctl-&gt;running &gt;= 2) &#123; farjmp(0, task-&gt;sel); &#125; return;&#125; 12345678910111213141516171819202122int fifo32_put(struct FIFO32 *fifo, int data)/* FIFO傊僨乕僞傪憲傝崬傫偱拁偊傞 */&#123; if (fifo-&gt;free == 0) &#123; /* 嬻偒偑側偔偰偁傆傟偨 */ fifo-&gt;flags |= FLAGS_OVERRUN; return -1; &#125; fifo-&gt;buf[fifo-&gt;p] = data; fifo-&gt;p++; if (fifo-&gt;p == fifo-&gt;size) &#123; fifo-&gt;p = 0; &#125; fifo-&gt;free--; if (fifo-&gt;task != 0) &#123; if (fifo-&gt;task-&gt;flags != 2) &#123; task_run(fifo-&gt;task, 0); &#125; &#125; return 0;&#125; 1234567void HariMain(void)&#123; /* sht_win_b */ for (i = 0; i &lt; 3; i++) &#123; task_run(task_b[i], i + 1); &#125;&#125; 设定任务优先级（2）（harib13e） 最上层的任务只要存在哪怕一个任务，则完全忽略level 1和level 2中的任务，只在level 0的任务中进行任务切换。 12345678910111213141516171819#define MAX_TASKS_LV 100#define MAX_TASKLEVELS 10struct TASK &#123; int sel, flags; int level, priority; struct TSS32 tss;&#125;;struct TASKLEVEL &#123; int running; /* 正在运行的任务数量 */ int now; /* 当前正在运行的任务 */ struct TASK *tasks[MAX_TASKS_LV];&#125;;struct TASKCTL &#123; int now_lv; /* 现在活动中的level */ char lv_change; /* 下次任务切换时是否需要改变level */ struct TASKLEVEL level[MAX_TASKLEVELS]; struct TASK tasks0[MAX_TASKS];&#125;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135struct TASK *task_now(void)&#123; struct TASKLEVEL *tl = &amp;taskctl-&gt;level[taskctl-&gt;now_lv]; return tl-&gt;tasks[tl-&gt;now];&#125;void task_add(struct TASK *task)&#123; struct TASKLEVEL *tl = &amp;taskctl-&gt;level[task-&gt;level]; tl-&gt;tasks[tl-&gt;running] = task; tl-&gt;running++; task-&gt;flags = 2; return;&#125;void task_remove(struct TASK *task)&#123; int i; struct TASKLEVEL *tl = &amp;taskctl-&gt;level[task-&gt;level]; for (i = 0; i &lt; tl-&gt;running; i++) &#123; if (tl-&gt;tasks[i] == task) &#123; break; &#125; &#125; tl-&gt;running--; if (i &lt; tl-&gt;now) &#123; tl-&gt;now--; &#125; if (tl-&gt;now &gt;= tl-&gt;running) &#123; tl-&gt;now = 0; &#125; task-&gt;flags = 1; for (; i &lt; tl-&gt;running; i++) &#123; tl-&gt;tasks[i] = tl-&gt;tasks[i + 1]; &#125; return;&#125;/* 用来任务切换时决定接下来切换到哪个level */void task_switchsub(void)&#123; int i; for (i = 0; i &lt; MAX_TASKLEVELS; i++) &#123; if (taskctl-&gt;level[i].running &gt; 0) &#123; break; &#125; &#125; taskctl-&gt;now_lv = i; taskctl-&gt;lv_change = 0; return;&#125;struct TASK *task_init(struct MEMMAN *memman)&#123; for (i = 0; i &lt; MAX_TASKLEVELS; i++) &#123; taskctl-&gt;level[i].running = 0; taskctl-&gt;level[i].now = 0; &#125; task = task_alloc(); task-&gt;flags = 2; task-&gt;priority = 2; /* 0.02昩 */ task-&gt;level = 0; task_add(task); task_switchsub(); load_tr(task-&gt;sel); task_timer = timer_alloc(); timer_settime(task_timer, task-&gt;priority); return task;&#125;void task_run(struct TASK *task, int level, int priority)&#123; if (level &lt; 0) &#123; level = task-&gt;level; &#125; if (priority &gt; 0) &#123; task-&gt;priority = priority; &#125; if (task-&gt;flags == 2 &amp;&amp; task-&gt;level != level) &#123; task_remove(task); &#125; if (task-&gt;flags != 2) &#123; task-&gt;level = level; task_add(task); &#125; taskctl-&gt;lv_change = 1; return;&#125;void task_sleep(struct TASK *task)&#123; struct TASK *now_task; if (task-&gt;flags == 2) &#123; now_task = task_now(); task_remove(task); if (task == now_task) &#123; task_switchsub(); now_task = task_now(); farjmp(0, now_task-&gt;sel); &#125; &#125; return;&#125;void task_switch(void)&#123; struct TASKLEVEL *tl = &amp;taskctl-&gt;level[taskctl-&gt;now_lv]; struct TASK *new_task, *now_task = tl-&gt;tasks[tl-&gt;now]; tl-&gt;now++; if (tl-&gt;now == tl-&gt;running) &#123; tl-&gt;now = 0; &#125; if (taskctl-&gt;lv_change != 0) &#123; task_switchsub(); tl = &amp;taskctl-&gt;level[taskctl-&gt;now_lv]; &#125; new_task = tl-&gt;tasks[tl-&gt;now]; timer_settime(task_timer, new_task-&gt;priority); if (new_task != now_task) &#123; farjmp(0, new_task-&gt;sel); &#125; return;&#125; 12345678910int fifo32_put(struct FIFO32 *fifo, int data)&#123; if (fifo-&gt;task != 0) &#123; if (fifo-&gt;task-&gt;flags != 2) &#123; task_run(fifo-&gt;task, -1, 0); &#125; &#125; return 0;&#125; 12345678910void HariMain(void)&#123; task_a = task_init(memman); fifo.task = task_a; task_run(task_a, 1, 2); for (i = 0; i &lt; 3; i++) &#123; task_run(task_b[i], 2, i + 1); &#125;&#125;","tags":[{"name":"30天自制操作系统","slug":"30天自制操作系统","permalink":"http://yoursite.com/tags/30天自制操作系统/"},{"name":"任务管理自动化","slug":"任务管理自动化","permalink":"http://yoursite.com/tags/任务管理自动化/"},{"name":"任务优先级","slug":"任务优先级","permalink":"http://yoursite.com/tags/任务优先级/"}]},{"title":"15 自制操作系统第十五天","date":"2018-01-24T16:00:00.000Z","path":"2018/01/25/omake_15/","text":"项目地址 1234567主要内容：1. 任务切换（harib12a）2. 任务切换进阶（harib12b）3. 简单的多任务（1）（harib12c)4. 简单的多任务（2）（harib12d）5. 提高运行速度（harib12e）6. 多任务进阶（harib12g） 任务切换（harib012a）123456struct TSS32 &#123; int backlink, esp0, ss0, esp1, ss1, esp2, ss2, cr3; int eip, eflags, eax, ecx, edx, ebx, esp, ebp, esi, edi; int es, cs, ss, ds, fs, gs; int ldtr, iomap;&#125;; 第一行保存的是与任务设置相关的信息。第二行的成员是32位寄存器第三行保存的是16位寄存器暂时将ldtr设置为0，iomap设置为0x40000000 eip的全称是“extended instruction pointer”，也就是“扩展指令指针寄存器”的意思。是CPU用来记录下一条需要执行的指令位于内存中哪个地址的寄存器。其实，JMP 0x1234这种写法，CPU会解释成MOV EIP, 0x1234。 1234567_load_tr: ; void load_tr(int tr); LTR [ESP+4] ; tr RET_taskswitch4: ; void taskswitch4(void); JMP 4*8:0 RET 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667struct TSS32 &#123; int backlink, esp0, ss0, esp1, ss1, esp2, ss2, cr3; int eip, eflags, eax, ecx, edx, ebx, esp, ebp, esi, edi; int es, cs, ss, ds, fs, gs; int ldtr, iomap;&#125;;void HariMain(void)&#123; struct TSS32 tss_a, tss_b; struct SEGMENT_DESCRIPTOR *gdt = (struct SEGMENT_DESCRIPTOR *) ADR_GDT; tss_a.ldtr = 0; tss_a.iomap = 0x40000000; tss_b.ldtr = 0; tss_b.iomap = 0x40000000; set_segmdesc(gdt + 3, 103, (int) &amp;tss_a, AR_TSS32); set_segmdesc(gdt + 4, 103, (int) &amp;tss_b, AR_TSS32); load_tr(3 * 8); task_b_esp = memman_alloc_4k(memman, 64 * 1024) + 64 * 1024; tss_b.eip = (int) &amp;task_b_main; tss_b.eflags = 0x00000202; /* IF = 1; */ tss_b.eax = 0; tss_b.ecx = 0; tss_b.edx = 0; tss_b.ebx = 0; tss_b.esp = task_b_esp; tss_b.ebp = 0; tss_b.esi = 0; tss_b.edi = 0; tss_b.es = 1 * 8; tss_b.cs = 2 * 8; tss_b.ss = 1 * 8; tss_b.ds = 1 * 8; tss_b.fs = 1 * 8; tss_b.gs = 1 * 8; for (;;) &#123; io_cli(); if (fifo32_status(&amp;fifo) == 0) &#123; io_stihlt(); &#125; else &#123; i = fifo32_get(&amp;fifo); io_sti(); if (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; &#125; else if (512 &lt;= i &amp;&amp; i &lt;= 767) &#123; &#125; else if (i == 10) &#123; putfonts8_asc_sht(sht_back, 0, 64, COL8_FFFFFF, COL8_008484, &quot;10[sec]&quot;, 7); taskswitch4(); &#125; else if (i == 3) &#123; &#125; else if (i &lt;= 1) &#123; &#125; &#125; &#125;&#125;void task_b_main(void)&#123; for (;;) &#123; io_hlt(); &#125;&#125; 上述代码是，执行10秒之后，调用taskb。 load_tr(3 * 8);它的作用是让CPU记住当前正在运行哪个任务。赋值的时候，必须把段号乘以8。 要进行任务切换，必须执行far模式的跳转指令，加上段号，也就是上述的taskswitch4。 给cs置为GDT的2号，其他寄存器置为GDT的1号，也就是试用了和bootpack.c相同的地址段。 eip是任务执行的开始地址。 esp是专门位任务B所定义的栈，因为是从栈底开始存数据的，所以会加上64*1024。 任务切换进阶（harib012b）执行任务b后5秒之后，再次调用任务a。 123_taskswitch3: ; void taskswitch3(void); JMP 3*8:0 RET 12345678910111213141516171819202122232425void task_b_main(void)&#123; struct FIFO32 fifo; struct TIMER *timer; int i, fifobuf[128]; fifo32_init(&amp;fifo, 128, fifobuf); timer = timer_alloc(); timer_init(timer, &amp;fifo, 1); timer_settime(timer, 500); for (;;) &#123; io_cli(); if (fifo32_status(&amp;fifo) == 0) &#123; io_sti(); io_hlt(); &#125; else &#123; i = fifo32_get(&amp;fifo); io_sti(); if (i == 1) &#123; taskswitch3(); &#125; &#125; &#125;&#125; 简单的多任务（1）（harib12c)123_farjmp: ; void farjmp(int eip, int cs); JMP FAR [ESP+4] ; eip, cs RET taskswitch3(); 相当于farjmp(0, 3 * 8); 下面的程序是，任务a和任务b每隔0.02秒切换一次。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859void HariMain(void)&#123; timer_ts = timer_alloc(); timer_init(timer_ts, &amp;fifo, 2); timer_settime(timer_ts, 2); for (;;) &#123; io_cli(); if (fifo32_status(&amp;fifo) == 0) &#123; io_stihlt(); &#125; else &#123; i = fifo32_get(&amp;fifo); io_sti(); if (i == 2) &#123; farjmp(0, 4 * 8); timer_settime(timer_ts, 2); &#125; else if (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; &#125; else if (512 &lt;= i &amp;&amp; i &lt;= 767) &#123; &#125; else if (i == 10) &#123; &#125; else if (i == 3) &#123; &#125; else if (i &lt;= 1) &#123; &#125; &#125; &#125;&#125;void task_b_main(void)&#123; struct FIFO32 fifo; struct TIMER *timer_ts; int i, fifobuf[128]; fifo32_init(&amp;fifo, 128, fifobuf); timer_ts = timer_alloc(); timer_init(timer_ts, &amp;fifo, 1); timer_settime(timer_ts, 2); for (;;) &#123; io_cli(); if (fifo32_status(&amp;fifo) == 0) &#123; io_sti(); io_hlt(); &#125; else &#123; i = fifo32_get(&amp;fifo); io_sti(); if (i == 1) &#123; farjmp(0, 3 * 8); timer_settime(timer_ts, 2); &#125; &#125; &#125;&#125; 简单的多任务（2）（harib12d）让任务b在窗口上显示点东西。 123456789101112131415161718192021222324252627282930313233343536void HariMain(void)&#123; *((int *) 0x0fec) = (int) sht_back;&#125;void task_b_main(void)&#123; struct FIFO32 fifo; struct TIMER *timer_ts; int i, fifobuf[128], count = 0; char s[11]; struct SHEET *sht_back; fifo32_init(&amp;fifo, 128, fifobuf); timer_ts = timer_alloc(); timer_init(timer_ts, &amp;fifo, 1); timer_settime(timer_ts, 2); sht_back = (struct SHEET *) *((int *) 0x0fec); for (;;) &#123; count++; sprintf(s, &quot;%10d&quot;, count); putfonts8_asc_sht(sht_back, 0, 144, COL8_FFFFFF, COL8_008484, s, 10); io_cli(); if (fifo32_status(&amp;fifo) == 0) &#123; io_sti(); &#125; else &#123; i = fifo32_get(&amp;fifo); io_sti(); if (i == 1) &#123; farjmp(0, 3 * 8); timer_settime(timer_ts, 2); &#125; &#125; &#125;&#125; 提高运行速度（harib12e）从每计一个数显示一次，变成每0.01秒刷新一次。 12345678910111213141516171819202122232425262728293031323334353637383940void HariMain(void)&#123; task_b_esp = memman_alloc_4k(memman, 64 * 1024) + 64 * 1024 - 8; *((int *) (task_b_esp + 4)) = (int) sht_back;&#125;void task_b_main(struct SHEET *sht_back)&#123; struct FIFO32 fifo; struct TIMER *timer_ts, *timer_put; int i, fifobuf[128], count = 0; char s[12]; fifo32_init(&amp;fifo, 128, fifobuf); timer_ts = timer_alloc(); timer_init(timer_ts, &amp;fifo, 2); timer_settime(timer_ts, 2); timer_put = timer_alloc(); timer_init(timer_put, &amp;fifo, 1); timer_settime(timer_put, 1); for (;;) &#123; count++; io_cli(); if (fifo32_status(&amp;fifo) == 0) &#123; io_sti(); &#125; else &#123; i = fifo32_get(&amp;fifo); io_sti(); if (i == 1) &#123; sprintf(s, &quot;%11d&quot;, count); putfonts8_asc_sht(sht_back, 0, 144, COL8_FFFFFF, COL8_008484, s, 11); timer_settime(timer_put, 1); &#125; else if (i == 2) &#123; farjmp(0, 3 * 8); timer_settime(timer_ts, 2); &#125; &#125; &#125;&#125; load_tr(123);这样的调用，如果从汇编语言的角度来看的话，参数指定的数值就放在内存中，地址为ESP+4。task_b_esp = memman_alloc_4k(memman, 64 1024) + 64 1024 - 8;((int ) (task_b_esp + 4)) = (int) sht_back;这样一来，在任务b启动的时候，[ESP+4]这个地址里面就已经存入了sht_back的值。 多任务进阶（harib12g）真正的任务，是要做到程序本身不知道的情况下进行任务切换。 12345678910111213141516171819202122232425mtask.c文件struct TIMER *mt_timer;int mt_tr;void mt_init(void)&#123; mt_timer = timer_alloc(); /* 因为不需要往缓冲区写数据，所以不需要timer_init */ timer_settime(mt_timer, 2); mt_tr = 3 * 8; return;&#125;void mt_taskswitch(void)&#123; if (mt_tr == 3 * 8) &#123; mt_tr = 4 * 8; &#125; else &#123; mt_tr = 3 * 8; &#125; timer_settime(mt_timer, 2); farjmp(0, mt_tr); return;&#125; 12345678910111213141516171819202122232425262728293031timer.c 文件void inthandler20(int *esp)&#123; struct TIMER *timer; char ts = 0; io_out8(PIC0_OCW2, 0x60); timerctl.count++; if (timerctl.next &gt; timerctl.count) &#123; return; &#125; timer = timerctl.t0; for (;;) &#123; if (timer-&gt;timeout &gt; timerctl.count) &#123; break; &#125; timer-&gt;flags = TIMER_FLAGS_ALLOC; if (timer != mt_timer) &#123; fifo32_put(timer-&gt;fifo, timer-&gt;data); &#125; else &#123; ts = 1; &#125; timer = timer-&gt;next; &#125; timerctl.t0 = timer; timerctl.next = timer-&gt;timeout; if (ts != 0) &#123; mt_taskswitch(); &#125; return;&#125; 然后把HariMain和task_b_main里面有关任务切换的代码删掉。","tags":[{"name":"30天自制操作系统","slug":"30天自制操作系统","permalink":"http://yoursite.com/tags/30天自制操作系统/"},{"name":"任务切换","slug":"任务切换","permalink":"http://yoursite.com/tags/任务切换/"},{"name":"多任务","slug":"多任务","permalink":"http://yoursite.com/tags/多任务/"}]},{"title":"14 自制操作系统第十四天","date":"2018-01-23T16:00:00.000Z","path":"2018/01/24/omake_14/","text":"项目地址 1234567主要内容：1. 提高分辨率（1）（harib11d）2. 提高分辨率（2）（harib11e）3. 键盘输入（1）（harib11f)4. 键盘输入（2）（harib11g）5. 追加内容（1）（harib11h）6. 窗口瞬间移动（harib11i） 提高分辨率（1）（harib011d）12345678910asmhead.nas文件 MOV BX,0x4101 ; VBE的640×480×8bit彩色 MOV AX,0x4f02 INT 0x10 MOV BYTE [VMODE],8 MOV WORD [SCRNX],640 MOV WORD [SCRNY],480 MOV DWORD [VRAM],0xe0000000 给AX赋值0x4f02，给BX赋值画面模式号码，这样就可以切换到高分辨率画面模式了。 VBE的画面模式如下：0x101 640×480×8bit彩色0x103 800×600×8bit彩色0x105 1024×768×8bit彩色0x107 1280×1024×8bit彩色 如果想要成功显示，必须将画面模式的号码加上0x4000，再赋值到BX中。 提高分辨率（2）（harib011e）有的机器上可能显示不出高分辨率的，所以需要判断一下。 123456789; 确认VBE是否存在 MOV AX,0x9000 MOV ES,AX MOV DI,0 MOV AX,0x4f00 INT 0x10 CMP AX,0x004f JNE scrn320 给ES赋值为0x9000，给DI赋值为0，给AX赋值为0x4f00，再执行“INT 0x10”。如果有VBE的话，AX就会变为0x004f。要是AX没有变成这个值，就只能使用320×200的画面了。 12345; 检查VBE的版本 MOV AX,[ES:DI+4] CMP AX,0x0200 JB scrn320 ; if (AX &lt; 0x0200) goto scrn320 如果VBE的版本不是2.0以上的，就不能使用高分辨率。 123456789VBEMODE EQU 0x105; 取得画面模式信息 MOV CX,VBEMODE MOV AX,0x4f01 INT 0x10 CMP AX,0x004f JNE scrn320 如果AX是0x004f以外的值，就意味着所指定的画面模式不能使用。此次取得的画面模式信息也被写入内存中从ES:DI开始的256字节中。 模式信息中，重要的信息有如下6个：WORD [ES:DI+0x00]: 模式属性（bit7不是1就不行）WORD [ES:DI+0x12]: x的分辨率WORD [ES:DI+0x14]: y的分辨率WORD [ES:DI+0x19]: 颜色数（必须为8）WORD [ES:DI+0x1b]: 颜色的指定方法（必须是4，4是调色板模式）WORD [ES:DI+0x28]: VRAM的地址 123456789; 画面模式信息的确认 CMP BYTE [ES:DI+0x19],8 JNE scrn320 CMP BYTE [ES:DI+0x1b],4 JNE scrn320 MOV AX,[ES:DI+0x00] AND AX,0x0080 JZ scrn320 12345678910111213; 画面模式的切换 MOV BX,VBEMODE+0x4000 MOV AX,0x4f02 INT 0x10 MOV BYTE [VMODE],8 MOV AX,[ES:DI+0x12] MOV [SCRNX],AX MOV AX,[ES:DI+0x14] MOV [SCRNY],AX MOV EAX,[ES:DI+0x28] MOV [VRAM],EAX JMP keystatus 12345678scrn320: MOV AL,0x13 MOV AH,0x00 INT 0x10 MOV BYTE [VMODE],8 MOV WORD [SCRNX],320 MOV WORD [SCRNY],200 MOV DWORD [VRAM],0x000a0000 键盘输入（1）（harib11f) 按下A键的时候，应该显示“1E”，弹起的的时候应该显示“9E” 123456789101112131415161718192021222324252627282930313233343536void HariMain(void)&#123; for (;;) &#123; io_cli(); if (fifo32_status(&amp;fifo) == 0) &#123; io_stihlt(); &#125; else &#123; i = fifo32_get(&amp;fifo); io_sti(); if (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; /* 键盘数据 */ sprintf(s, &quot;%02X&quot;, i - 256); putfonts8_asc_sht(sht_back, 0, 16, COL8_FFFFFF, COL8_008484, s, 2); if (i == 0x1e + 256) &#123; putfonts8_asc_sht(sht_win, 40, 28, COL8_000000, COL8_C6C6C6, &quot;A&quot;, 1); &#125; &#125; else if (512 &lt;= i &amp;&amp; i &lt;= 767) &#123; /* 鼠标数据 */ &#125; else if (i == 10) &#123; /* 10秒定时器 */ putfonts8_asc_sht(sht_back, 0, 64, COL8_FFFFFF, COL8_008484, &quot;10[sec]&quot;, 7); &#125; else if (i == 3) &#123; /* 3秒定时器 */ putfonts8_asc_sht(sht_back, 0, 80, COL8_FFFFFF, COL8_008484, &quot;3[sec]&quot;, 6); &#125; else if (i == 1) &#123; /* 光标定时器 */ timer_init(timer3, &amp;fifo, 0); boxfill8(buf_back, binfo-&gt;scrnx, COL8_FFFFFF, 8, 96, 15, 111); timer_settime(timer3, 50); sheet_refresh(sht_back, 8, 96, 16, 112); &#125; else if (i == 0) &#123; /* 光标定时器 */ timer_init(timer3, &amp;fifo, 1); boxfill8(buf_back, binfo-&gt;scrnx, COL8_008484, 8, 96, 15, 111); timer_settime(timer3, 50); sheet_refresh(sht_back, 8, 96, 16, 112); &#125; &#125; &#125;&#125; 键盘输入（2）（harib11g)12345678910111213141516171819202122232425262728293031323334353637383940414243void HariMain(void)&#123; static char keytable[0x54] = &#123; 0, 0, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;0&apos;, &apos;-&apos;, &apos;^&apos;, 0, 0, &apos;Q&apos;, &apos;W&apos;, &apos;E&apos;, &apos;R&apos;, &apos;T&apos;, &apos;Y&apos;, &apos;U&apos;, &apos;I&apos;, &apos;O&apos;, &apos;P&apos;, &apos;@&apos;, &apos;[&apos;, 0, 0, &apos;A&apos;, &apos;S&apos;, &apos;D&apos;, &apos;F&apos;, &apos;G&apos;, &apos;H&apos;, &apos;J&apos;, &apos;K&apos;, &apos;L&apos;, &apos;;&apos;, &apos;:&apos;, 0, 0, &apos;]&apos;, &apos;Z&apos;, &apos;X&apos;, &apos;C&apos;, &apos;V&apos;, &apos;B&apos;, &apos;N&apos;, &apos;M&apos;, &apos;,&apos;, &apos;.&apos;, &apos;/&apos;, 0, &apos;*&apos;, 0, &apos; &apos;, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;-&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;+&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;0&apos;, &apos;.&apos; &#125;; for (;;) &#123; io_cli(); if (fifo32_status(&amp;fifo) == 0) &#123; io_stihlt(); &#125; else &#123; i = fifo32_get(&amp;fifo); io_sti(); if (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; /* 键盘数据 */ sprintf(s, &quot;%02X&quot;, i - 256); putfonts8_asc_sht(sht_back, 0, 16, COL8_FFFFFF, COL8_008484, s, 2); if (i &lt; 256 + 0x54) &#123; if (keytable[i - 256] != 0) &#123; s[0] = keytable[i - 256]; s[1] = 0; putfonts8_asc_sht(sht_win, 40, 28, COL8_000000, COL8_C6C6C6, s, 1); &#125; &#125; &#125; else if (512 &lt;= i &amp;&amp; i &lt;= 767) &#123; /* 鼠标数据 */ &#125; else if (i == 10) &#123; /* 10秒定时器 */ &#125; else if (i == 3) &#123; /* 3秒定时器 */ &#125; else if (i == 1) &#123; /* 光标定时器 */ &#125; else if (i == 0) &#123; /* 光标定时器 */ &#125; &#125; &#125;&#125; 追加内容（1）（harib11h）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970void HariMain(void)&#123; int cursor_x, cursor_c; make_textbox8(sht_win, 8, 28, 144, 16, COL8_FFFFFF); cursor_x = 8; cursor_c = COL8_FFFFFF; for (;;) &#123; io_cli(); if (fifo32_status(&amp;fifo) == 0) &#123; io_stihlt(); &#125; else &#123; i = fifo32_get(&amp;fifo); io_sti(); if (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; /* 键盘数据 */ sprintf(s, &quot;%02X&quot;, i - 256); putfonts8_asc_sht(sht_back, 0, 16, COL8_FFFFFF, COL8_008484, s, 2); if (i &lt; 0x54 + 256) &#123; if (keytable[i - 256] != 0 &amp;&amp; cursor_x &lt; 144) &#123; s[0] = keytable[i - 256]; s[1] = 0; putfonts8_asc_sht(sht_win, cursor_x, 28, COL8_000000, COL8_FFFFFF, s, 1); cursor_x += 8; &#125; &#125; if (i == 256 + 0x0e &amp;&amp; cursor_x &gt; 8) &#123; putfonts8_asc_sht(sht_win, cursor_x, 28, COL8_000000, COL8_FFFFFF, &quot; &quot;, 1); cursor_x -= 8; &#125; boxfill8(sht_win-&gt;buf, sht_win-&gt;bxsize, cursor_c, cursor_x, 28, cursor_x + 7, 43); sheet_refresh(sht_win, cursor_x, 28, cursor_x + 8, 44); &#125; else if (512 &lt;= i &amp;&amp; i &lt;= 767) &#123; /* 鼠标数据 */ &#125; else if (i == 10) &#123; /* 10秒定时器 */ &#125; else if (i == 3) &#123; /* 3秒定时器 */ &#125; else if (i &lt;= 1) &#123; /* 光标定时器 */ if (i != 0) &#123; timer_init(timer3, &amp;fifo, 0); cursor_c = COL8_000000; &#125; else &#123; timer_init(timer3, &amp;fifo, 1); cursor_c = COL8_FFFFFF; &#125; timer_settime(timer3, 50); boxfill8(sht_win-&gt;buf, sht_win-&gt;bxsize, cursor_c, cursor_x, 28, cursor_x + 7, 43); sheet_refresh(sht_win, cursor_x, 28, cursor_x + 8, 44); &#125; &#125; &#125;&#125;void make_textbox8(struct SHEET *sht, int x0, int y0, int sx, int sy, int c)&#123; int x1 = x0 + sx, y1 = y0 + sy; boxfill8(sht-&gt;buf, sht-&gt;bxsize, COL8_848484, x0 - 2, y0 - 3, x1 + 1, y0 - 3); boxfill8(sht-&gt;buf, sht-&gt;bxsize, COL8_848484, x0 - 3, y0 - 3, x0 - 3, y1 + 1); boxfill8(sht-&gt;buf, sht-&gt;bxsize, COL8_FFFFFF, x0 - 3, y1 + 2, x1 + 1, y1 + 2); boxfill8(sht-&gt;buf, sht-&gt;bxsize, COL8_FFFFFF, x1 + 2, y0 - 3, x1 + 2, y1 + 2); boxfill8(sht-&gt;buf, sht-&gt;bxsize, COL8_000000, x0 - 1, y0 - 2, x1 + 0, y0 - 2); boxfill8(sht-&gt;buf, sht-&gt;bxsize, COL8_000000, x0 - 2, y0 - 2, x0 - 2, y1 + 0); boxfill8(sht-&gt;buf, sht-&gt;bxsize, COL8_C6C6C6, x0 - 2, y1 + 1, x1 + 0, y1 + 1); boxfill8(sht-&gt;buf, sht-&gt;bxsize, COL8_C6C6C6, x1 + 1, y0 - 2, x1 + 1, y1 + 1); boxfill8(sht-&gt;buf, sht-&gt;bxsize, c, x0 - 1, y0 - 1, x1 + 0, y1 + 0); return;&#125; 窗口瞬间移动（harib11i）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162void HariMain(void)&#123; int cursor_x, cursor_c; make_textbox8(sht_win, 8, 28, 144, 16, COL8_FFFFFF); cursor_x = 8; cursor_c = COL8_FFFFFF; for (;;) &#123; io_cli(); if (fifo32_status(&amp;fifo) == 0) &#123; io_stihlt(); &#125; else &#123; i = fifo32_get(&amp;fifo); io_sti(); if (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; /* 键盘数据 */ &#125; else if (512 &lt;= i &amp;&amp; i &lt;= 767) &#123; /* 鼠标数据 */ if (mouse_decode(&amp;mdec, i - 512) != 0) &#123; sprintf(s, &quot;[lcr %4d %4d]&quot;, mdec.x, mdec.y); if ((mdec.btn &amp; 0x01) != 0) &#123; s[1] = &apos;L&apos;; &#125; if ((mdec.btn &amp; 0x02) != 0) &#123; s[3] = &apos;R&apos;; &#125; if ((mdec.btn &amp; 0x04) != 0) &#123; s[2] = &apos;C&apos;; &#125; putfonts8_asc_sht(sht_back, 32, 16, COL8_FFFFFF, COL8_008484, s, 15); mx += mdec.x; my += mdec.y; if (mx &lt; 0) &#123; mx = 0; &#125; if (my &lt; 0) &#123; my = 0; &#125; if (mx &gt; binfo-&gt;scrnx - 1) &#123; mx = binfo-&gt;scrnx - 1; &#125; if (my &gt; binfo-&gt;scrny - 1) &#123; my = binfo-&gt;scrny - 1; &#125; sprintf(s, &quot;(%3d, %3d)&quot;, mx, my); putfonts8_asc_sht(sht_back, 0, 0, COL8_FFFFFF, COL8_008484, s, 10); sheet_slide(sht_mouse, mx, my); if ((mdec.btn &amp; 0x01) != 0) &#123; sheet_slide(sht_win, mx - 80, my - 8); &#125; &#125; &#125; else if (i == 10) &#123; /* 10秒定时器 */ &#125; else if (i == 3) &#123; /* 3秒定时器 */ &#125; else if (i &lt;= 1) &#123; /* 光标定时器 */ &#125; &#125; &#125;&#125; 只是窗口的瞬间移动，不是拖动。","tags":[{"name":"30天自制操作系统","slug":"30天自制操作系统","permalink":"http://yoursite.com/tags/30天自制操作系统/"},{"name":"提高分辨率","slug":"提高分辨率","permalink":"http://yoursite.com/tags/提高分辨率/"},{"name":"键盘输入","slug":"键盘输入","permalink":"http://yoursite.com/tags/键盘输入/"}]},{"title":"13 自制操作系统第十三天","date":"2018-01-22T16:00:00.000Z","path":"2018/01/23/omake_13/","text":"项目地址 123456主要内容：1. 简化字符串显示（harib10a）2. 调整FIFO缓冲区（1）（harib10b）3. 调整FIFO缓冲区（2）（harib10g）4. 加快中断处理（4）（harib10h）5. 使用“哨兵”简化程序（harib10i） 简化字符串显示（harib010a）12345678910111213boxfill8(buf_win, 160, COL8_C6C6C6, 40, 28, 119, 43);putfonts8_asc(buf_win, 160, 40, 28, COL8_000000, s);sheet_refresh(sht_win, 40, 28, 120, 44);总结成一个函数void putfonts8_asc_sht(struct SHEET *sht, int x, int y, int c, int b, char *s, int l)&#123; boxfill8(sht-&gt;buf, sht-&gt;bxsize, b, x, y, x + l * 8 - 1, y + 15); putfonts8_asc(sht-&gt;buf, sht-&gt;bxsize, x, y, c, s); sheet_refresh(sht, x, y, x + l * 8, y + 16); return;&#125; x，y表示位置的坐标c表示字符的颜色b表示背景颜色s表示字符串l表示字符串长度 调整FIFO缓冲区（1）（harib010b）把timer的fifo缓冲区整合到一个里面，用数据来区分定时器。 12345678910111213141516171819202122232425262728293031323334353637383940414243void HariMain(void)&#123; char s[40], keybuf[32], mousebuf[128], timerbuf[8]; fifo8_init(&amp;timerfifo, 8, timerbuf); timer = timer_alloc(); timer_init(timer, &amp;timerfifo, 10); timer_settime(timer, 1000); timer2 = timer_alloc(); timer_init(timer2, &amp;timerfifo, 3); timer_settime(timer2, 300); timer3 = timer_alloc(); timer_init(timer3, &amp;timerfifo, 1); timer_settime(timer3, 50); for (;;) &#123; io_cli(); if (fifo8_status(&amp;keyfifo) + fifo8_status(&amp;mousefifo) + fifo8_status(&amp;timerfifo) == 0) &#123; io_sti(); &#125; else &#123; if (fifo8_status(&amp;keyfifo) != 0) &#123; &#125; else if (fifo8_status(&amp;mousefifo) != 0) &#123; &#125; else if (fifo8_status(&amp;timerfifo) != 0) &#123; i = fifo8_get(&amp;timerfifo); io_sti(); if (i == 10) &#123; &#125; else if (i == 3) &#123; &#125; else &#123; if (i != 0) &#123; &#125; else &#123; &#125; &#125; &#125; &#125; &#125;&#125; 调整FIFO缓冲区（2）（harib10g）把键盘、鼠标和定时器所有的信息都记录到一个FIFO缓冲区里。用数据进行区分。 0~1 表示 光标闪烁3 表示 3秒定时器10 表示 10秒定时器256~511 表示 键盘输入（键盘控制器读入的值再加上256）512~767 表示 鼠标输入（键盘控制器读入的值再加上512） 1234struct FIFO32 &#123; int *buf; int p, q, size, free, flags;&#125;; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647fifo.c文件void fifo32_init(struct FIFO32 *fifo, int size, int *buf)&#123; fifo-&gt;size = size; fifo-&gt;buf = buf; fifo-&gt;free = size; fifo-&gt;flags = 0; fifo-&gt;p = 0; fifo-&gt;q = 0; return;&#125;int fifo32_put(struct FIFO32 *fifo, int data)&#123; if (fifo-&gt;free == 0) &#123; fifo-&gt;flags |= FLAGS_OVERRUN; return -1; &#125; fifo-&gt;buf[fifo-&gt;p] = data; fifo-&gt;p++; if (fifo-&gt;p == fifo-&gt;size) &#123; fifo-&gt;p = 0; &#125; fifo-&gt;free--; return 0;&#125;int fifo32_get(struct FIFO32 *fifo)&#123; int data; if (fifo-&gt;free == fifo-&gt;size) &#123; return -1; &#125; data = fifo-&gt;buf[fifo-&gt;q]; fifo-&gt;q++; if (fifo-&gt;q == fifo-&gt;size) &#123; fifo-&gt;q = 0; &#125; fifo-&gt;free++; return data;&#125;int fifo32_status(struct FIFO32 *fifo)&#123; return fifo-&gt;size - fifo-&gt;free;&#125; 1234567891011121314151617181920212223242526keyboard.c文件struct FIFO32 *keyfifo;int keydata0;void init_keyboard(struct FIFO32 *fifo, int data0)&#123; keyfifo = fifo; keydata0 = data0; wait_KBC_sendready(); io_out8(PORT_KEYCMD, KEYCMD_WRITE_MODE); wait_KBC_sendready(); io_out8(PORT_KEYDAT, KBC_MODE); return;&#125;void inthandler21(int *esp)&#123; int data; io_out8(PIC0_OCW2, 0x61); data = io_in8(PORT_KEYDAT); fifo32_put(keyfifo, data + keydata0); return;&#125; 123456789101112131415161718192021222324252627mouse.c文件struct FIFO32 *mousefifo;int mousedata0;void enable_mouse(struct FIFO32 *fifo, int data0, struct MOUSE_DEC *mdec)&#123; mousefifo = fifo; mousedata0 = data0; wait_KBC_sendready(); io_out8(PORT_KEYCMD, KEYCMD_SENDTO_MOUSE); wait_KBC_sendready(); io_out8(PORT_KEYDAT, MOUSECMD_ENABLE); mdec-&gt;phase = 0; return;&#125;void inthandler2c(int *esp)&#123; int data; io_out8(PIC1_OCW2, 0x64); io_out8(PIC0_OCW2, 0x62); data = io_in8(PORT_KEYDAT); fifo32_put(mousefifo, data + mousedata0); return;&#125; 12345struct TIMER &#123; unsigned int timeout, flags; struct FIFO32 *fifo; int data;&#125;; 123456789101112131415161718192021222324252627282930313233343536timer.c文件void timer_init(struct TIMER *timer, struct FIFO32 *fifo, int data)&#123; timer-&gt;fifo = fifo; timer-&gt;data = data; return;&#125;void inthandler20(int *esp)&#123; int i, j; io_out8(PIC0_OCW2, 0x60); timerctl.count++; if (timerctl.next &gt; timerctl.count) &#123; return; &#125; for (i = 0; i &lt; timerctl.using; i++) &#123; if (timerctl.timers[i]-&gt;timeout &gt; timerctl.count) &#123; break; &#125; timerctl.timers[i]-&gt;flags = TIMER_FLAGS_ALLOC; fifo32_put(timerctl.timers[i]-&gt;fifo, timerctl.timers[i]-&gt;data); &#125; timerctl.using -= i; for (j = 0; j &lt; timerctl.using; j++) &#123; timerctl.timers[j] = timerctl.timers[i + j]; &#125; if (timerctl.using &gt; 0) &#123; timerctl.next = timerctl.timers[0]-&gt;timeout; &#125; else &#123; timerctl.next = 0xffffffff; &#125; return;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748bootpack.c 文件void HariMain(void)&#123; struct FIFO32 fifo; int fifobuf[128]; struct TIMER *timer, *timer2, *timer3; fifo32_init(&amp;fifo, 128, fifobuf); init_keyboard(&amp;fifo, 256); enable_mouse(&amp;fifo, 512, &amp;mdec); timer = timer_alloc(); timer_init(timer, &amp;fifo, 10); timer_settime(timer, 1000); timer2 = timer_alloc(); timer_init(timer2, &amp;fifo, 3); timer_settime(timer2, 300); timer3 = timer_alloc(); timer_init(timer3, &amp;fifo, 1); timer_settime(timer3, 50); for (;;) &#123; io_cli(); if (fifo32_status(&amp;fifo) == 0) &#123; io_sti(); &#125; else &#123; i = fifo32_get(&amp;fifo); io_sti(); if (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; /* 键盘数据 */ &#125; else if (512 &lt;= i &amp;&amp; i &lt;= 767) &#123; /* 鼠标数据 */ &#125; else if (i == 10) &#123; /* 10秒定时器 */ &#125; else if (i == 3) &#123; /* 3秒定时器 */ &#125; else if (i == 1) &#123; /* 光标定时器 */ &#125; else if (i == 0) &#123; /* 光标定时器 */ &#125; &#125; &#125;&#125; 加快中断处理（4）（harib10h使用链表的形式实现定时器的移动 123456789101112struct TIMER &#123; struct TIMER *next; unsigned int timeout, flags; struct FIFO32 *fifo; int data;&#125;;struct TIMERCTL &#123; unsigned int count, next, using; struct TIMER *t0; struct TIMER timers0[MAX_TIMER];&#125;; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677void inthandler20(int *esp)&#123; int i; struct TIMER *timer; io_out8(PIC0_OCW2, 0x60); timerctl.count++; if (timerctl.next &gt; timerctl.count) &#123; return; &#125; timer = timerctl.t0; for (i = 0; i &lt; timerctl.using; i++) &#123; if (timer-&gt;timeout &gt; timerctl.count) &#123; break; &#125; timer-&gt;flags = TIMER_FLAGS_ALLOC; fifo32_put(timer-&gt;fifo, timer-&gt;data); timer = timer-&gt;next; &#125; timerctl.using -= i; timerctl.t0 = timer; if (timerctl.using &gt; 0) &#123; timerctl.next = timerctl.t0-&gt;timeout; &#125; else &#123; timerctl.next = 0xffffffff; &#125; return;&#125;void timer_settime(struct TIMER *timer, unsigned int timeout)&#123; int e; struct TIMER *t, *s; timer-&gt;timeout = timeout + timerctl.count; timer-&gt;flags = TIMER_FLAGS_USING; e = io_load_eflags(); io_cli(); timerctl.using++; if (timerctl.using == 1) &#123; /* 空的状态 */ timerctl.t0 = timer; timer-&gt;next = 0; timerctl.next = timer-&gt;timeout; io_store_eflags(e); return; &#125; t = timerctl.t0; if (timer-&gt;timeout &lt;= t-&gt;timeout) &#123; /* 插最前面 */ timerctl.t0 = timer; timer-&gt;next = t; timerctl.next = timer-&gt;timeout; io_store_eflags(e); return; &#125; /* 寻找插入的位置 */ for (;;) &#123; s = t; t = t-&gt;next; if (t == 0) &#123; break; &#125; if (timer-&gt;timeout &lt;= t-&gt;timeout) &#123; /* 介于第一个和最后一个之间的位置 */ s-&gt;next = timer; timer-&gt;next = t; io_store_eflags(e); return; &#125; &#125; /* 最后一个位置的后面 */ s-&gt;next = timer; timer-&gt;next = 0; io_store_eflags(e); return;&#125; 使用“哨兵”简化程序（harib10i）将上述的四种情况减少到两种情况，就是提前插入一个定时器，这个定时器的时间是很长很长的，和timerctl的count一样长。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273void init_pit(void)&#123; int i; struct TIMER *t; io_out8(PIT_CTRL, 0x34); io_out8(PIT_CNT0, 0x9c); io_out8(PIT_CNT0, 0x2e); timerctl.count = 0; for (i = 0; i &lt; MAX_TIMER; i++) &#123; timerctl.timers0[i].flags = 0; &#125; t = timer_alloc(); t-&gt;timeout = 0xffffffff; t-&gt;flags = TIMER_FLAGS_USING; t-&gt;next = 0; timerctl.t0 = t; timerctl.next = 0xffffffff; return;&#125;void timer_settime(struct TIMER *timer, unsigned int timeout)&#123; int e; struct TIMER *t, *s; timer-&gt;timeout = timeout + timerctl.count; timer-&gt;flags = TIMER_FLAGS_USING; e = io_load_eflags(); io_cli(); t = timerctl.t0; if (timer-&gt;timeout &lt;= t-&gt;timeout) &#123; timerctl.t0 = timer; timer-&gt;next = t; timerctl.next = timer-&gt;timeout; io_store_eflags(e); return; &#125; for (;;) &#123; s = t; t = t-&gt;next; if (timer-&gt;timeout &lt;= t-&gt;timeout) &#123; s-&gt;next = timer; timer-&gt;next = t; io_store_eflags(e); return; &#125; &#125;&#125;void inthandler20(int *esp)&#123; struct TIMER *timer; io_out8(PIC0_OCW2, 0x60); timerctl.count++; if (timerctl.next &gt; timerctl.count) &#123; return; &#125; timer = timerctl.t0; for (;;) &#123; if (timer-&gt;timeout &gt; timerctl.count) &#123; break; &#125; timer-&gt;flags = TIMER_FLAGS_ALLOC; fifo32_put(timer-&gt;fifo, timer-&gt;data); timer = timer-&gt;next; &#125; timerctl.t0 = timer; timerctl.next = timer-&gt;timeout; return;&#125;","tags":[{"name":"30天自制操作系统","slug":"30天自制操作系统","permalink":"http://yoursite.com/tags/30天自制操作系统/"},{"name":"调整FIFO缓冲区","slug":"调整FIFO缓冲区","permalink":"http://yoursite.com/tags/调整FIFO缓冲区/"},{"name":"加快中断处理","slug":"加快中断处理","permalink":"http://yoursite.com/tags/加快中断处理/"}]},{"title":"12 自制操作系统第十二天","date":"2018-01-21T16:00:00.000Z","path":"2018/01/22/omake_12/","text":"项目地址 12345678主要内容：1. 使用定时器（harib09a）2. 计量时间（harib09b）3. 超时功能（harib09c）4. 使用多个定时器（harib09d）5. 加快中断处理（1）（harib09e）6. 加快中断处理（2）（harib09f）7. 加快中断处理（3）（harib09g） 使用定时器（harib09a）1234IRQ0的中断周期变更：AL = 0x34AL = 中断周期的低8位AL = 中断周期的高8位 如果指定中断周期是0，会被看做指定为65536。实际的中断产生的频率是单位时间周期数（主频）/ 设定的数值。比如设定1000，那么中断产生的频率就是1.19318KHz。设定值为10000的话，中断产生频率就是119.318Hz。再比如设定值是11932的话，中断产生的频率大约就是100Hz了，即每10ms发生一次中断。 11932换算成十六进制就是0x2e9c 12345678910#define PIT_CTRL 0x0043#define PIT_CNT0 0x0040void init_pit(void)&#123; io_out8(PIT_CTRL, 0x34); io_out8(PIT_CNT0, 0x9c); io_out8(PIT_CNT0, 0x2e); return;&#125; 1234567891011void HariMain(void)&#123; init_gdtidt(); init_pic(); io_sti(); fifo8_init(&amp;keyfifo, 32, keybuf); fifo8_init(&amp;mousefifo, 128, mousebuf); init_pit(); io_out8(PIC0_IMR, 0xf8); /* PIT和PIC1和键盘设置许可(11111000) */ io_out8(PIC1_IMR, 0xef); /* 鼠标设置许可(11101111) */ 123456void inthandler20(int *esp)&#123; io_out8(PIC0_OCW2, 0x60); return;&#125; 123456789101112131415_asm_inthandler20: PUSH ES PUSH DS PUSHAD MOV EAX,ESP PUSH EAX MOV AX,SS MOV DS,AX MOV ES,AX CALL _inthandler20 POP EAX POPAD POP DS POP ES IRETD 12345678910void init_gdtidt(void)&#123; set_gatedesc(idt + 0x20, (int) asm_inthandler20, 2 * 8, AR_INTGATE32); set_gatedesc(idt + 0x21, (int) asm_inthandler21, 2 * 8, AR_INTGATE32); set_gatedesc(idt + 0x27, (int) asm_inthandler27, 2 * 8, AR_INTGATE32); set_gatedesc(idt + 0x2c, (int) asm_inthandler2c, 2 * 8, AR_INTGATE32); return;&#125; 计量时间（harib09b）123struct TIMERCTL &#123; unsigned int count;&#125;; 1234567891011121314151617struct TIMERCTL timerctl;void init_pit(void)&#123; io_out8(PIT_CTRL, 0x34); io_out8(PIT_CNT0, 0x9c); io_out8(PIT_CNT0, 0x2e); timerctl.count = 0; return;&#125;void inthandler20(int *esp)&#123; io_out8(PIC0_OCW2, 0x60); timerctl.count++; return;&#125; 123456789101112void HariMain(void)&#123; for (;;) &#123; sprintf(s, &quot;%010d&quot;, timerctl.count); boxfill8(buf_win, 160, COL8_C6C6C6, 40, 28, 119, 43); putfonts8_asc(buf_win, 160, 40, 28, COL8_000000, s); sheet_refresh(sht_win, 40, 28, 120, 44); &#125;&#125; 超时功能（harib09c）123456struct TIMERCTL &#123; unsigned int count; unsigned int timeout; struct FIFO8 *fifo; unsigned char data;&#125;; 12345678910111213141516171819202122232425262728293031323334void init_pit(void)&#123; io_out8(PIT_CTRL, 0x34); io_out8(PIT_CNT0, 0x9c); io_out8(PIT_CNT0, 0x2e); timerctl.count = 0; timerctl.timeout = 0; return;&#125;void inthandler20(int *esp)&#123; io_out8(PIC0_OCW2, 0x60); timerctl.count++; if (timerctl.timeout &gt; 0) &#123; timerctl.timeout--; if (timerctl.timeout == 0) &#123; fifo8_put(timerctl.fifo, timerctl.data); &#125; &#125; return;&#125;void settimer(unsigned int timeout, struct FIFO8 *fifo, unsigned char data)&#123; int eflags; eflags = io_load_eflags(); io_cli(); timerctl.timeout = timeout; timerctl.fifo = fifo; timerctl.data = data; io_store_eflags(eflags); return;&#125; 123456789101112131415161718192021222324252627void HariMain(void)&#123; struct FIFO8 timerfifo; char s[40], keybuf[32], mousebuf[128], timerbuf[8]; fifo8_init(&amp;timerfifo, 8, timerbuf); settimer(1000, &amp;timerfifo, 1); for (;;) &#123; io_cli(); if (fifo8_status(&amp;keyfifo) + fifo8_status(&amp;mousefifo) + fifo8_status(&amp;timerfifo) == 0) &#123; io_sti(); &#125; else &#123; if (fifo8_status(&amp;keyfifo) != 0) &#123; &#125; else if (fifo8_status(&amp;mousefifo) != 0) &#123; &#125; &#125; else if (fifo8_status(&amp;timerfifo) != 0) &#123; i = fifo8_get(&amp;timerfifo); io_sti(); putfonts8_asc(buf_back, binfo-&gt;scrnx, 0, 64, COL8_FFFFFF, &quot;10[sec]&quot;); sheet_refresh(sht_back, 0, 64, 56, 80); &#125; &#125; &#125;&#125; 使用多个定时器（harib09d）123456789101112#define MAX_TIMER 500struct TIMER &#123; unsigned int timeout, flags; struct FIFO8 *fifo; unsigned char data;&#125;;struct TIMERCTL &#123; unsigned int count; struct TIMER timer[MAX_TIMER];&#125;; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#define TIMER_FLAGS_ALLOC 1 /* 已经配置 */#define TIMER_FLAGS_USING 2 /* 正在运行 */void init_pit(void)&#123; int i; io_out8(PIT_CTRL, 0x34); io_out8(PIT_CNT0, 0x9c); io_out8(PIT_CNT0, 0x2e); timerctl.count = 0; for (i = 0; i &lt; MAX_TIMER; i++) &#123; timerctl.timer[i].flags = 0; /* 未使用 */ &#125; return;&#125;struct TIMER *timer_alloc(void)&#123; int i; for (i = 0; i &lt; MAX_TIMER; i++) &#123; if (timerctl.timer[i].flags == 0) &#123; timerctl.timer[i].flags = TIMER_FLAGS_ALLOC; return &amp;timerctl.timer[i]; &#125; &#125; return 0; /* 分配失败 */&#125;void timer_free(struct TIMER *timer)&#123; timer-&gt;flags = 0; /* 未使用 */ return;&#125;void timer_init(struct TIMER *timer, struct FIFO8 *fifo, unsigned char data)&#123; timer-&gt;fifo = fifo; timer-&gt;data = data; return;&#125;void timer_settime(struct TIMER *timer, unsigned int timeout)&#123; timer-&gt;timeout = timeout; timer-&gt;flags = TIMER_FLAGS_USING; return;&#125;void inthandler20(int *esp)&#123; int i; io_out8(PIC0_OCW2, 0x60); timerctl.count++; for (i = 0; i &lt; MAX_TIMER; i++) &#123; if (timerctl.timer[i].flags == TIMER_FLAGS_USING) &#123; timerctl.timer[i].timeout--; if (timerctl.timer[i].timeout == 0) &#123; timerctl.timer[i].flags = TIMER_FLAGS_ALLOC; fifo8_put(timerctl.timer[i].fifo, timerctl.timer[i].data); &#125; &#125; &#125; return;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758void HariMain(void)&#123; struct FIFO8 timerfifo, timerfifo2, timerfifo3; char s[40], keybuf[32], mousebuf[128], timerbuf[8], timerbuf2[8], timerbuf3[8]; struct TIMER *timer, *timer2, *timer3; fifo8_init(&amp;timerfifo, 8, timerbuf); timer = timer_alloc(); timer_init(timer, &amp;timerfifo, 1); timer_settime(timer, 1000); fifo8_init(&amp;timerfifo2, 8, timerbuf2); timer2 = timer_alloc(); timer_init(timer2, &amp;timerfifo2, 1); timer_settime(timer2, 300); fifo8_init(&amp;timerfifo3, 8, timerbuf3); timer3 = timer_alloc(); timer_init(timer3, &amp;timerfifo3, 1); timer_settime(timer3, 50); for (;;) &#123; if (fifo8_status(&amp;keyfifo) + fifo8_status(&amp;mousefifo) + fifo8_status(&amp;timerfifo) + fifo8_status(&amp;timerfifo2) + fifo8_status(&amp;timerfifo3) == 0) &#123; io_sti(); &#125; else &#123; if (fifo8_status(&amp;keyfifo) != 0) &#123; &#125; else if (fifo8_status(&amp;mousefifo) != 0) &#123; &#125; else if (fifo8_status(&amp;timerfifo) != 0) &#123; i = fifo8_get(&amp;timerfifo); io_sti(); putfonts8_asc(buf_back, binfo-&gt;scrnx, 0, 64, COL8_FFFFFF, &quot;10[sec]&quot;); sheet_refresh(sht_back, 0, 64, 56, 80); &#125; else if (fifo8_status(&amp;timerfifo2) != 0) &#123; i = fifo8_get(&amp;timerfifo2); io_sti(); putfonts8_asc(buf_back, binfo-&gt;scrnx, 0, 80, COL8_FFFFFF, &quot;3[sec]&quot;); sheet_refresh(sht_back, 0, 80, 48, 96); &#125; else if (fifo8_status(&amp;timerfifo3) != 0) &#123; i = fifo8_get(&amp;timerfifo3); io_sti(); if (i != 0) &#123; i = fifo8_get(&amp;timerfifo); boxfill8(buf_back, binfo-&gt;scrnx, COL8_FFFFFF, 8, 96, 15, 111); &#125; else &#123; timer_init(timer3, &amp;timerfifo3, 1); boxfill8(buf_back, binfo-&gt;scrnx, COL8_008484, 8, 96, 15, 111); &#125; timer_settime(timer3, 50); sheet_refresh(sht_back, 8, 96, 16, 112); &#125; &#125; &#125;&#125; 加快中断处理（1）（harib09e）123456789101112131415void inthandler20(int *esp)&#123; int i; io_out8(PIC0_OCW2, 0x60); timerctl.count++; for (i = 0; i &lt; MAX_TIMER; i++) &#123; if (timerctl.timer[i].flags == TIMER_FLAGS_USING) &#123; if (timerctl.timer[i].timeout &lt;= timerctl.count) &#123; timerctl.timer[i].flags = TIMER_FLAGS_ALLOC; fifo8_put(timerctl.timer[i].fifo, timerctl.timer[i].data); &#125; &#125; &#125; return;&#125; 123456void timer_settime(struct TIMER *timer, unsigned int timeout)&#123; timer-&gt;timeout = timeout + timerctl.count; timer-&gt;flags = TIMER_FLAGS_USING; return;&#125; 加快中断处理（2）（harib09f）1234struct TIMERCTL &#123; unsigned int count, next; struct TIMER timer[MAX_TIMER];&#125;; 1234567891011121314151617181920212223void inthandler20(int *esp)&#123; int i; io_out8(PIC0_OCW2, 0x60); timerctl.count++; if (timerctl.next &gt; timerctl.count) &#123; return; &#125; timerctl.next = 0xffffffff; for (i = 0; i &lt; MAX_TIMER; i++) &#123; if (timerctl.timer[i].flags == TIMER_FLAGS_USING) &#123; if (timerctl.timer[i].timeout &lt;= timerctl.count) &#123; timerctl.timer[i].flags = TIMER_FLAGS_ALLOC; fifo8_put(timerctl.timer[i].fifo, timerctl.timer[i].data); &#125; else &#123; if (timerctl.next &gt; timerctl.timer[i].timeout) &#123; timerctl.next = timerctl.timer[i].timeout; &#125; &#125; &#125; &#125; return;&#125; 1234567891011121314151617181920212223void init_pit(void)&#123; int i; io_out8(PIT_CTRL, 0x34); io_out8(PIT_CNT0, 0x9c); io_out8(PIT_CNT0, 0x2e); timerctl.count = 0; timerctl.next = 0xffffffff; /* 最大值 */ for (i = 0; i &lt; MAX_TIMER; i++) &#123; timerctl.timer[i].flags = 0; &#125; return;&#125;void timer_settime(struct TIMER *timer, unsigned int timeout)&#123; timer-&gt;timeout = timeout + timerctl.count; timer-&gt;flags = TIMER_FLAGS_USING; if (timerctl.next &gt; timer-&gt;timeout) &#123; timerctl.next = timer-&gt;timeout; &#125; return;&#125; 加快中断处理（3）（harib09g）12345struct TIMERCTL &#123; unsigned int count, next, using; struct TIMER *timers[MAX_TIMER]; struct TIMER timers0[MAX_TIMER];&#125;; 1234567891011121314151617181920212223242526272829void inthandler20(int *esp)&#123; int i, j; io_out8(PIC0_OCW2, 0x60); timerctl.count++; if (timerctl.next &gt; timerctl.count) &#123; return; &#125; for (i = 0; i &lt; timerctl.using; i++) &#123; if (timerctl.timers[i]-&gt;timeout &gt; timerctl.count) &#123; break; &#125; /* 超时 */ timerctl.timers[i]-&gt;flags = TIMER_FLAGS_ALLOC; fifo8_put(timerctl.timers[i]-&gt;fifo, timerctl.timers[i]-&gt;data); &#125; /* i个定时器超时，进行移位 */ timerctl.using -= i; for (j = 0; j &lt; timerctl.using; j++) &#123; timerctl.timers[j] = timerctl.timers[i + j]; &#125; if (timerctl.using &gt; 0) &#123; timerctl.next = timerctl.timers[0]-&gt;timeout; &#125; else &#123; timerctl.next = 0xffffffff; &#125; return;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950void init_pit(void)&#123; int i; io_out8(PIT_CTRL, 0x34); io_out8(PIT_CNT0, 0x9c); io_out8(PIT_CNT0, 0x2e); timerctl.count = 0; timerctl.next = 0xffffffff; timerctl.using = 0; for (i = 0; i &lt; MAX_TIMER; i++) &#123; timerctl.timers0[i].flags = 0; &#125; return;&#125;struct TIMER *timer_alloc(void)&#123; int i; for (i = 0; i &lt; MAX_TIMER; i++) &#123; if (timerctl.timers0[i].flags == 0) &#123; timerctl.timers0[i].flags = TIMER_FLAGS_ALLOC; return &amp;timerctl.timers0[i]; &#125; &#125; return 0; &#125;void timer_settime(struct TIMER *timer, unsigned int timeout)&#123; int e, i, j; timer-&gt;timeout = timeout + timerctl.count; timer-&gt;flags = TIMER_FLAGS_USING; e = io_load_eflags(); io_cli(); for (i = 0; i &lt; timerctl.using; i++) &#123; if (timerctl.timers[i]-&gt;timeout &gt;= timer-&gt;timeout) &#123; break; &#125; &#125; for (j = timerctl.using; j &gt; i; j--) &#123; timerctl.timers[j] = timerctl.timers[j - 1]; &#125; timerctl.using++; timerctl.timers[i] = timer; timerctl.next = timerctl.timers[0]-&gt;timeout; io_store_eflags(e); return;&#125;","tags":[{"name":"30天自制操作系统","slug":"30天自制操作系统","permalink":"http://yoursite.com/tags/30天自制操作系统/"},{"name":"定时器","slug":"定时器","permalink":"http://yoursite.com/tags/定时器/"},{"name":"定时器的优化","slug":"定时器的优化","permalink":"http://yoursite.com/tags/定时器的优化/"}]},{"title":"11 自制操作系统第十一天","date":"2018-01-20T16:00:00.000Z","path":"2018/01/21/omake_11/","text":"项目地址 123456789主要内容：1. 鼠标显示问题（harib08a）2. 实现画面外的支持（harib08b）3. shtctl的指定缩略（harib08c）4. 显示窗口（harib08d）5. 小实验（harib08d）6. 计数器（harib08e）7. 消除闪烁（1）（harib08g）8. 消除闪烁（2）（harib08h） 鼠标显示问题（harib08a）让鼠标移动到右边和底下，可以隐藏起来。 123456if (mx &gt; binfo-&gt;scrnx - 1) &#123; mx = binfo-&gt;scrnx - 1;&#125;if (my &gt; binfo-&gt;scrny - 1) &#123; my = binfo-&gt;scrny - 1;&#125; 实现画面外的支持（harib08b）鼠标移动到右边的时候，左边也会出现鼠标的身影，这是用因为过界了，超过了vram指定大小。 123456789101112131415void sheet_refreshsub(struct SHTCTL *ctl, int vx0, int vy0, int vx1, int vy1)&#123; int h, bx, by, vx, vy, bx0, by0, bx1, by1; unsigned char *buf, c, *vram = ctl-&gt;vram; struct SHEET *sht; /* 检测是否超过了指定大小 */ if (vx0 &lt; 0) &#123; vx0 = 0; &#125; if (vy0 &lt; 0) &#123; vy0 = 0; &#125; if (vx1 &gt; ctl-&gt;xsize) &#123; vx1 = ctl-&gt;xsize; &#125; if (vy1 &gt; ctl-&gt;ysize) &#123; vy1 = ctl-&gt;ysize; &#125; for (h = 0; h &lt;= ctl-&gt;top; h++) &#123; &#125; return;&#125; shtctl的指定缩略（harib08c）12345678910111213141516171819202122232425struct SHEET &#123; unsigned char *buf; int bxsize, bysize, vx0, vy0, col_inv, height, flags; struct SHTCTL *ctl;&#125;;struct SHTCTL *shtctl_init(struct MEMMAN *memman, unsigned char *vram, int xsize, int ysize)&#123; struct SHTCTL *ctl; int i; ctl = (struct SHTCTL *) memman_alloc_4k(memman, sizeof (struct SHTCTL)); if (ctl == 0) &#123; goto err; &#125; ctl-&gt;vram = vram; ctl-&gt;xsize = xsize; ctl-&gt;ysize = ysize; ctl-&gt;top = -1; for (i = 0; i &lt; MAX_SHEETS; i++) &#123; ctl-&gt;sheets0[i].flags = 0; ctl-&gt;sheets0[i].ctl = ctl; &#125;err: return ctl;&#125; 然后修改sheet_updown函数、sheet_refresh函数、sheet_slide函数、sheet_free函数。 显示窗口（harib08d）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748void make_window8(unsigned char *buf, int xsize, int ysize, char *title)&#123; static char closebtn[14][16] = &#123; &quot;OOOOOOOOOOOOOOO@&quot;, &quot;OQQQQQQQQQQQQQ$@&quot;, &quot;OQQQQQQQQQQQQQ$@&quot;, &quot;OQQQ@@QQQQ@@QQ$@&quot;, &quot;OQQQQ@@QQ@@QQQ$@&quot;, &quot;OQQQQQ@@@@QQQQ$@&quot;, &quot;OQQQQQQ@@QQQQQ$@&quot;, &quot;OQQQQQ@@@@QQQQ$@&quot;, &quot;OQQQQ@@QQ@@QQQ$@&quot;, &quot;OQQQ@@QQQQ@@QQ$@&quot;, &quot;OQQQQQQQQQQQQQ$@&quot;, &quot;OQQQQQQQQQQQQQ$@&quot;, &quot;O$$$$$$$$$$$$$$@&quot;, &quot;@@@@@@@@@@@@@@@@&quot; &#125;; int x, y; char c; boxfill8(buf, xsize, COL8_C6C6C6, 0, 0, xsize - 1, 0 ); boxfill8(buf, xsize, COL8_FFFFFF, 1, 1, xsize - 2, 1 ); boxfill8(buf, xsize, COL8_C6C6C6, 0, 0, 0, ysize - 1); boxfill8(buf, xsize, COL8_FFFFFF, 1, 1, 1, ysize - 2); boxfill8(buf, xsize, COL8_848484, xsize - 2, 1, xsize - 2, ysize - 2); boxfill8(buf, xsize, COL8_000000, xsize - 1, 0, xsize - 1, ysize - 1); boxfill8(buf, xsize, COL8_C6C6C6, 2, 2, xsize - 3, ysize - 3); boxfill8(buf, xsize, COL8_000084, 3, 3, xsize - 4, 20 ); boxfill8(buf, xsize, COL8_848484, 1, ysize - 2, xsize - 2, ysize - 2); boxfill8(buf, xsize, COL8_000000, 0, ysize - 1, xsize - 1, ysize - 1); putfonts8_asc(buf, xsize, 24, 4, COL8_FFFFFF, title); for (y = 0; y &lt; 14; y++) &#123; for (x = 0; x &lt; 16; x++) &#123; c = closebtn[y][x]; if (c == &apos;@&apos;) &#123; c = COL8_000000; &#125; else if (c == &apos;$&apos;) &#123; c = COL8_848484; &#125; else if (c == &apos;Q&apos;) &#123; c = COL8_C6C6C6; &#125; else &#123; c = COL8_FFFFFF; &#125; buf[(5 + y) * xsize + (xsize - 21 + x)] = c; &#125; &#125; return;&#125; 12345678910111213struct SHEET *sht_back, *sht_mouse, *sht_win;unsigned char *buf_back, buf_mouse[256], *buf_win;sht_win = sheet_alloc(shtctl);buf_win = (unsigned char *) memman_alloc_4k(memman, 160 * 68);sheet_setbuf(sht_win, buf_win, 160, 68, -1);make_window8(buf_win, 160, 68, &quot;window&quot;);putfonts8_asc(buf_win, 160, 24, 28, COL8_000000, &quot;Welcome to&quot;);putfonts8_asc(buf_win, 160, 24, 44, COL8_000000, &quot; Haribote-OS!&quot;);sheet_slide(sht_win, 80, 72);sheet_updown(sht_win, 1); 小实验（harib08d）123sheet_updown(sht_back, 0);sheet_updown(sht_mouse, 1);sheet_updown(sht_win, 2); 计数器（harib08e）123456789101112131415unsigned int memtotal, count = 0;for (;;) &#123; count++; sprintf(s, &quot;%010d&quot;, count); boxfill8(buf_win, 160, COL8_C6C6C6, 40, 28, 119, 43); putfonts8_asc(buf_win, 160, 40, 28, COL8_000000, s); sheet_refresh(sht_win, 40, 28, 120, 44); io_cli(); if (fifo8_status(&amp;keyfifo) + fifo8_status(&amp;mousefifo) == 0) &#123; io_sti(); &#125; else &#123; &#125;&#125; 出现闪烁，这是因为总是先刷新背景图层，再刷新窗口图层。 消除闪烁（1）（harib08g）12345678void sheet_refreshsub(struct SHTCTL *ctl, int vx0, int vy0, int vx1, int vy1, int h0)&#123; for (h = h0; h &lt;= ctl-&gt;top; h++) &#123; &#125; return;&#125; 然后修改sheet_refresh函数、sheet_slide函数、sheet_updown函数。 把鼠标放在计数器窗口，鼠标指针也在闪烁。 消除闪烁（2）（harib08h）增加map字段，用来记录各个像素上是用来记录哪个图层。 1234567891011121314151617181920212223242526272829303132struct SHTCTL &#123; unsigned char *vram, *map; int xsize, ysize, top; struct SHEET *sheets[MAX_SHEETS]; struct SHEET sheets0[MAX_SHEETS];&#125;;struct SHTCTL *shtctl_init(struct MEMMAN *memman, unsigned char *vram, int xsize, int ysize)&#123; struct SHTCTL *ctl; int i; ctl = (struct SHTCTL *) memman_alloc_4k(memman, sizeof (struct SHTCTL)); if (ctl == 0) &#123; goto err; &#125; ctl-&gt;map = (unsigned char *) memman_alloc_4k(memman, xsize * ysize); if (ctl-&gt;map == 0) &#123; memman_free_4k(memman, (int) ctl, sizeof (struct SHTCTL)); goto err; &#125; ctl-&gt;vram = vram; ctl-&gt;xsize = xsize; ctl-&gt;ysize = ysize; ctl-&gt;top = -1; for (i = 0; i &lt; MAX_SHEETS; i++) &#123; ctl-&gt;sheets0[i].flags = 0; ctl-&gt;sheets0[i].ctl = ctl; &#125;err: return ctl;&#125; 123456789101112131415161718192021222324252627282930313233void sheet_refreshmap(struct SHTCTL *ctl, int vx0, int vy0, int vx1, int vy1, int h0)&#123; int h, bx, by, vx, vy, bx0, by0, bx1, by1; unsigned char *buf, sid, *map = ctl-&gt;map; struct SHEET *sht; if (vx0 &lt; 0) &#123; vx0 = 0; &#125; if (vy0 &lt; 0) &#123; vy0 = 0; &#125; if (vx1 &gt; ctl-&gt;xsize) &#123; vx1 = ctl-&gt;xsize; &#125; if (vy1 &gt; ctl-&gt;ysize) &#123; vy1 = ctl-&gt;ysize; &#125; for (h = h0; h &lt;= ctl-&gt;top; h++) &#123; sht = ctl-&gt;sheets[h]; sid = sht - ctl-&gt;sheets0; /* 计算图层号码 */ buf = sht-&gt;buf; bx0 = vx0 - sht-&gt;vx0; by0 = vy0 - sht-&gt;vy0; bx1 = vx1 - sht-&gt;vx0; by1 = vy1 - sht-&gt;vy0; if (bx0 &lt; 0) &#123; bx0 = 0; &#125; if (by0 &lt; 0) &#123; by0 = 0; &#125; if (bx1 &gt; sht-&gt;bxsize) &#123; bx1 = sht-&gt;bxsize; &#125; if (by1 &gt; sht-&gt;bysize) &#123; by1 = sht-&gt;bysize; &#125; for (by = by0; by &lt; by1; by++) &#123; vy = sht-&gt;vy0 + by; for (bx = bx0; bx &lt; bx1; bx++) &#123; vx = sht-&gt;vx0 + bx; if (buf[by * sht-&gt;bxsize + bx] != sht-&gt;col_inv) &#123; map[vy * ctl-&gt;xsize + vx] = sid; &#125; &#125; &#125; &#125; return;&#125; 12345678910111213141516171819202122void sheet_refreshsub(struct SHTCTL *ctl, int vx0, int vy0, int vx1, int vy1, int h0, int h1)&#123; int h, bx, by, vx, vy, bx0, by0, bx1, by1; unsigned char *buf, *vram = ctl-&gt;vram, *map = ctl-&gt;map, sid; struct SHEET *sht; for (h = h0; h &lt;= h1; h++) &#123; sht = ctl-&gt;sheets[h]; buf = sht-&gt;buf; sid = sht - ctl-&gt;sheets0; for (by = by0; by &lt; by1; by++) &#123; vy = sht-&gt;vy0 + by; for (bx = bx0; bx &lt; bx1; bx++) &#123; vx = sht-&gt;vx0 + bx; if (map[vy * ctl-&gt;xsize + vx] == sid) &#123; vram[vy * ctl-&gt;xsize + vx] = buf[by * sht-&gt;bxsize + bx]; &#125; &#125; &#125; &#125; return;&#125; 然后修改sheet_refresh函数、sheet_slide函数、sheet_updown函数。","tags":[{"name":"30天自制操作系统","slug":"30天自制操作系统","permalink":"http://yoursite.com/tags/30天自制操作系统/"},{"name":"鼠标显示","slug":"鼠标显示","permalink":"http://yoursite.com/tags/鼠标显示/"},{"name":"窗口处理","slug":"窗口处理","permalink":"http://yoursite.com/tags/窗口处理/"}]},{"title":"10 自制操作系统第十天","date":"2018-01-19T16:00:00.000Z","path":"2018/01/20/omake_10/","text":"项目地址 12345主要内容：1. 内存管理（续）（harib07a）2. 叠加处理（harib07b）3. 提高叠加处理速度（1）（harib07c）4. 提高叠加处理速度（2）（harib07d） 内存管理（续）（harib07a） 把内存管理的相关代码放到memmory.c中 内存分配时，是以一字节分配的，这样的话，就会出现很多不连续的小段空间。因此现在编写以0x1000字节为单位进行内存分配和释放的函数 123456789101112131415unsigned int memman_alloc_4k(struct MEMMAN *man, unsigned int size)&#123; unsigned int a; size = (size + 0xfff) &amp; 0xfffff000; /*向上取舍*/ a = memman_alloc(man, size); return a;&#125;int memman_free_4k(struct MEMMAN *man, unsigned int addr, unsigned int size)&#123; int i; size = (size + 0xfff) &amp; 0xfffff000; /*向上取舍*/ i = memman_free(man, addr, size); return i;&#125; 叠加处理（harib07b）1234struct SHEET &#123; unsigned char *buf; int bxsize, bysize, vx0, vy0, col_inv, height, flags;&#125;; buf是记录图层内容的地址bxsize和bysize是图层的整体大小vx0和vy0是表示图层的坐标col_inv是透明色色号height表示图层的高度flags用于存放有关图层的各种信息 12345678#define MAX_SHEETS 256struct SHTCTL &#123; unsigned char *vram; int xsize, ysize, top; struct SHEET *sheets[MAX_SHEETS]; struct SHEET sheets0[MAX_SHEETS];&#125;; vram、xsize、ysize代表VRAM的地址和画面的大小。top代表最上面图层的高度sheets0用于存放256个图层信息sheets用于记录图层的显示顺序 12345678910111213141516171819struct SHTCTL *shtctl_init(struct MEMMAN *memman, unsigned char *vram, int xsize, int ysize)&#123; struct SHTCTL *ctl; int i; ctl = (struct SHTCTL *) memman_alloc_4k(memman, sizeof (struct SHTCTL)); if (ctl == 0) &#123; goto err; &#125; ctl-&gt;vram = vram; ctl-&gt;xsize = xsize; ctl-&gt;ysize = ysize; ctl-&gt;top = -1; /* 一个图层都没有 */ for (i = 0; i &lt; MAX_SHEETS; i++) &#123; ctl-&gt;sheets0[i].flags = 0; /* 未使用标志 */ &#125;err: return ctl;&#125; 12345678910111213141516#define SHEET_USE 1struct SHEET *sheet_alloc(struct SHTCTL *ctl)&#123; struct SHEET *sht; int i; for (i = 0; i &lt; MAX_SHEETS; i++) &#123; if (ctl-&gt;sheets0[i].flags == 0) &#123; sht = &amp;ctl-&gt;sheets0[i]; sht-&gt;flags = SHEET_USE; /* 正在使用 */ sht-&gt;height = -1; /* 隐藏 */ return sht; &#125; &#125; return 0; /* 所有的sheet都在使用状态 */&#125; 12345678void sheet_setbuf(struct SHEET *sht, unsigned char *buf, int xsize, int ysize, int col_inv)&#123; sht-&gt;buf = buf; sht-&gt;bxsize = xsize; sht-&gt;bysize = ysize; sht-&gt;col_inv = col_inv; return;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354void sheet_updown(struct SHTCTL *ctl, struct SHEET *sht, int height)&#123; int h, old = sht-&gt;height; /* 之前的高度信息 */ /* 如果指定的高度过高或过低，则进行修正 */ if (height &gt; ctl-&gt;top + 1) &#123; height = ctl-&gt;top + 1; &#125; if (height &lt; -1) &#123; height = -1; &#125; sht-&gt;height = height; /* 调整好的高度 */ /* 下面对sheets[]重新调整 */ if (old &gt; height) &#123; /* 比以前低 */ if (height &gt;= 0) &#123; /* 把中间的往上提 */ for (h = old; h &gt; height; h--) &#123; ctl-&gt;sheets[h] = ctl-&gt;sheets[h - 1]; ctl-&gt;sheets[h]-&gt;height = h; &#125; ctl-&gt;sheets[height] = sht; &#125; else &#123; /* 隐藏 */ if (ctl-&gt;top &gt; old) &#123; /* 把上面的降下来 */ for (h = old; h &lt; ctl-&gt;top; h++) &#123; ctl-&gt;sheets[h] = ctl-&gt;sheets[h + 1]; ctl-&gt;sheets[h]-&gt;height = h; &#125; &#125; ctl-&gt;top--; /* 减少一个图层 */ &#125; sheet_refresh(ctl); /* 更新各个图层 */ &#125; else if (old &lt; height) &#123; /* 比以前高 */ if (old &gt;= 0) &#123; /* 把中间的拉下来 */ for (h = old; h &lt; height; h++) &#123; ctl-&gt;sheets[h] = ctl-&gt;sheets[h + 1]; ctl-&gt;sheets[h]-&gt;height = h; &#125; ctl-&gt;sheets[height] = sht; &#125; else &#123; /* 隐藏变为显示 */ /* 把已经在上面的提上去 */ for (h = ctl-&gt;top; h &gt;= height; h--) &#123; ctl-&gt;sheets[h + 1] = ctl-&gt;sheets[h]; ctl-&gt;sheets[h + 1]-&gt;height = h + 1; &#125; ctl-&gt;sheets[height] = sht; ctl-&gt;top++; /* 增加一个图层 */ &#125; sheet_refresh(ctl); /* 更新各个图层 */ &#125; return;&#125; 123456789101112131415161718192021void sheet_refresh(struct SHTCTL *ctl)&#123; int h, bx, by, vx, vy; unsigned char *buf, c, *vram = ctl-&gt;vram; struct SHEET *sht; for (h = 0; h &lt;= ctl-&gt;top; h++) &#123; sht = ctl-&gt;sheets[h]; buf = sht-&gt;buf; for (by = 0; by &lt; sht-&gt;bysize; by++) &#123; vy = sht-&gt;vy0 + by; for (bx = 0; bx &lt; sht-&gt;bxsize; bx++) &#123; vx = sht-&gt;vx0 + bx; c = buf[by * sht-&gt;bxsize + bx]; if (c != sht-&gt;col_inv) &#123; vram[vy * ctl-&gt;xsize + vx] = c; &#125; &#125; &#125; &#125; return;&#125; 123456789void sheet_slide(struct SHTCTL *ctl, struct SHEET *sht, int vx0, int vy0)&#123; sht-&gt;vx0 = vx0; sht-&gt;vy0 = vy0; if (sht-&gt;height &gt;= 0) &#123; /* 如果正在显示 */ sheet_refresh(ctl); &#125; return;&#125; 12345678void sheet_free(struct SHTCTL *ctl, struct SHEET *sht)&#123; if (sht-&gt;height &gt;= 0) &#123; sheet_updown(ctl, sht, -1); /* 隐藏 */ &#125; sht-&gt;flags = 0; /* 未使用标志位 */ return;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384void HariMain(void)&#123; struct SHTCTL *shtctl; struct SHEET *sht_back, *sht_mouse; unsigned char *buf_back, buf_mouse[256]; init_palette(); shtctl = shtctl_init(memman, binfo-&gt;vram, binfo-&gt;scrnx, binfo-&gt;scrny); sht_back = sheet_alloc(shtctl); sht_mouse = sheet_alloc(shtctl); buf_back = (unsigned char *) memman_alloc_4k(memman, binfo-&gt;scrnx * binfo-&gt;scrny); sheet_setbuf(sht_back, buf_back, binfo-&gt;scrnx, binfo-&gt;scrny, -1); /* 没有透明色 */ sheet_setbuf(sht_mouse, buf_mouse, 16, 16, 99); init_screen8(buf_back, binfo-&gt;scrnx, binfo-&gt;scrny); init_mouse_cursor8(buf_mouse, 99); sheet_slide(shtctl, sht_back, 0, 0); mx = (binfo-&gt;scrnx - 16) / 2; my = (binfo-&gt;scrny - 28 - 16) / 2; sheet_slide(shtctl, sht_mouse, mx, my); sheet_updown(shtctl, sht_back, 0); sheet_updown(shtctl, sht_mouse, 1); sprintf(s, &quot;(%3d, %3d)&quot;, mx, my); putfonts8_asc(buf_back, binfo-&gt;scrnx, 0, 0, COL8_FFFFFF, s); sprintf(s, &quot;memory %dMB free : %dKB&quot;, memtotal / (1024 * 1024), memman_total(memman) / 1024); putfonts8_asc(buf_back, binfo-&gt;scrnx, 0, 32, COL8_FFFFFF, s); sheet_refresh(shtctl); for (;;) &#123; io_cli(); if (fifo8_status(&amp;keyfifo) + fifo8_status(&amp;mousefifo) == 0) &#123; io_stihlt(); &#125; else &#123; if (fifo8_status(&amp;keyfifo) != 0) &#123; i = fifo8_get(&amp;keyfifo); io_sti(); sprintf(s, &quot;%02X&quot;, i); boxfill8(buf_back, binfo-&gt;scrnx, COL8_008484, 0, 16, 15, 31); putfonts8_asc(buf_back, binfo-&gt;scrnx, 0, 16, COL8_FFFFFF, s); sheet_refresh(shtctl); &#125; else if (fifo8_status(&amp;mousefifo) != 0) &#123; i = fifo8_get(&amp;mousefifo); io_sti(); if (mouse_decode(&amp;mdec, i) != 0) &#123; sprintf(s, &quot;[lcr %4d %4d]&quot;, mdec.x, mdec.y); if ((mdec.btn &amp; 0x01) != 0) &#123; s[1] = &apos;L&apos;; &#125; if ((mdec.btn &amp; 0x02) != 0) &#123; s[3] = &apos;R&apos;; &#125; if ((mdec.btn &amp; 0x04) != 0) &#123; s[2] = &apos;C&apos;; &#125; boxfill8(buf_back, binfo-&gt;scrnx, COL8_008484, 32, 16, 32 + 15 * 8 - 1, 31); putfonts8_asc(buf_back, binfo-&gt;scrnx, 32, 16, COL8_FFFFFF, s); mx += mdec.x; my += mdec.y; if (mx &lt; 0) &#123; mx = 0; &#125; if (my &lt; 0) &#123; my = 0; &#125; if (mx &gt; binfo-&gt;scrnx - 16) &#123; mx = binfo-&gt;scrnx - 16; &#125; if (my &gt; binfo-&gt;scrny - 16) &#123; my = binfo-&gt;scrny - 16; &#125; sprintf(s, &quot;(%3d, %3d)&quot;, mx, my); boxfill8(buf_back, binfo-&gt;scrnx, COL8_008484, 0, 0, 79, 15); putfonts8_asc(buf_back, binfo-&gt;scrnx, 0, 0, COL8_FFFFFF, s); sheet_slide(shtctl, sht_mouse, mx, my); &#125; &#125; &#125; &#125;&#125; 提高叠加处理速度（1）（harib07c）想想看，鼠标指针最多只有16×16个像素，但是每动一次鼠标，所有的湖面都要重新刷新一遍。而实际上，只要重新描绘移动相关的部分即可，也就是移动前后的部分就可以了，即256×2个像素。 1234567891011121314151617181920212223void sheet_refreshsub(struct SHTCTL *ctl, int vx0, int vy0, int vx1, int vy1)&#123; int h, bx, by, vx, vy; unsigned char *buf, c, *vram = ctl-&gt;vram; struct SHEET *sht; for (h = 0; h &lt;= ctl-&gt;top; h++) &#123; sht = ctl-&gt;sheets[h]; buf = sht-&gt;buf; for (by = 0; by &lt; sht-&gt;bysize; by++) &#123; vy = sht-&gt;vy0 + by; for (bx = 0; bx &lt; sht-&gt;bxsize; bx++) &#123; vx = sht-&gt;vx0 + bx; if (vx0 &lt;= vx &amp;&amp; vx &lt; vx1 &amp;&amp; vy0 &lt;= vy &amp;&amp; vy &lt; vy1) &#123; c = buf[by * sht-&gt;bxsize + bx]; if (c != sht-&gt;col_inv) &#123; vram[vy * ctl-&gt;xsize + vx] = c; &#125; &#125; &#125; &#125; &#125; return;&#125; 1234567891011void sheet_slide(struct SHTCTL *ctl, struct SHEET *sht, int vx0, int vy0)&#123; int old_vx0 = sht-&gt;vx0, old_vy0 = sht-&gt;vy0; sht-&gt;vx0 = vx0; sht-&gt;vy0 = vy0; if (sht-&gt;height &gt;= 0) &#123; sheet_refreshsub(ctl, old_vx0, old_vy0, old_vx0 + sht-&gt;bxsize, old_vy0 + sht-&gt;bysize); sheet_refreshsub(ctl, vx0, vy0, vx0 + sht-&gt;bxsize, vy0 + sht-&gt;bysize); &#125; return;&#125; 1234567void sheet_refresh(struct SHTCTL *ctl, struct SHEET *sht, int bx0, int by0, int bx1, int by1)&#123; if (sht-&gt;height &gt;= 0) &#123; sheet_refreshsub(ctl, sht-&gt;vx0 + bx0, sht-&gt;vy0 + by0, sht-&gt;vx0 + bx1, sht-&gt;vy0 + by1); &#125; return;&#125; 提高叠加处理速度（2）（harib07d）依照sheet_refreshsub这个函数，即使不写入东西，也要执行很多if语句。 123456789101112131415161718192021222324252627282930void sheet_refreshsub(struct SHTCTL *ctl, int vx0, int vy0, int vx1, int vy1)&#123; int h, bx, by, vx, vy, bx0, by0, bx1, by1; unsigned char *buf, c, *vram = ctl-&gt;vram; struct SHEET *sht; for (h = 0; h &lt;= ctl-&gt;top; h++) &#123; sht = ctl-&gt;sheets[h]; buf = sht-&gt;buf; bx0 = vx0 - sht-&gt;vx0; by0 = vy0 - sht-&gt;vy0; bx1 = vx1 - sht-&gt;vx0; by1 = vy1 - sht-&gt;vy0; if (bx0 &lt; 0) &#123; bx0 = 0; &#125; if (by0 &lt; 0) &#123; by0 = 0; &#125; if (bx1 &gt; sht-&gt;bxsize) &#123; bx1 = sht-&gt;bxsize; &#125; if (by1 &gt; sht-&gt;bysize) &#123; by1 = sht-&gt;bysize; &#125; for (by = by0; by &lt; by1; by++) &#123; vy = sht-&gt;vy0 + by; for (bx = bx0; bx &lt; bx1; bx++) &#123; vx = sht-&gt;vx0 + bx; c = buf[by * sht-&gt;bxsize + bx]; if (c != sht-&gt;col_inv) &#123; vram[vy * ctl-&gt;xsize + vx] = c; &#125; &#125; &#125; &#125; return;&#125; 交集是需要刷新的面积","tags":[{"name":"30天自制操作系统","slug":"30天自制操作系统","permalink":"http://yoursite.com/tags/30天自制操作系统/"},{"name":"内存管理","slug":"内存管理","permalink":"http://yoursite.com/tags/内存管理/"},{"name":"叠加处理","slug":"叠加处理","permalink":"http://yoursite.com/tags/叠加处理/"}]},{"title":"9 自制操作系统第九天","date":"2018-01-17T16:00:00.000Z","path":"2018/01/18/omake_9/","text":"项目地址 12345主要内容：1. 文件整理（harib06a）2. 内存容量检查（1）（harib06b）3. 内存容量检查（2）（harib06c）4. 内存管理（harib06d） 文件整理（harib06a） 函数名 移动前 移动后 wait_KBC_sendready bootpack.c keyboard.c init_keyboard bootpack.c keyboard.c enable_mouse bootpack.c mouse.c mouse_decode bootpack.c mouse.c inthandler21 int.c keyboard.c inthandler2c int.c mouse.c 内存容量检查（1）（harib06b）让高速缓存无效。内存检查时，要先往内存随便写入一个值，然后马上读取，来检查读取的数值与写入的值是否相等。 12345678910111213141516171819202122232425262728293031323334bootpack.c文件中unsigned int memtest(unsigned int start, unsigned int end)&#123; char flg486 = 0; unsigned int eflg, cr0, i; /* 检查CPU是386还是486以上的 */ eflg = io_load_eflags(); eflg |= EFLAGS_AC_BIT; /* AC-bit = 1 */ io_store_eflags(eflg); eflg = io_load_eflags(); if ((eflg &amp; EFLAGS_AC_BIT) != 0) &#123; /* 如果是386，即使设定AC=1，AC的值还是会自动回到0 */ flg486 = 1; &#125; eflg &amp;= ~EFLAGS_AC_BIT; /* AC-bit = 0 */ io_store_eflags(eflg); if (flg486 != 0) &#123; cr0 = load_cr0(); cr0 |= CR0_CACHE_DISABLE; /* 禁止缓存 */ store_cr0(cr0); &#125; i = memtest_sub(start, end); if (flg486 != 0) &#123; cr0 = load_cr0(); cr0 &amp;= ~CR0_CACHE_DISABLE; /* 允许缓存 */ store_cr0(cr0); &#125; return i;&#125; 12345678910naskfunc.nas文件中_load_cr0: ; int load_cr0(void); MOV EAX,CR0 RET_store_cr0: ; void store_cr0(int cr0); MOV EAX,[ESP+4] MOV CR0,EAX RET 1234567891011121314151617181920212223内存检查的实现unsigned int memtest_sub(unsigned int start, unsigned int end)&#123; unsigned int i, *p, old, pat0 = 0xaa55aa55, pat1 = 0x55aa55aa; for (i = start; i &lt;= end; i += 0x1000) &#123; p = (unsigned int *) (i + 0xffc); old = *p; /* 记住修改之前的值 */ *p = pat0; /* 写入 */ *p ^= 0xffffffff; /* 反转 */ if (*p != pat1) &#123; /* 检查反转结果 */not_memory: *p = old; break; &#125; *p ^= 0xffffffff; /* 再次反转 */ if (*p != pat0) &#123; /* 检查是否恢复 */ goto not_memory; &#125; *p = old; /* 恢复原来的值 */ &#125; return i;&#125; 每次增加0x1000，相当于4KB。p = i + 0xffc; 只让它检查末尾的4个字节。 毕竟在系统启动时内存已经被仔细检查过了，所以像这次这样，目的只是确认容量的话，做到如此程度就足够了。甚至可以说每次检查1MB都没什么问题。 123i = memtest(0x00400000, 0xbfffffff) / (1024 * 1024);sprintf(s, &quot;memory %dMB&quot;, i);putfonts8_asc(binfo-&gt;vram, binfo-&gt;scrnx, 0, 32, COL8_FFFFFF, s); 这个程序最大可以识别3G范围的内存，如果在QEMU上运行，根据模拟器的设定，内存应为32MB。但是运行之后，显示的是3072MB。下面解释原因。 内存容量检查（2）（harib06c）12345678910111213141516使用make -r bootpack.nas指令，查看编译后的指令_memtest_sub: PUSH EBP ; C编译器的固定语句 MOV EBP,ESP MOV EDX,DWORD [12+EBP] ; EDX = end MOV EAX,DWORD [8+EBP] ; EAX = start CMP EAX,EDX ; if (EAX &gt; EDX) goto L30； JA L30L36:L34: ADD EAX,4096 ; EAX += 0x1000; CMP EAX,EDX ; if (EAX &lt;= EDX) goto L36; JBE L36L30: POP EBP RET 编译之后，没有XOR指令，只剩下了for语句。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354编译器中所想（1）它认为if语句的结果是肯定的，得不到执行，所以简化为如下：unsigned int memtest_sub(unsigned int start, unsigned int end) &#123; unsigned int i, *p, old, pat0 = 0xaa55aa55, pat1 = 0x55aa55aa; for (i = start; i &lt;= end; i += 0x1000) &#123; p = (unsigned int *) (i + 0xffc); old = *p; *p = pat0; *p ^= 0xffffffff; *p ^= 0xffffffff; *p = old; &#125; return i;&#125;编译器中所想（2）反转两次会变回之前的状态，所以这些处理也不需要，变成如下：unsigned int memtest_sub(unsigned int start, unsigned int end) &#123; unsigned int i, *p, old, pat0 = 0xaa55aa55, pat1 = 0x55aa55aa; for (i = start; i &lt;= end; i += 0x1000) &#123; p = (unsigned int *) (i + 0xffc); old = *p; *p = pat0; *p = old; &#125; return i;&#125;编译器中所想（3）“*p=pat0”，没有意义，因为*p迟早被赋值old，变成如下：unsigned int memtest_sub(unsigned int start, unsigned int end) &#123; unsigned int i, *p, old, pat0 = 0xaa55aa55, pat1 = 0x55aa55aa; for (i = start; i &lt;= end; i += 0x1000) &#123; p = (unsigned int *) (i + 0xffc); old = *p; *p = old; &#125; return i;&#125;编译器中所想（4）*p什么都没有写入，可以删掉了，变成如下：unsigned int memtest_sub(unsigned int start, unsigned int end) &#123; unsigned int i, *p, old, pat0 = 0xaa55aa55, pat1 = 0x55aa55aa; for (i = start; i &lt;= end; i += 0x1000) &#123; p = (unsigned int *) (i + 0xffc); &#125; return i;&#125;编译器中所想（5）变量p也没有没有用到，也可以删了，变成如下：unsigned int memtest_sub(unsigned int start, unsigned int end) &#123; unsigned int i, *p, old, pat0 = 0xaa55aa55, pat1 = 0x55aa55aa; for (i = start; i &lt;= end; i += 0x1000) &#123; &#125; return i;&#125; 既然编译器这么优秀，那只好用汇编写了 123456789101112131415161718192021222324252627282930313233343536_memtest_sub: ;unsigned int memtest_sub(unsigned int start, unsigned int end) PUSH EDI PUSH ESI PUSH EBX MOV ESI, 0xaa55aa55 MOV EDI, 0x55aa55aa MOV EAX, [ESP + 12 + 4] ;i = start; mts_loop: MOV EBX, EAX ADD EBX, 0xffc ; p = i + 0xffc; MOV EDX, [EBX] ; old = *port MOV [EBX], ESI ; *p = pat0 XOR DWORD [EBX], 0xffffffff ; *p ^= 0xffffffff; CMP EDI, [EBX] ; if (*p != pat1) goto fin; JNE mts_fin XOR DWORD [EBX], 0xffffffff ; *p ^= 0xffffffff; CMP ESI, [EBX] ; if(*p != pat0) goto fin JNE mts_fin MOV [EBX], EDX ; *p = old ADD EAX, 0x1000 ; i += 0x1000; CMP EAX, [ESP + 12 + 8] ; if (i &lt;= end) goto mts_loop JBE mts_loop POP EBX POP ESI POP EDI RET mts_fin: MOV [EBX], EDX ; *p = old POP EBX POP ESI POP EDI RET 内存管理（harib06d）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#define MEMMAN_FREES 4090 /* 大约32KB */struct FREEINFO &#123; unsigned int addr, size;&#125;;struct MEMMAN &#123; /* 内存管理 */ int frees, maxfrees, lostsize, losts; struct FREEINFO free[MEMMAN_FREES];&#125;;void memman_init(struct MEMMAN *man)&#123; man-&gt;frees = 0; /* 可用信息数目 */ man-&gt;maxfrees = 0; /* frees的最大值 */ man-&gt;lostsize = 0; /* 释放失败的内存的大小总和 */ man-&gt;losts = 0; /* 释放失败的次数 */ return;&#125;unsigned int memman_total(struct MEMMAN *man)/* 空余内存大小的合计 */&#123; unsigned int i, t = 0; for (i = 0; i &lt; man-&gt;frees; i++) &#123; t += man-&gt;free[i].size; &#125; return t;&#125;unsigned int memman_alloc(struct MEMMAN *man, unsigned int size)/* 分配 */&#123; unsigned int i, a; for (i = 0; i &lt; man-&gt;frees; i++) &#123; if (man-&gt;free[i].size &gt;= size) &#123; a = man-&gt;free[i].addr; man-&gt;free[i].addr += size; man-&gt;free[i].size -= size; if (man-&gt;free[i].size == 0) &#123; /* 如果free[i]的size变成了0，就减掉一条可用信息 */ man-&gt;frees--; for (; i &lt; man-&gt;frees; i++) &#123; man-&gt;free[i] = man-&gt;free[i + 1]; /* 峔憿懱偺戙擖 */ &#125; &#125; return a; &#125; &#125; return 0; /* 没有可以用的空间 */&#125;int memman_free(struct MEMMAN *man, unsigned int addr, unsigned int size)/* 释放 */&#123; int i, j; /* 找到地址 */ for (i = 0; i &lt; man-&gt;frees; i++) &#123; if (man-&gt;free[i].addr &gt; addr) &#123; break; &#125; &#125; /* free[i - 1].addr &lt; addr &lt; free[i].addr */ if (i &gt; 0) &#123; /* 前面有可以用的空间 */ if (man-&gt;free[i - 1].addr + man-&gt;free[i - 1].size == addr) &#123; /* 可以和前面的合并到一起 */ man-&gt;free[i - 1].size += size; if (i &lt; man-&gt;frees) &#123; /* 后面也有 */ if (addr + size == man-&gt;free[i].addr) &#123; /* 也可以和后面的合并到一起 */ man-&gt;free[i - 1].size += man-&gt;free[i].size; man-&gt;frees--; for (; i &lt; man-&gt;frees; i++) &#123; man-&gt;free[i] = man-&gt;free[i + 1]; &#125; &#125; &#125; return 0; /* 成功完成 */ &#125; &#125; /* 不能和前面的合并到一起 */ if (i &lt; man-&gt;frees) &#123; /* 后面还有 */ if (addr + size == man-&gt;free[i].addr) &#123; /* 可以和后面的合并到一起 */ man-&gt;free[i].addr = addr; man-&gt;free[i].size += size; return 0; /* 成功完成 */ &#125; &#125; /* 既不能和前面的合并到一起，也不能和后面的合并到一起 */ if (man-&gt;frees &lt; MEMMAN_FREES) &#123; for (j = man-&gt;frees; j &gt; i; j--) &#123; man-&gt;free[j] = man-&gt;free[j - 1]; &#125; man-&gt;frees++; if (man-&gt;maxfrees &lt; man-&gt;frees) &#123; man-&gt;maxfrees = man-&gt;frees; &#125; man-&gt;free[i].addr = addr; man-&gt;free[i].size = size; return 0; &#125; /* 不能往后移动 */ man-&gt;losts++; man-&gt;lostsize += size; return -1; /* 失败 */&#125; 123456789101112131415最后#define MEMMAN_ADDR 0x003c0000void HariMain(void)&#123; unsigned int memtotal; struct MEMMAN *memman = (struct MEMMAN *) MEMMAN_ADDR; memtotal = memtest(0x00400000, 0xbfffffff); memman_init(memman); memman_free(memman, 0x00001000, 0x0009e000); /* 0x00001000 - 0x0009efff */ memman_free(memman, 0x00400000, memtotal - 0x00400000); sprintf(s, &quot;memory %dMB free : %dKB&quot;, memtotal / (1024 * 1024), memman_total(memman) / 1024); putfonts8_asc(binfo-&gt;vram, binfo-&gt;scrnx, 0, 32, COL8_FFFFFF, s); 屏幕应该显示 memory 32MB free：29304KB 29304 = 632KB + 28MB","tags":[{"name":"30天自制操作系统","slug":"30天自制操作系统","permalink":"http://yoursite.com/tags/30天自制操作系统/"},{"name":"内存管理","slug":"内存管理","permalink":"http://yoursite.com/tags/内存管理/"},{"name":"内存容量检查","slug":"内存容量检查","permalink":"http://yoursite.com/tags/内存容量检查/"}]},{"title":"8 自制操作系统第八天","date":"2018-01-16T16:00:00.000Z","path":"2018/01/17/omake_8/","text":"项目地址 123456主要内容：1. 鼠标解读（1）（harib05a）2. 代码整理（harib05b）3. 鼠标解读（2）（harib05c）4. 移动鼠标指针（harib05d）5. 通往32位模式之路 鼠标解读（1）（harib05a）123456789101112131415161718192021222324252627282930313233343536373839404142434445unsigned char mouse_dbuf[3], mouse_phase;enable_mouse();mouse_phase = 0; /* 进入等待鼠标的0xfa的状态 */for (;;) &#123; io_cli(); if (fifo8_status(&amp;keyfifo) + fifo8_status(&amp;mousefifo) == 0) &#123; io_stihlt(); &#125; else &#123; if (fifo8_status(&amp;keyfifo) != 0) &#123; i = fifo8_get(&amp;keyfifo); io_sti(); sprintf(s, &quot;%02X&quot;, i); boxfill8(binfo-&gt;vram, binfo-&gt;scrnx, COL8_008484, 0, 16, 15, 31); putfonts8_asc(binfo-&gt;vram, binfo-&gt;scrnx, 0, 16, COL8_FFFFFF, s); &#125; else if (fifo8_status(&amp;mousefifo) != 0) &#123; i = fifo8_get(&amp;mousefifo); io_sti(); if (mouse_phase == 0) &#123; /* 等待鼠标的0xfa */ if (i == 0xfa) &#123; mouse_phase = 1; &#125; &#125; else if (mouse_phase == 1) &#123; /* 等待鼠标的第一字节 */ mouse_dbuf[0] = i; mouse_phase = 2; &#125; else if (mouse_phase == 2) &#123; /* 等待鼠标的第二字节 */ mouse_dbuf[1] = i; mouse_phase = 3; &#125; else if (mouse_phase == 3) &#123; /* 等待鼠标的第三字节 */ mouse_dbuf[2] = i; mouse_phase = 1; /* 显示鼠标的三个字节 */ sprintf(s, &quot;%02X %02X %02X&quot;, mouse_dbuf[0], mouse_dbuf[1], mouse_dbuf[2]); boxfill8(binfo-&gt;vram, binfo-&gt;scrnx, COL8_008484, 32, 16, 32 + 8 * 8 - 1, 31); putfonts8_asc(binfo-&gt;vram, binfo-&gt;scrnx, 32, 16, COL8_FFFFFF, s); &#125; &#125; &#125;&#125; 屏幕会出现类似08 12 34之类的三字节数字。 如果移动鼠标，这个“08”部分的“0”那一位，会在0~3范围内变化。如果只是移动鼠标，08部分的“8”那一位，不会有任何变化，只有当点击鼠标的时候它才会变化。不仅左击有反应，右击和点击中间滚轮时都会有反应。不管怎样点击鼠标，这个值会在8~F之间变化。 “12”部分与鼠标的左右移动有关系 “34”部分与鼠标上下移动有关系 代码整理（harib05b）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667struct MOUSE_DEC &#123; unsigned char buf[3], phase;&#125;;void enable_mouse(struct MOUSE_DEC *mdec);int mouse_decode(struct MOUSE_DEC *mdec, unsigned char dat);for (;;) &#123; io_cli(); if (fifo8_status(&amp;keyfifo) + fifo8_status(&amp;mousefifo) == 0) &#123; io_stihlt(); &#125; else &#123; if (fifo8_status(&amp;keyfifo) != 0) &#123; i = fifo8_get(&amp;keyfifo); io_sti(); sprintf(s, &quot;%02X&quot;, i); boxfill8(binfo-&gt;vram, binfo-&gt;scrnx, COL8_008484, 0, 16, 15, 31); putfonts8_asc(binfo-&gt;vram, binfo-&gt;scrnx, 0, 16, COL8_FFFFFF, s); &#125; else if (fifo8_status(&amp;mousefifo) != 0) &#123; i = fifo8_get(&amp;mousefifo); io_sti(); if (mouse_decode(&amp;mdec, i) != 0) &#123; sprintf(s, &quot;%02X %02X %02X&quot;, mdec.buf[0], mdec.buf[1], mdec.buf[2]); boxfill8(binfo-&gt;vram, binfo-&gt;scrnx, COL8_008484, 32, 16, 32 + 8 * 8 - 1, 31); putfonts8_asc(binfo-&gt;vram, binfo-&gt;scrnx, 32, 16, COL8_FFFFFF, s); &#125; &#125; &#125;&#125;void enable_mouse(struct MOUSE_DEC *mdec)&#123; wait_KBC_sendready(); io_out8(PORT_KEYCMD, KEYCMD_SENDTO_MOUSE); wait_KBC_sendready(); io_out8(PORT_KEYDAT, MOUSECMD_ENABLE); mdec-&gt;phase = 0; return;&#125;int mouse_decode(struct MOUSE_DEC *mdec, unsigned char dat)&#123; if (mdec-&gt;phase == 0) &#123; if (dat == 0xfa) &#123; mdec-&gt;phase = 1; &#125; return 0; &#125; if (mdec-&gt;phase == 1) &#123; mdec-&gt;buf[0] = dat; mdec-&gt;phase = 2; return 0; &#125; if (mdec-&gt;phase == 2) &#123; mdec-&gt;buf[1] = dat; mdec-&gt;phase = 3; return 0; &#125; if (mdec-&gt;phase == 3) &#123; mdec-&gt;buf[2] = dat; mdec-&gt;phase = 1; return 1; &#125; return -1; &#125; 鼠标解读（2）（harib05c）12345678910111213141516171819202122232425262728293031323334353637383940414243struct MOUSE_DEC &#123; unsigned char buf[3], phase; int x, y, btn;&#125;;int mouse_decode(struct MOUSE_DEC *mdec, unsigned char dat)&#123; if (mdec-&gt;phase == 0) &#123; if (dat == 0xfa) &#123; mdec-&gt;phase = 1; &#125; return 0; &#125; if (mdec-&gt;phase == 1) &#123; if ((dat &amp; 0xc8) == 0x08) &#123; /* 检查第一个字节的合法性 */ mdec-&gt;buf[0] = dat; mdec-&gt;phase = 2; &#125; return 0; &#125; if (mdec-&gt;phase == 2) &#123; mdec-&gt;buf[1] = dat; mdec-&gt;phase = 3; return 0; &#125; if (mdec-&gt;phase == 3) &#123; mdec-&gt;buf[2] = dat; mdec-&gt;phase = 1; mdec-&gt;btn = mdec-&gt;buf[0] &amp; 0x07; mdec-&gt;x = mdec-&gt;buf[1]; mdec-&gt;y = mdec-&gt;buf[2]; if ((mdec-&gt;buf[0] &amp; 0x10) != 0) &#123; mdec-&gt;x |= 0xffffff00; &#125; if ((mdec-&gt;buf[0] &amp; 0x20) != 0) &#123; mdec-&gt;y |= 0xffffff00; &#125; mdec-&gt;y = - mdec-&gt;y; return 1; &#125; return -1; &#125; x、y和btn分别存放移动信息和按键状态 第一字节对移动有反应的部分是否在0~3的范围内；同时判断点击有反应的部分是否在8~F的范围内。 鼠标键的状态存放在buf[0]第3位。 x和y直接使用buf[1]和buf[2]，但是需要使用第一字节中对鼠标移动有反应的几位信息，将x和y第8位以及第8位以后全部设为1，或全部设为0。鼠标与屏幕的y方向相反，需要对y符号进行取反操作。123456789101112131415161718192021222324修改显示部分&#125; else if (fifo8_status(&amp;mousefifo) != 0) &#123; i = fifo8_get(&amp;mousefifo); io_sti(); sprintf(s, &quot;[lcr %4d %4d]&quot;, mdec.x, mdec.y); if (mouse_decode(&amp;mdec, i) != 0) &#123; if ((mdec.btn &amp; 0x01) != 0) &#123; s[1] = &apos;L&apos;; &#125; if ((mdec.btn &amp; 0x02) != 0) &#123; s[3] = &apos;R&apos;; &#125; if ((mdec.btn &amp; 0x04) != 0) &#123; s[2] = &apos;C&apos;; &#125; boxfill8(binfo-&gt;vram, binfo-&gt;scrnx, COL8_008484, 32, 16, 32 + 15 * 8 - 1, 31); putfonts8_asc(binfo-&gt;vram, binfo-&gt;scrnx, 32, 16, COL8_FFFFFF, s); &#125;&#125; 移动鼠标指针（harib05d）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&#125; else if (fifo8_status(&amp;mousefifo) != 0) &#123; i = fifo8_get(&amp;mousefifo); io_sti(); if (mouse_decode(&amp;mdec, i) != 0) &#123; sprintf(s, &quot;[lcr %4d %4d]&quot;, mdec.x, mdec.y); if ((mdec.btn &amp; 0x01) != 0) &#123; s[1] = &apos;L&apos;; &#125; if ((mdec.btn &amp; 0x02) != 0) &#123; s[3] = &apos;R&apos;; &#125; if ((mdec.btn &amp; 0x04) != 0) &#123; s[2] = &apos;C&apos;; &#125; boxfill8(binfo-&gt;vram, binfo-&gt;scrnx, COL8_008484, 32, 16, 32 + 15 * 8 - 1, 31); putfonts8_asc(binfo-&gt;vram, binfo-&gt;scrnx, 32, 16, COL8_FFFFFF, s); /* 鼠标指针的移动 */ boxfill8(binfo-&gt;vram, binfo-&gt;scrnx, COL8_008484, mx, my, mx + 15, my + 15);/* 隐藏鼠标 */ mx += mdec.x; my += mdec.y; if (mx &lt; 0) &#123; mx = 0; &#125; if (my &lt; 0) &#123; my = 0; &#125; if (mx &gt; binfo-&gt;scrnx - 16) &#123; mx = binfo-&gt;scrnx - 16; &#125; if (my &gt; binfo-&gt;scrny - 16) &#123; my = binfo-&gt;scrny - 16; &#125; sprintf(s, &quot;(%3d, %3d)&quot;, mx, my); boxfill8(binfo-&gt;vram, binfo-&gt;scrnx, COL8_008484, 0, 0, 79, 15); putfonts8_asc(binfo-&gt;vram, binfo-&gt;scrnx, 0, 0, COL8_FFFFFF, s); putblock8_8(binfo-&gt;vram, binfo-&gt;scrnx, 16, 16, mx, my, mcursor, 16); &#125; 通往32位模式之路12345678910111213MOV AL, 0xffOUT 0x21, ALNOPOUT 0Xa1, ALCLT 相当于C语言中的：io_out8(PIC0_IMR, 0xff); io_out8(PIC1_IMR, 0xff); io_cli(); NOP指令什么都不做，它只是让CPU休息一个时钟长的时间 12345678910111213141516CALL waitkbdoutMOV AL, 0xd1OUT 0x64, ALCALL waitkbdoutMOV AL, 0xdf ; enable A20OUT 0x60, ALCALL waitkbdout相当于C语言的wait_KBC_sendready();io_out8(PORT_KEYCMD, 0xd1);wait_KBC_sendready();io_out8(PORT_KEYDAT, 0xdf);wait_KBC_sendready(); 这里发送的指令是指令键盘控制电路的附属端口输出0xdf。所要完成的功能是让A20GATE信号线变成ON的状态。它能使内存的1MB以上的部分变成可使用状态。 最后还有一点，“wait_KBC_sendready();”是多余的。在此之后，虽然不会往键盘送命令，但仍然要等到下一个命令能够送来为止。这是为了等待A20GATE的处理切实完成。 12345678910111213141516[INSTRSET &quot;i486p&quot;] ; LGDT [GDTR0] ; 设定临时GDT MOV EAX,CR0 AND EAX,0x7fffffff ; 设bit31为0（为了禁止分页） OR EAX,0x00000001 ; 设bit0为1（为了切换到保护模式） MOV CR0,EAX JMP pipelineflush pipelineflush: MOV AX,1*8 ; MOV DS,AX MOV ES,AX MOV FS,AX MOV GS,AX MOV SS,AX LGDT指令，不管三七二十一，把随意准备的GDT读进来。对于这个暂定的GDT，我们以后还要重新设置。 将CR0的最高位置为0，最低位设置为1.这样就进入的保护模式。而且要马上执行JMP指令。 进入保护模式之后，段寄存器的意思也变了（不再是乘以16后再加算的意思了），除了CS以外所有段寄存器的值都从0x0000变成了0x0008。0x0008相当于“gdt+1”的段 1234567891011121314151617181920212223242526272829303132; bootpack的装送 MOV ESI,bootpack ; 转送源 MOV EDI,BOTPAK ; 转送目的地 MOV ECX,512*1024/4 CALL memcpy; 磁盘数据最终转送到它本来的位置; 首先从启动区开始 MOV ESI,0x7c00 MOV EDI,DSKCAC MOV ECX,512/4 CALL memcpy; 所有剩下的 MOV ESI,DSKCAC0+512 MOV EDI,DSKCAC+512 MOV ECX,0 MOV CL,BYTE [CYLS] IMUL ECX,512*18*2/4 SUB ECX,512/4 CALL memcpy 上述代码和以下C语言等同memcpy(bootpack, BOTPAK, 512*1024/4);memcpy(0x7c00, DSKCAC, 512/4);memcpy(bootpack, BOTPAK, cyls*512*18*2/4 - 512/4); memcpy(源地址, 目标地址, 数据大小);转送的数据是双字节位单位的，所以数据大小用字节数除以4来指定。 IMUL是乘法运算 SUB是减法运算。 1234567891011121314; bootpack的启动 MOV EBX,BOTPAK MOV ECX,[EBX+16] ADD ECX,3 ; ECX += 3; SHR ECX,2 ; ECX /= 4; JZ skip ; 没有要转送的东西 MOV ESI,[EBX+20] ; ADD ESI,EBX MOV EDI,[EBX+12] ; CALL memcpyskip: MOV ESP,[EBX+12] ; 栈初始值 JMP DWORD 2*8:0x0000001b JMP DWORD 28:0x0000001b将28带入CS里，同时移动到0x1b号地址。这里的0x1b号地址是指第二个段的0x1b号地址。第二个段的基地址是0x280000，所以实际上是从0x28001b开始的。这也就是bootpack.hrb的第0x1b号地址。这样就开始执行bootpack.hrb了。 123456789操作系统内存分布图：0x00000000 - 0x000fffff : 虽然在启动区会多次使用，但之后会变空（1M）0x00100000 - 0x00267fff：用于保存软盘的内容（1440KB）0x00268000 - 0x0026f7ff：空（30KB）0x0026f800 - 0x0026ffff：IDT（2KB）0x00270000 - 0x0027ffff：GDT（64KB）0x00280000 - 0x002fffff：bootpack.hrb（512KB）0x00300000 - 0x003fffff：栈及其他（1Mb）0x00400000 - ：空 12345waitkbdout: IN AL,0x64 AND AL,0x02 JNZ waitkbdout ; 如果不为0，就跳到waitkbdout RET 12345678memcpy: MOV EAX,[ESI] ADD ESI,4 MOV [EDI],EAX ADD EDI,4 SUB ECX,1 JNZ memcpy RET 12345678910111213 ALIGNB 16GDT0: RESB 8 DW 0xffff,0x0000,0x9200,0x00cf ; DW 0xffff,0x0000,0x9a28,0x0047 ; DW 0GDTR0: DW 8*3-1 DD GDT0 ALIGNB 16bootpack: ALIGNB的指令就是一直添加DB0，直到地址能被16整除的时候。目的是让GDT0的地址是8的整数倍。 12345GDT0也是一种特定的GDT。 0号是空区域。 1号和2号分别由下式设定:set_segmdesc(gdt + 1, 0xffffffff, 0x00000000, AR_DATA32_RW);set_segmdesc(gdt + 2, LIMIT_BOTPAK, ADR_BOTPAK, AR_CODE32_ER); 最初状态下，GDT在asmhead.nas里，并不在0x00270000~0x0027ffff的范围里。IDT连设定都没有设定，所以仍处于中断禁止的状态。应当趁着硬件上积累过多数据而产生误动作之前，尽快开放中断，接收数据。 因此，应该在进行调色板的初始化之前以及画面的准备之前，先赶紧重新创建GDT和IDT，初始化PIC，并执行“io_sti();” 12345678910111213141516171819void HariMain(void)&#123; struct BOOTINFO *binfo = (struct BOOTINFO *) ADR_BOOTINFO; char s[40], mcursor[256], keybuf[32], mousebuf[128]; int mx, my, i; struct MOUSE_DEC mdec; init_gdtidt(); init_pic(); io_sti(); fifo8_init(&amp;keyfifo, 32, keybuf); fifo8_init(&amp;mousefifo, 128, mousebuf); io_out8(PIC0_IMR, 0xf9); io_out8(PIC1_IMR, 0xef); init_keyboard(); init_palette(); init_screen8(binfo-&gt;vram, binfo-&gt;scrnx, binfo-&gt;scrny);","tags":[{"name":"30天自制操作系统","slug":"30天自制操作系统","permalink":"http://yoursite.com/tags/30天自制操作系统/"},{"name":"鼠标解读","slug":"鼠标解读","permalink":"http://yoursite.com/tags/鼠标解读/"},{"name":"移动鼠标","slug":"移动鼠标","permalink":"http://yoursite.com/tags/移动鼠标/"},{"name":"asmhead.nas解读","slug":"asmhead-nas解读","permalink":"http://yoursite.com/tags/asmhead-nas解读/"}]},{"title":"7 自制操作系统第七天","date":"2018-01-15T16:00:00.000Z","path":"2018/01/16/omake_7/","text":"项目地址 12345678主要内容：1. 获取按键编码（harib04a）2. 加快中断处理（harib04b）3. 制作FIFO缓冲区（harib04c）4. 改善FIFO缓冲区（harib04d）5. 整理FIFO缓冲区（harib04e）6. 激活鼠标（harib04f）7. 从鼠标获取数据（harib04g） 获取按键编码（harib04a）123456789101112131415#define PORT_KEYDAT 0x0060void inthandler21(int *esp)&#123; struct BOOTINFO *binfo = (struct BOOTINFO *) ADR_BOOTINFO; unsigned char data, s[4]; io_out8(PIC0_OCW2, 0x61); /* 通知 PIC &quot;IRQ-01&quot; 已经受理完成 */ data = io_in8(PORT_KEYDAT); sprintf(s, &quot;%02X&quot;, data); boxfill8(binfo-&gt;vram, binfo-&gt;scrnx, COL8_008484, 0, 16, 15, 31); putfonts8_asc(binfo-&gt;vram, binfo-&gt;scrnx, 0, 16, COL8_FFFFFF, s); return;&#125; io_out8(PIC0_OCW2, 0x61);这句话用来通知PIC“已经知发生了IRQ1中断”。如果是IRQ3，则写成0x63。也就是说将“0x60 + IRQ号码”输出给OCW2就可以。执行这句话之后，PIC继续时刻监视IRQ1中断是否发生。反过来，如果不执行这句话，PIC就不再监视IRQ1中断，不管下次由键盘输入什么信息，系统都感知不到了。 键按下去之后，随即就会显示出一个数字（十六进制）来，键松开之后也会显示一个数字。所以，计算机不光知道什么时候按下了键，还知道什么时候把键松开了。 加快中断处理（harib04b）所谓中断处理，基本上就是打算CPU本来的工作，加塞要求进行处理。而且中断处理进行期间，不在接受别的中断。所以如果处理键盘的中断速度太慢，就会出现鼠标的运动不连贯、不能从网上接受数据等情况。 那就现将按键的编码接收下来，保存到变量里，然后在主函数里偶尔去查看这个变量。如果发现有了数据，就把它显示出来。 123456789101112131415161718192021int.c文件中struct KEYBUF &#123; unsigned char data, flag;&#125;;#define PORT_KEYDAT 0x0060struct KEYBUF keybuf;void inthandler21(int *esp)&#123; unsigned char data; io_out8(PIC0_OCW2, 0x61); /* 通知 PIC &quot;IRQ-01&quot; 已经受理完成 */ data = io_in8(PORT_KEYDAT); if (keybuf.flag == 0) &#123; keybuf.data = data; keybuf.flag = 1; &#125; return;&#125; 123456789101112131415bootpack.c文件中for (;;) &#123; io_cli(); if (keybuf.flag == 0) &#123; io_stihlt(); &#125; else &#123; i = keybuf.data; keybuf.flag = 0; io_sti(); sprintf(s, &quot;%02X&quot;, i); boxfill8(binfo-&gt;vram, binfo-&gt;scrnx, COL8_008484, 0, 16, 15, 31); putfonts8_asc(binfo-&gt;vram, binfo-&gt;scrnx, 0, 16, COL8_FFFFFF, s); &#125;&#125; 小问题：这次按下键盘的右ctrl键，不管按下还是松开，屏幕上显示的都是“E0”在harib04a中的情况是，按下去是“1D”，松开时，显示是“9D” 当按下右ctrl键时，会产生两个字节的键码值“E0 1D”，而松开这个键之后，会产生两个字节的键码“E0 9D”。所以一次按键会产生两次中断，第一次中断时发送E0，第二次中断时发送1D。 harib04a中，两次中断发生的值都能收到，但是太快，所以接收的总是后面的编码，即1D和9Dharib04b中，由于太快，记录了第一个值之后，还没有显示，所以会把第二个值忽略，所以接收的总是第一个值，即E0和E0 制作FIFO缓冲区（harib04c）1234567891011121314151617181920int.c文件中struct KEYBUF &#123; unsigned char data[32]; int next;&#125;;struct KEYBUF keybuf;void inthandler21(int *esp)&#123; unsigned char data; io_out8(PIC0_OCW2, 0x61); data = io_in8(PORT_KEYDAT); if (keybuf.next &lt; 32) &#123; keybuf.data[keybuf.next] = data; keybuf.next++; &#125; return;&#125; 123456789101112131415161718bootpack.c文件中for (;;) &#123; io_cli(); if (keybuf.next == 0) &#123; io_stihlt(); &#125; else &#123; i = keybuf.data[0]; keybuf.next--; for (j = 0; j &lt; keybuf.next; j++) &#123; keybuf.data[j] = keybuf.data[j + 1]; &#125; io_sti(); sprintf(s, &quot;%02X&quot;, i); boxfill8(binfo-&gt;vram, binfo-&gt;scrnx, COL8_008484, 0, 16, 15, 31); putfonts8_asc(binfo-&gt;vram, binfo-&gt;scrnx, 0, 16, COL8_FFFFFF, s); &#125;&#125; 改善FIFO缓冲区（harib04d）1234567891011121314151617181920212223242526272829303132333435363738394041struct KEYBUF &#123; unsigned char data[32]; int next_r, next_w, len;&#125;;struct KEYBUF keybuf;void inthandler21(int *esp)&#123; unsigned char data; io_out8(PIC0_OCW2, 0x61); /* IRQ-01??t??????PIC???m */ data = io_in8(PORT_KEYDAT); if (keybuf.len &lt; 32) &#123; keybuf.data[keybuf.next_w] = data; keybuf.len++; keybuf.next_w++; if (keybuf.next_w == 32) &#123; keybuf.next_w = 0; &#125; &#125; return;&#125;for (;;) &#123; io_cli(); if (keybuf.len == 0) &#123; io_stihlt(); &#125; else &#123; i = keybuf.data[keybuf.next_r]; keybuf.len--; keybuf.next_r++; if (keybuf.next_r == 32) &#123; keybuf.next_r = 0; &#125; io_sti(); sprintf(s, &quot;%02X&quot;, i); boxfill8(binfo-&gt;vram, binfo-&gt;scrnx, COL8_008484, 0, 16, 15, 31); putfonts8_asc(binfo-&gt;vram, binfo-&gt;scrnx, 0, 16, COL8_FFFFFF, s); &#125;&#125; 整理FIFO缓冲区（harib04e）1234struct FIFO8 &#123; unsigned char *buf; int p, q, size, free, flags;&#125;; 缓冲区的总字节数保存在size里。变量free用于保存缓冲区里没有数据的字节数。缓冲区的地址保存在buf里。p（next_w）代表下一个数据写入，q（next_r）代表下一个数据读出地址。 1234567891011/* 初始化FIFO缓冲区 */void fifo8_init(struct FIFO8 *fifo, int size, unsigned char *buf)&#123; fifo-&gt;size = size; fifo-&gt;buf = buf; fifo-&gt;free = size; fifo-&gt;flags = 0; fifo-&gt;p = 0; fifo-&gt;q = 0; return;&#125; 1234567891011121314151617int fifo8_put(struct FIFO8 *fifo, unsigned char data)/* 向FIFO传送数据并保存 */&#123; if (fifo-&gt;free == 0) &#123; /* 溢出 将flags置为1 */ fifo-&gt;flags |= FLAGS_OVERRUN; return -1; &#125; fifo-&gt;buf[fifo-&gt;p] = data; fifo-&gt;p++; if (fifo-&gt;p == fifo-&gt;size) &#123; fifo-&gt;p = 0; &#125; fifo-&gt;free--; return 0;&#125; 12345678910111213141516int fifo8_get(struct FIFO8 *fifo)/* 从FIFO取得一个数据 */&#123; int data; if (fifo-&gt;free == fifo-&gt;size) &#123; /* 如果缓冲区为空，返回-1 */ return -1; &#125; data = fifo-&gt;buf[fifo-&gt;q]; fifo-&gt;q++; if (fifo-&gt;q == fifo-&gt;size) &#123; fifo-&gt;q = 0; &#125; fifo-&gt;free++; return data;&#125; 12345int fifo8_status(struct FIFO8 *fifo)/* 缓冲区存入的数据数量 */&#123; return fifo-&gt;size - fifo-&gt;free;&#125; 1234567891011int.c 文件中struct FIFO8 keyfifo;void inthandler21(int *esp)&#123; unsigned char data; io_out8(PIC0_OCW2, 0x61); data = io_in8(PORT_KEYDAT); fifo8_put(&amp;keyfifo, data); return;&#125; 1234567891011121314151617bootpack.c文件中char s[40], mcursor[256], keybuf[32];fifo8_init(&amp;keyfifo, 32, keybuf);for (;;) &#123; io_cli(); if (fifo8_status(&amp;keyfifo) == 0) &#123; io_stihlt(); &#125; else &#123; i = fifo8_get(&amp;keyfifo); io_sti(); sprintf(s, &quot;%02X&quot;, i); boxfill8(binfo-&gt;vram, binfo-&gt;scrnx, COL8_008484, 0, 16, 15, 31); putfonts8_asc(binfo-&gt;vram, binfo-&gt;scrnx, 0, 16, COL8_FFFFFF, s); &#125;&#125; 激活鼠标（harib04f）虽然在主板上做了鼠标用的电路，但只要不执行激活鼠标的指令，就不产生鼠标的中断信号。 如果想要使用鼠标，必须让两个装置有效，一个是鼠标控制电路，一个是鼠标本身。要先让鼠标控制电路有效，再让鼠标有效。 事实上，鼠标控制电路包含在键盘控制电路里，如果键盘控制电路的初始化正常完成，鼠标电路控制的激活也就完成了。 123456789101112131415161718192021222324252627282930bootpack.c 文件中#define PORT_KEYDAT 0x0060#define PORT_KEYSTA 0x0064#define PORT_KEYCMD 0x0064#define KEYSTA_SEND_NOTREADY 0x02#define KEYCMD_WRITE_MODE 0x60#define KBC_MODE 0x47void wait_KBC_sendready(void)&#123; /* 等待键盘控制电路准备完毕 */ for (;;) &#123; if ((io_in8(PORT_KEYSTA) &amp; KEYSTA_SEND_NOTREADY) == 0) &#123; break; &#125; &#125; return;&#125;void init_keyboard(void)&#123; /* 初始化键盘控制电路 */ wait_KBC_sendready(); io_out8(PORT_KEYCMD, KEYCMD_WRITE_MODE); wait_KBC_sendready(); io_out8(PORT_KEYDAT, KBC_MODE); return;&#125; 如果键盘控制电路可以接受CPU指令了，CPU从设备号码0x0064处所读取的数据的倒数第二位应该是0. init_keyboard，一边确认可否往键盘控制电路传送消息，一边发送指令。模式设定的指令是0x60，利用鼠标模式的模式号码是0x47。 123456789101112#define KEYCMD_SENDTO_MOUSE 0xd4#define MOUSECMD_ENABLE 0xf4void enable_mouse(void)&#123; /* 激活 */ wait_KBC_sendready(); io_out8(PORT_KEYCMD, KEYCMD_SENDTO_MOUSE); wait_KBC_sendready(); io_out8(PORT_KEYDAT, MOUSECMD_ENABLE); return;&#125; 如果往键盘控制电路发送指令0xd4，下一个数据就会自动发送给鼠标。鼠标收到激活指令以后，就会给CPU发送答复消息，这个消息就是0xfa。因为这个数据马上就跟着来了，即使我们保持鼠标不动，也一定会产生一个鼠标中断。 从鼠标获取数据（harib04g）123456789struct FIFO8 mousefifo;void inthandler2c(int *esp) &#123; unsigned char data; io_out8(PIC1_OCW2, 0x64); /* 通知PIC1 IRQ-12的受理已经完成 */ io_out8(PIC0_OCW2, 0x62); /* 通知PIC0 IRQ-02的受理已经完成 */ data = io_in8(PORT_KEYDAT); fifo8_put(&amp;mousefifo, data);&#125; 12345678910111213141516171819202122232425fifo8_init(&amp;mousefifo, 128, mousebuf);for (;;) &#123; io_cli(); if (fifo8_status(&amp;keyfifo) + fifo8_status(&amp;mousefifo) == 0) &#123; io_stihlt(); &#125; else &#123; if (fifo8_status(&amp;keyfifo) != 0) &#123; i = fifo8_get(&amp;keyfifo); io_sti(); sprintf(s, &quot;%02X&quot;, i); boxfill8(binfo-&gt;vram, binfo-&gt;scrnx, COL8_008484, 0, 16, 15, 31); putfonts8_asc(binfo-&gt;vram, binfo-&gt;scrnx, 0, 16, COL8_FFFFFF, s); &#125; else if (fifo8_status(&amp;mousefifo) != 0) &#123; i = fifo8_get(&amp;mousefifo); io_sti(); sprintf(s, &quot;%02X&quot;, i); boxfill8(binfo-&gt;vram, binfo-&gt;scrnx, COL8_008484, 32, 16, 47, 31); putfonts8_asc(binfo-&gt;vram, binfo-&gt;scrnx, 32, 16, COL8_FFFFFF, s); &#125; &#125;&#125;","tags":[{"name":"30天自制操作系统","slug":"30天自制操作系统","permalink":"http://yoursite.com/tags/30天自制操作系统/"},{"name":"按键编码","slug":"按键编码","permalink":"http://yoursite.com/tags/按键编码/"},{"name":"FIFO缓冲区","slug":"FIFO缓冲区","permalink":"http://yoursite.com/tags/FIFO缓冲区/"},{"name":"激活鼠标","slug":"激活鼠标","permalink":"http://yoursite.com/tags/激活鼠标/"}]},{"title":"6 自制操作系统第六天","date":"2018-01-13T16:00:00.000Z","path":"2018/01/14/omake_6/","text":"项目地址 harib03a（分割源文件）graphic.c 关于描述画面的处理dsctbl.c 关于GDT，IDT等 descriptor table的处理bootpack.c 主要调用 harib03b（Makefile智能化）12345678%.gas : %.c Makefile $(CC1) -o $*.gas $*.c%.nas : %.gas Makefile $(GAS2NASK) $*.gas $*.nas%.obj : %.nas Makefile $(NASK) $*.nas $*.obj $*.lst harib03c（整理头文件）把所有的函数声明、结构体定义、宏定义都放在bootpach.h中，然后在其他的c文件中应用“include bootpack.h”就可以调用里面的所有东西。 编译器见到“include bootpack.h”这一行，就将该行替换成所指定文件的内容，然后进行编译。 前一天的问题12345_load_gdtr: ; void load_gdtr(int limit, int addr); MOV AX,[ESP+4] ; limit MOV [ESP+6],AX LGDT [ESP+6] RET 这个函数用来将制定的端上限和地址值赋值给名为GDTR的48位寄存器。不能使用MOV指令来赋值，只能用LGDT这个命令，从制定的地址读取6个字节，赋值给GDTR寄存器。 该寄存器的低16位是段上限，它等于“GDT的有效字节数-1”。剩下的高32位，该表GDT的开始地址。 DWORD[ESP + 4]里存放的是段上限，DWORD[ESP + 8]里存放的是地址。 具体到实际的数值，就是0x0000ffff和0x00270000。把它们按字节写出来的话，就成了[FF FF 00 00 00 00 27 00] (低位放在内存地址小的字节里，右边的为低位，左边的为高位) 为了执行LGDT，我们希望把它们排列成[FF FF 00 00 27 00]，先用”MOV AX,[ESP + 4]” AX里面的数据是[FF FF]，然后”MOV [ESP + 6], AX”。然后结果就变成了[FF FF FF FF 00 00 27 00]，然后[ESP + 6]开始读6个字节的话，就是[FF FF 00 00 27 00] 1234567891011121314151617181920struct SEGMENT_DESCRIPTOR &#123; short limit_low, base_low; char base_mid, access_right; char limit_high, base_high;&#125;;void set_segmdesc(struct SEGMENT_DESCRIPTOR *sd, unsigned int limit, int base, int ar)&#123; if (limit &gt; 0xfffff) &#123; ar |= 0x8000; /* G_bit = 1 */ limit /= 0x1000; &#125; sd-&gt;limit_low = limit &amp; 0xffff; sd-&gt;base_low = base &amp; 0xffff; sd-&gt;base_mid = (base &gt;&gt; 16) &amp; 0xff; sd-&gt;access_right = ar &amp; 0xff; sd-&gt;limit_high = ((limit &gt;&gt; 16) &amp; 0x0f) | ((ar &gt;&gt; 8) &amp; 0xf0); sd-&gt;base_high = (base &gt;&gt; 24) &amp; 0xff; return;&#125; 段的信息有三部分：1.段的大小2.段的起始地址3.段的管理属性（进制写入，进制执行，系统专用等） （1）段地址段的地址是用32位来表示。这个结构体里base又分为low（2字节），mid（1字节），high（1字节）3段。 为什么要分为3段？主要为了与80286时代的程序兼容。有了这样的规格，80286用的操作系统，也可以不用修改就在386以后的CPU上运行。 （2）段上限段上限使用20位。也就是最大指定到1MB。在段的属性里有个标志位，叫做Gbit。这个标志位是1的时候，limit的单位不解释成字节，而解释成页。1页指4KB。这样的话就是1MB * 4KB = 4GB 20位的段上限分别写到limit_low 和 limit_high里。看起来它们好像是总共有3字节，但实际上我们接着要把段属性写入limit_high的高4位里，所以段上限还是只有20。 （3）段属性在程序中用变量名access_right或ar来表示。12位段属性中的高4位放在limit_high的高4位里。xxxx0000xxxxxxxx ar的高4位被称为“扩展访问权”。这高4位的访问属性在80286的时代还不存在，到386以后才可以使用。这4位由“GD00”构成的，其中G是G bit，D是指段的模式，1是指32位模式，0是指16位模式。 ar的低8位从80286时代就已经有了，这里只是简单介绍一下。00000000（0x00）：未使用的记录表10010010（0x92）：系统专用，可读写的段。不可执行。10011010（0x9a）：系统专用，可执行的段。可读不可写。11110010（0xf2）：应用程序用，可读写的段。不可执行。11111010（0xfa）：应用程序用，可执行的段。可读不可写。 harib03d（初始化PIC）PIC就是“programmable interrupt controller”的缩写。PIC是将8个中断信号（interrupt reque 缩写为IRQ）集合成一个中断信号的装置。PIC监视着输入管脚的8个中断信号，只要有一个中断信号进来，就将唯一的输出管脚信号变为on，并通知给CPU。 与CPU直接相连的PIC称为主PIC，与主PIC相连的PIC称为从PIC。主PIC负责处理第0到第7号中断信号，从PIC负责处理第8到第15号中断信号。从PIC通过第2号IRQ与主PIC相连。 123456789101112131415161718192021void init_pic(void)/* PICの初期化 */&#123; io_out8(PIC0_IMR, 0xff ); /* 禁止所有中断 */ io_out8(PIC1_IMR, 0xff ); /* 禁止所有中断 */ io_out8(PIC0_ICW1, 0x11 ); /* 边沿触发模式 */ io_out8(PIC0_ICW2, 0x20 ); /* IRQ0~7由INT20~27接收 */ io_out8(PIC0_ICW3, 1 &lt;&lt; 2); /* PIC1由IRQ2连接 */ io_out8(PIC0_ICW4, 0x01 ); /* 无缓冲模式 */ io_out8(PIC1_ICW1, 0x11 ); /* 边沿触发模式 */ io_out8(PIC1_ICW2, 0x28 ); /* IRQ8-15由INT28-2f接收 */ io_out8(PIC1_ICW3, 2 ); /* PIC1由IRQ2连接 */ io_out8(PIC1_ICW4, 0x01 ); /* 无缓冲模式 */ io_out8(PIC0_IMR, 0xfb ); /* 11111011 PIC1以外全部禁止 */ io_out8(PIC1_IMR, 0xff ); /* 11111111 禁止所有中断 */ return;&#125; PIC的寄存器都是8位寄存器。IMR是“interrupt mask register”，意思是“中断屏蔽寄存器”，8位分别对应8路IRQ信号，如果某一位的值是1，则该对应的IRQ信号被屏蔽，PIC就忽视改路信号。 ICW是“initial control word”的缩写，意思是“初始化控制数据”。 ICW有4个分别编号为1~4，共有4个字节的数据。 ICW1和ICW4设定的都是固定值，不做说明。 ICW3是有关主从连接的设定，对主PIC而言，第几号IRQ与从PIC相连，使用8位来设定的，如果把这些为全部设为1，那么主PIC就能驱动8个从PIC（那样的话，最大可能就是有64个IRQ）。另外对于从PIC来说，该从PIC与主PIC的第几号相连，用3位设定。 ICW2，决定了IRQ以哪一号中断通知CPU。 这次是以INT 0x20~0x2f接收中断信号IRQ0~IRQ15设定的。 harib03e（中断处理程序的制作）鼠标是IRQ12，键盘是IRQ1。 12345678910void inthandler21(int *esp)/* 来自键盘的中断 */&#123; struct BOOTINFO *binfo = (struct BOOTINFO *) ADR_BOOTINFO; boxfill8(binfo-&gt;vram, binfo-&gt;scrnx, COL8_000000, 0, 0, 32 * 8 - 1, 15); putfonts8_asc(binfo-&gt;vram, binfo-&gt;scrnx, 0, 0, COL8_FFFFFF, &quot;INT 21 (IRQ-1) : PS/2 keyboard&quot;); for (;;) &#123; io_hlt(); &#125;&#125; 12345678910111213141516171819naskfunc.nas文件里面EXTERN _inthandler21_asm_inthandler21: PUSH ES PUSH DS PUSHAD MOV EAX,ESP PUSH EAX MOV AX,SS MOV DS,AX MOV ES,AX CALL _inthandler21 POP EAX POPAD POP DS POP ES IRETD 中断处理后，不能使用RET，必须使用IRETD PUSH EAX这个指令，相当于：ADD ESP, -4MOV [SS:ESP], EAX POP EAX这个指令，相当于：MOV EAX, [SS:ESP]ADD ESP, 4 PUSHAD 相当于：PUSH EAXPUSH ECXPUSH EDXPUSH EBXPUSH ESPPUSH EBPPUSH ESIPUSH EDI 这个函数只是将寄存器的值保存到栈中，然后将DS和ES调整到SS相等，在调用_inthandler21，返回之后，将所有寄存器的值在返回到原来的值，然后执行IRETD。 C语言认为“DS也好，ES也好，SS也好，它们都是指的同一个段”，如果不这样设定的话，函数inthandler21不能顺利执行。 12set_gatedesc(idt + 0x21, (int) asm_inthandler21, 2 * 8, AR_INTGATE32);set_gatedesc(idt + 0x2c, (int) asm_inthandler2c, 2 * 8, AR_INTGATE32); asm_inthandler21注册在idt的第0x21号。这样，如果发生中断了，CPU就会自动调用asm_inthandler21。这里的2*8表示的是asm_inthandler21属于哪一个段，即段号2，乘以8是因为低3位有着别的意思，这里低3位必须是0。也可以写成2&lt;&lt;3。 断号位2的段正好涵盖了整个bootpack.hrb 最后的AR_INTGATE32将IDT的属性设定为0x88e。表示用于中断处理的有效设定。","tags":[{"name":"30天自制操作系统","slug":"30天自制操作系统","permalink":"http://yoursite.com/tags/30天自制操作系统/"},{"name":"文件分割","slug":"文件分割","permalink":"http://yoursite.com/tags/文件分割/"},{"name":"GDT","slug":"GDT","permalink":"http://yoursite.com/tags/GDT/"},{"name":"PIC","slug":"PIC","permalink":"http://yoursite.com/tags/PIC/"},{"name":"中断处理","slug":"中断处理","permalink":"http://yoursite.com/tags/中断处理/"},{"name":"汇编中的栈","slug":"汇编中的栈","permalink":"http://yoursite.com/tags/汇编中的栈/"}]},{"title":"5 自制操作系统第五天","date":"2017-12-01T16:00:00.000Z","path":"2017/12/02/omake_5/","text":"项目地址 harib02a123456789101112131415161718192021void HariMain(void)&#123; char *vram; int xsize, ysize; short *binfo_scrnx, *binfo_scrny; int *binfo_vram; init_palette(); binfo_scrnx = (short *) 0x0ff4; binfo_scrny = (short *) 0x0ff6; binfo_vram = (int *) 0x0ff8; xsize = *binfo_scrnx; ysize = *binfo_scrny; vram = (char *)*binfo_vram; init_screen(vram, xsize, ysize); for (;;) &#123; io_hlt(); &#125;&#125; harib02b123456789101112131415161718192021222324struct BOOTINFO &#123; char cyls, leds, vmode, reserve; short scrnx, scrny; char *vram;&#125;;void HariMain(void)&#123; char *vram; int xsize, ysize; struct BOOTINFO *binfo; init_palette(); binfo = (struct BOOTINFO *)0x0ff0; xsize = (*binfo).scrnx; ysize = (*binfo).scrny; vram = (*binfo).vram; init_screen(vram, xsize, ysize); for (;;) &#123; io_hlt(); &#125;&#125; struct命令只是把一串变量生命起来，统一叫做“struct BOOTINFO”，最初的1字节的变量cyls，接着是1字节的leds，照此下去，一直到vram。这一串变量一共是12字节。 binfo表示指针变量。地址用4个字节来表示，所以binfo是4字节变量。而*binfo来表示内存地址上12字节的结构体。 harib02c123456789101112131415161718使用箭头记号(*binfo).scrnx和binfo-&gt;vram的意思相同void HariMain(void)&#123; char *vram; int xsize, ysize; struct BOOTINFO *binfo; init_palette(); binfo = (struct BOOTINFO *)0x0ff0; init_screen(binfo-&gt;vram, binfo-&gt;scrnx, binfo-&gt;scrny); for (;;) &#123; io_hlt(); &#125;&#125; harib02d1234567891011121314151617181920212223242526272829303132333435363738394041424344...........**......**......**......**.....*..*....*..*....*..*....*..*...******..*....*..*....*..*....*.***..***................点代表0，星代表1。用代码表示就是static char font_A[16] = &#123; 0x00, 0x18, 0x18, 0x18, 0x18, 0x24, 0x24, 0x24, 0x24, 0x7e, 0x42, 0x42, 0x42, 0xe7, 0x00, 0x00&#125;;void putfont8(char *vram, int xsize, int x, int y, char c, char *font) &#123; int i; char *p, d; /* d 表示 data */ for (i = 0; i &lt; 16; i++) &#123; p = vram + (y + i) * xsize + x; /* *p = vram[(y+i)*xsize)+x] */ d = font[i]; if ((d &amp; 0x80) != 0) &#123; p[0] = c;&#125; if ((d &amp; 0x40) != 0) &#123; p[1] = c;&#125; if ((d &amp; 0x20) != 0) &#123; p[2] = c;&#125; if ((d &amp; 0x10) != 0) &#123; p[3] = c;&#125; if ((d &amp; 0x08) != 0) &#123; p[4] = c;&#125; if ((d &amp; 0x04) != 0) &#123; p[5] = c;&#125; if ((d &amp; 0x02) != 0) &#123; p[6] = c;&#125; if ((d &amp; 0x01) != 0) &#123; p[7] = c;&#125; &#125; return;&#125; harib02e显示更多的字符，有一个hankaku.txt，这个文本里面包含了一些字符。里面有256个字符，16*256=4096个字节。将这个文件编译生成hankaku.bin文件，再变成目标文件，再和bootpack.obj连接。 在c语言汇总使用这种字体数据，只需要写上一下语句就可以了。extern char hankaku[4096]; hankaku里面的字体按照一般的ASCII字符编码。A的字符编码就是0x41，所以以A的字体数据，放在自“hankaku + 0x41 16”开始的16字节里。C语言中A的字符编码可以用‘A’来表示，可以写成“hankaku + ‘A’ 16” 1234567891011121314151617181920void HariMain(void)&#123; struct BOOTINFO *binfo = (struct BOOTINFO *)0x0ff0; extern char hankaku[4096]; init_palette(); init_screen(binfo-&gt;vram, binfo-&gt;scrnx, binfo-&gt;scrny); putfont8(binfo-&gt;vram, binfo-&gt;scrnx, 8, 8, COL8_FFFFFF, hankaku + &apos;A&apos; * 16); putfont8(binfo-&gt;vram, binfo-&gt;scrnx, 16, 8, COL8_FFFFFF, hankaku + &apos;B&apos; * 16); putfont8(binfo-&gt;vram, binfo-&gt;scrnx, 24, 8, COL8_FFFFFF, hankaku + &apos;C&apos; * 16); putfont8(binfo-&gt;vram, binfo-&gt;scrnx, 40, 8, COL8_FFFFFF, hankaku + &apos;1&apos; * 16); putfont8(binfo-&gt;vram, binfo-&gt;scrnx, 48, 8, COL8_FFFFFF, hankaku + &apos;2&apos; * 16); putfont8(binfo-&gt;vram, binfo-&gt;scrnx, 56, 8, COL8_FFFFFF, hankaku + &apos;3&apos; * 16); for (;;) &#123; io_hlt(); &#125;&#125; harib02f123456789101112131415161718192021222324252627void putfonts8_asc(char *vram, int xsize, int x, int y, char c, unsigned char *s) &#123; extern char hankaku[4096]; for (; *s != 0x00; s++) &#123; putfont8(vram, xsize, x, y, c, hankaku + *s * 16); x += 8; &#125; return;&#125;void HariMain(void)&#123; struct BOOTINFO *binfo = (struct BOOTINFO *)0x0ff0; init_palette(); init_screen(binfo-&gt;vram, binfo-&gt;scrnx, binfo-&gt;scrny); putfonts8_asc(binfo-&gt;vram, binfo-&gt;scrnx, 8, 8, COL8_FFFFFF, &quot;ABC 123&quot;); putfonts8_asc(binfo-&gt;vram, binfo-&gt;scrnx, 31, 31, COL8_000000, &quot;Haribote OS.&quot;); putfonts8_asc(binfo-&gt;vram, binfo-&gt;scrnx, 30, 30, COL8_FFFFFF, &quot;Haribote OS.&quot;); for (;;) &#123; io_hlt(); &#125;&#125; C语言中都是以0x00结尾的。 harib02g123char s[40];sprintf(s, &quot;scrnx = %d&quot;, binfo-&gt;scrnx);putfonts8_asc(binfo-&gt;vram, binfo-&gt;scrnx, 16, 64, COL8_FFFFFF, s); sprintf函数是输出字符串的方法，sprintf(地址, 格式, 数值, 数值, 数值, ……) harib02h1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556显示鼠标void init_mouse_cursor8(char *mouse, char bc) &#123; static char cursor[16][16] = &#123; &quot;**************..&quot;, &quot;*OOOOOOOOOOO*...&quot;, &quot;*OOOOOOOOOO*....&quot;, &quot;*OOOOOOOOO*.....&quot;, &quot;*OOOOOOOO*......&quot;, &quot;*OOOOOOO*.......&quot;, &quot;*OOOOOOO*.......&quot;, &quot;*OOOOOOOO*......&quot;, &quot;*OOOO**OOO*.....&quot;, &quot;*OOO*..*OOO*....&quot;, &quot;*OO*....*OOO*...&quot;, &quot;*O*......*OOO*..&quot;, &quot;**........*OOO*.&quot;, &quot;*..........*OOO*&quot;, &quot;............*OO*&quot;, &quot;.............***&quot; &#125;; int x, y; for (y = 0; y &lt; 16; y++) &#123; for (x = 0; x &lt; 16; x++) &#123; if (cursor[y][x] == &apos;*&apos;) &#123; mouse[y * 16 + x] = COL8_000000; &#125; if (cursor[y][x] == &apos;O&apos;) &#123; mouse[y * 16 + x] = COL8_FFFFFF; &#125; if (cursor[y][x] == &apos;.&apos;) &#123; mouse[y * 16 + x] = bc; &#125; &#125; &#125; return;&#125;void putblock8_8(char *vram, int vxsize, int pxsize, int pysize, int px0, int py0, char *buf, int bxsize) &#123; int x, y; for (y = 0; y &lt; pysize; y++) &#123; for (x = 0; x &lt; pxsize; x++) &#123; vram[(py0 + y) * vxsize + (px0 + x)] = buf[y * bxsize + x]; &#125; &#125; return;&#125;init_mouse_cursor8(mcursor, COL8_008484);putblock8_8(binfo-&gt;vram, binfo-&gt;scrnx, 16, 16, mx, my, mcursor, 16); harib02i鼠标指针显示出来了，我们想做的第一件事情就是去移动它，但鼠标一动不动。 GDT是“global descriptor table”的缩写，意思是全局段号记录表。将这些整齐的排列在内存的某个地方，然后将内存的其实地址和有效设定个数放在CPU内被称作GDTR的特殊寄存器中，设定就完成了。 IDT使“interrupt descriptor table”的缩写，直译过来就是“中断记录表”。","tags":[{"name":"30天自制操作系统","slug":"30天自制操作系统","permalink":"http://yoursite.com/tags/30天自制操作系统/"},{"name":"结构体","slug":"结构体","permalink":"http://yoursite.com/tags/结构体/"},{"name":"字符显示","slug":"字符显示","permalink":"http://yoursite.com/tags/字符显示/"}]},{"title":"4 自制操作系统第四天","date":"2017-11-30T16:00:00.000Z","path":"2017/12/01/omake_4/","text":"项目地址 harib01a12345_write_mem8: ; void write_mem8(int addr, int data) MOV ECX, [ESP+4] MOV AL, [ESP+8] MOV [ECX], AL RET 这个函数类似于C语言中的“write_mem8(0x1234, 0x56);”语句，动作上相当于“MOV BYTE[0x1234], 0x56”。 在C语言用到了write_mem8函数，就会跳转到_write_mem8。此时参数指定的数字就存放到内存里，分别是：第一个数字存放的地址是：[ESP + 4]第一个数字存放的地址是：[ESP + 8]第一个数字存放的地址是：[ESP + 12]第一个数字存放的地址是：[ESP + 16]一次类推…… 如果与C语言联合使用的话，有的寄存器不能自由使用，能自由使用的只有EAX、ECX、EDX这个3个。 [INSTRSET “i486p”]，INSTRSET这个指令告诉nask“这个程序是给468用的”，如果不指定，它就会认为那是为8086这种16位寄存器的CPU而写的程序，见了EAX这个词，会误解成标签，或是常数。 虽然写着是486使用，但并不是会出现仅能486中执行的机器语言。所以486用的模式下，如果只使用16位寄存器，也能成为在8086中亦可执行的机器语言。 英特尔系列家谱 1238086-&gt;80186-&gt;286-&gt;386-&gt;486-&gt;Pentium-&gt;PentiumPro-&gt;PentiumⅡ -&gt;PentiumⅢ-&gt;Pentium4-&gt;……到286为止 CPU是16位，386以后CPU是32位 123456789101112131415161718bootpack.c内容void io_hlt(void);void write_mem8(int addr, int data);void HariMain(void)&#123; int i; for (i = 0xa0000; i &lt;= 0xaffff; i++) &#123; write_mem8(i, 15); &#125; for (;;) &#123; io_hlt(); &#125;&#125; 画面是白屏，因为VRAM全部都写入了15，意思是全部像素的颜色都是第15种颜色，而第15种颜色碰巧是纯白。 harib01b12345显示有条纹的图案for (i = 0xa0000; i &lt;= 0xaffff; i++) &#123; write_mem8(i, i &amp; 0x0f);&#125; &amp; 是与运算，也叫按位与。 写入的值为：00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 00 01 02 03 04 05 06 ……上面的操作，每隔16个像素，色号就反复一次。 harib01cchar p; 用于BYTE类地址short p; 用于WORD类地址int *p; 用于DWORd地址 “char i; ”类似AL的1字节变量，“short i”类似于AX的2字节变量，“int i”类似EAX的4字节变量 不管是“char p”，还是“short p”，还是“int *p”，变量p都是4字节。这是因为是用于记录地址的变量。在汇编语言中，地址也像ECX一样，用4字节的寄存器来指定，也是4字节。 1234567891011121314151617void HariMain(void)&#123; int i; char* p; for (i = 0xa0000; i &lt;= 0xaffff; i++) &#123; p = (char*) i; /* 强转 */ *p = i &amp; 0x0f; /*不用write_mem8也可以显示条纹图案*/ &#125; for (;;) &#123; io_hlt(); &#125;&#125; 123456p = (char *) i; *p = i &amp; 0x0f; *((char *) i) = i &amp; 0x0f; 有没有这种写法与“BYTE[i] = i &amp; 0x0f”有些相像呢？“char *”相当于“BYTE”“*()”相当于“[]” 12345678MOV BYTE[i], (i &amp; 0x0f)int i;char *p;p = (char *) i;*p = i &amp; 0x0f;上面四行是MOV语句的替代物 12345678p = (char *) i;*p = i &amp; 0x0f;假设p是ECX，那么写出来的就是：MOV ECX, iMOV BYTE [ECX], (i &amp; 0x0f)第一个是给ECX寄存器赋值，第二个是给内存地址赋值。 12345*p不是一个变量，变量只有p。所谓*p，就相当于汇编汇总BYTE[p]这种语句的替代物char *p, q; c编译器会把q看做是一般的1字节的变量。如果想要声明两个地址变量，就写成char *p, *q; harib01d1234p = (char*) 0xa0000;for (i = 0; i &lt;= 0xaffff; i++) &#123; *(p + i) = i &amp; 0x0f;&#125; harib01e1234p = (char*) 0xa0000;for (i = 0; i &lt;= 0xaffff; i++) &#123; p[i] = i &amp; 0x0f;&#125; 1234567p[i] 和 *(p + i)意思完全相同。*(p + i)是6个字符，而p[i]只有4个字符，区别只有这一点。当然，p[0]写成*p，反倒会节省2个字符。加法顺序可以交换顺序，所以将*(p + i)写成*(i + p)也是可以的。同理，将p[i]写成i[p]也是可以的。a[2]也可以写成2[a]。 harib01f 色号使用8位二进制数，也就是只能使用0~255的数。一般颜色都是用#ffffff一类的数来表示的。这是RGB（红绿蓝方式），用3个字节表示。8位数完全不够，那么该方式怎么指定#ffffff方式的颜色呢？ 这个8位彩色模式，是由程序员随意指定0~255的数字所对应的颜色的。比如说25号颜色对应#ffffff，26号对应#123456等。这种方式叫做调色板(palette) 设定16种颜色，并编上号码0~1512345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667void io_hlt(void);void io_cli(void);void io_out8(int port, int data);int io_load_eflags(void);void io_store_eflags(int eflags);void init_palette(void);void set_palette(int start, int end, unsigned char *rgb);void HariMain(void)&#123; int i; char* p; init_palette(); p = (char*) 0xa0000; for (i = 0; i &lt;= 0xaffff; i++) &#123; p[i] = i &amp; 0x0f; &#125; for (;;) &#123; io_hlt(); &#125;&#125;void init_palette(void) &#123; static unsigned char table_rgb[16 * 3] = &#123; 0x00, 0x00, 0x00, /* 0:黑 */ 0xff, 0x00, 0x00, /* 1:亮红 */ 0x00, 0xff, 0x00, /* 2:亮绿 */ 0xff, 0xff, 0x00, /* 3:亮黄 */ 0x00, 0x00, 0xff, /* 4:亮蓝 */ 0xff, 0x00, 0xff, /* 5:亮紫 */ 0x00, 0xff, 0xff, /* 6:浅亮蓝 */ 0xff, 0xff, 0xff, /* 7:白 */ 0xc6, 0xc6, 0xc6, /* 8:亮灰 */ 0x84, 0x00, 0x00, /* 9:暗红 */ 0x00, 0x84, 0x00, /* 10:暗绿 */ 0x84, 0x84, 0x00, /* 11:暗黄 */ 0x00, 0x00, 0x84, /* 12:暗青 */ 0x84, 0x00, 0x84, /* 13:暗紫 */ 0x00, 0x84, 0x84, /* 14:浅暗蓝 */ 0x84, 0x84, 0x84 /* 15:暗灰 */ &#125;; set_palette(0, 15, table_rgb); return;&#125;void set_palette(int start, int end, unsigned char *rgb) &#123; int i, eflags; eflags = io_load_eflags(); /* 记录中断许可标志的值 */ io_cli(); /*将中断许可标志设置为0，禁止中断*/ io_out8(0x03c8, start); for (i = start; i &lt;= end; i++) &#123; io_out8(0x03c9, rgb[0] / 4); /* 为什么除以4? */ io_out8(0x03c9, rgb[1] / 4); io_out8(0x03c9, rgb[2] / 4); rgb += 3; &#125; io_store_eflags(eflags); /* 复原中断标志许可标志*/ return;&#125; 123456char a[3];相当于汇编语言中的a: RESB 3a意味着地址。a就是一个地址变量，也就是所谓的指针。 char型的变量有3中模式，分别是signed型、unsigned型和未指定型。signed用于处理-128~127的整数。unsigned型能够处理0~255的整数。未指定型由编译器决定是unsigned还是signed。 CPU与设备相连，那么就有向这些设备发送电信号，或者从这些设备取得信息的指令。向设备发送电信号的是OUT指令，从设备取得电信号的是IN指令。为了区别不同的设备，要使用设备号码。设备号码在英文汇总被称为port。prot愿意是港口，这里形象地将CPU与各个设备交换电信号的行为比作了船舶的出港和进港。 12345调色板的访问步骤首先在一连串的访问中屏蔽中断（CLI）将要设定的调色板号码写入0x03c8，紧接着，按R，G，B的顺序写入0x03c9。如果还想设定下一个调色板，则省略调色板号码。如果想要独处当前调色板的状态，首先要将调色板的号码写入0x03c7，再从0x03c9读取3次。读出的顺序就是R，G，B。如果要继续读出下一个调色板，同样也是省略调色码的设定，按RGB的顺序读出。如果执行了CLI，那么最好要执行STL。 CLI（clean interrupt flag）是将中断标志置为0的指令，STI（set interrupt flag）是将中断标志置为1的指令。如果中断标志位位1，当CPU遇到中断请求时，会立即处理中断请求；如果中断标志位位0，那么中断请求将被忽略。 12io_load_eflags:读取最初的eflags值io_store_eflags:恢复最初的eflags值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485; naskfunc; TAB=4[FORMAT &quot;WCOFF&quot;] ; 制作目标文件的模式 [BITS 32] ; 制作32位模式用的机器语言[INSTRSET &quot;i486p&quot;] ; 使用到486为止的指令[FILE &quot;naskfunc.nas&quot;] ; 源文件名信息; 制作目标文件的信息 GLOBAL _io_hlt, _io_cli, _io_sti, io_stihlt ; 程序中包含的函数名 GLOBAL _io_in8, _io_in16, _io_in32 GLOBAL _io_out8, _io_out16, _io_out32 GLOBAL _io_load_eflags, _io_store_eflags; 以下是实际的函数[SECTION .text] ; 目标文件中写了这些之后再写程序_io_hlt: ; void io_hlt(void); HLT RET_io_cli: CLI RET_io_sti: STI RET_io_stihlt: STI HLT RET_io_in8: MOV EDX, [ESP+4] ; port MOV EAX, 0 IN AL, DX RET_io_in16: MOV EDX, [ESP+4] ; port MOV EAX, 0 IN AX, DX RET_io_in32: MOV EDX, [ESP+4] ; port IN EAX, DX RET_io_out8: MOV EDX, [ESP+4] MOV AL, [ESP+8] OUT DX, AL RET_io_out16: MOV EDX, [ESP+4] MOV AL, [ESP+8] OUT DX, AX RET_io_out32: MOV EDX, [ESP+4] MOV AL, [ESP+8] OUT DX, EAX RET _io_load_eflags: PUSHFD ; 指的是push eflags POP EAX RET_io_store_eflags: MOV EAX, [ESP+4] PUSH EAX POPFD ; 指的是pop eflags RET 没有“MOV EAX, EFLAGS”之类的指令，所以只能用PUSHFD和POPFD指令。 PUSHFD是“push flags double-word”的缩写，意思将标志位的值按照双字节压入栈。其实它所做的，无非就是“PUSH EFLAGS”。POPFD是“pop flags double-word”的缩写，意思是按双字节将标志位从栈弹出。他所做的就是“POP EFLAGS”。 “PUSHFD POP EAX”相当于“MOV EAX, EFLAGS”。“PUSH EAX POPFD”相当于“MOV EFLAGS, EAX”。 1io_load_eflags，执行RET语句时，EAX中的值被看做函数的返回值。 harib01g画面上有320200个像素，假设左上点的坐标是(0, 0)，右下点的坐标是(319, 319)，那么像素坐标(x, y)对应VRAM地址应按下式计算。0xa0000 + x + y 320其他画面模式也相同，只是0xa0000这个其实地址和y的系数320有些不同。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546画矩形#define COL8_000000 0 /* 0:黑 */#define COL8_ff0000 1 /* 1:亮红 */#define COL8_00ff00 2 /* 2:亮绿 */#define COL8_ffff00 3 /* 3:亮黄 */#define COL8_0000ff 4 /* 4:亮蓝 */#define COL8_ff00ff 5 /* 5:亮紫 */#define COL8_00ffff 6 /* 6:浅亮蓝 */#define COL8_ffffff 7 /* 7:白 */#define COL8_c6c6c6 8 /* 8:亮灰 */#define COL8_840000 9 /* 9:暗红 */#define COL8_008400 10 /* 10:暗绿 */#define COL8_848400 11 /* 11:暗黄 */#define COL8_000084 12 /* 12:暗青 */#define COL8_840084 13 /* 13:暗紫 */#define COL8_008484 14 /* 14:浅暗蓝 */#define COL8_848484 15 /* 15:暗灰 */void HariMain(void)&#123; int i; char* p; init_palette(); p = (char*) 0xa0000; boxfill8(p, 320, COL8_ff0000, 20, 20, 120, 120); boxfill8(p, 320, COL8_00ffff, 70, 50, 170, 150); boxfill8(p, 320, COL8_ffff00, 120, 80, 220, 180); for (;;) &#123; io_hlt(); &#125;&#125;void boxfill8(unsigned char *vram, int xsize, unsigned char c, int x0, int y0, int x1, int y1) &#123; int x, y; for (y = y0; y &lt;= y1; y++) &#123; for (x = x0; x &lt;= x1; x++) &#123; vram[y * xsize + x] = c; &#125; &#125;&#125; harib01f123456789101112131415161718192021222324252627282930313233画任务条(task bar)void HariMain(void)&#123; char *vram; int xsize, ysize; init_palette(); vram = (char*) 0xa0000; xsize = 320; ysize = 200; boxfill8(vram, xsize, COL8_008484, 0, 0, xsize - 1, ysize - 29); boxfill8(vram, xsize, COL8_C6C6C6, 0, ysize - 28, xsize - 1, ysize - 28); boxfill8(vram, xsize, COL8_FFFFFF, 0, ysize - 27, xsize - 1, ysize - 27); boxfill8(vram, xsize, COL8_C6C6C6, 0, ysize - 26, xsize - 1, ysize - 1); boxfill8(vram, xsize, COL8_FFFFFF, 3, ysize - 24, 59, ysize - 24); boxfill8(vram, xsize, COL8_FFFFFF, 2, ysize - 24, 2, ysize - 4); boxfill8(vram, xsize, COL8_848484, 3, ysize - 4, 59, ysize - 4); boxfill8(vram, xsize, COL8_848484, 59, ysize - 23, 59, ysize - 5); boxfill8(vram, xsize, COL8_000000, 2, ysize - 3, 59, ysize - 3); boxfill8(vram, xsize, COL8_000000, 60, ysize - 24, 60, ysize - 3); boxfill8(vram, xsize, COL8_848484, xsize - 47, ysize - 24, xsize - 4, ysize - 24); boxfill8(vram, xsize, COL8_848484, xsize - 47, ysize - 23, xsize - 47, ysize - 4); boxfill8(vram, xsize, COL8_FFFFFF, xsize - 47, ysize - 3, xsize - 4, ysize - 3); boxfill8(vram, xsize, COL8_FFFFFF, xsize - 3, ysize - 24, xsize - 3, ysize - 3); for (;;) &#123; io_hlt(); &#125;&#125;","tags":[{"name":"30天自制操作系统","slug":"30天自制操作系统","permalink":"http://yoursite.com/tags/30天自制操作系统/"},{"name":"内存","slug":"内存","permalink":"http://yoursite.com/tags/内存/"},{"name":"指针","slug":"指针","permalink":"http://yoursite.com/tags/指针/"},{"name":"显示颜色","slug":"显示颜色","permalink":"http://yoursite.com/tags/显示颜色/"}]},{"title":"3 自制操作系统第三天","date":"2017-11-27T16:00:00.000Z","path":"2017/11/28/omake_3/","text":"项目地址 因为磁盘的最初的512字节是启动盘，所以要装载下一个512字节的内容。 harib00a12345678910111213本次要添加的部分MOV AX, 0x0820MOV ES, AXMOV CH, 0 ; 柱面0MOV DH, 0 ; 磁头0MOV CL, 2 ; 扇区2MOV AH, 0x02 ; AH = 0x02 : 读盘MOV AL, 1 ; 1个扇区MOV BX, 0 ; MOV DL, 0x00 ; A驱动器INT 0x13 ; 调用磁盘BIOSJC error JC，是”jump if carry”的缩写，如果进位标志位是1的话，就跳转。 1234567891011121314151617磁盘读、写、扇区校验，以及寻道 AH = 0x02; （读盘） AH = 0x03; （写盘） AH = 0x04; （校验） AH = 0x0c; （寻道） AL = 处理对象的扇区数;（只能同时处理连续的扇区） CH = 柱面号 &amp; 0xff; CL = 扇区号（0~5）|（柱面号&amp;0x300）&gt;&gt;2; DH = 磁头号; DL = 驱动器号; ES：BS = 缓冲地址（检验及寻道时不使用） 返回值： FLACS.CF == 0：没有出错，AH = 0 FLACS.CF == 1：有错误，错误码存入AH内 一张软盘大约有80个柱面，2个磁头，18个扇区，且一个扇区有512字节。所以一张软盘的容量是80×2×18×512 = 1 474 560 字节 = 1440KB C0-H0-S1(柱面0，磁头0，扇区1)，下一个扇区是C0-H0-S2 由于寄存器是16位的，最大表示0xffff，也就是65535，最大才64K。使用辅助作用的段寄存器，以ES：BX这种表示方法来表示地址，写成MOV AL, [ES:BX]，表示的是ES*16+BX的内存地址。这样可以表示1 114 095个字节，也就是1M，比64K大多了。 事实上，不管我们要指定内存的什么地址，都必须同时指定段寄存器，这是规定。一般如果省略的话就会把“DS:”作为默认的段寄存器。因为有这样的规则，所以DS必须预先指定为0，否则地址的值要加上这个数的16倍。 Makefile中可以使用简单的变量。 harib00b软盘这东西很不靠谱，有时会发生不能读取数据的情况，这时候需要再读一次就行了。我们决定重试5次，不行的话就放弃。 1234567891011121314151617181920212223 MOV AX, 0x0820 MOV ES, AX MOV CH, 0 ; 柱面0 MOV DH, 0 ; 磁头0 MOV CL, 2 ; 扇区2 MOV SI, 0 ; 记录失败次数的寄存器retry: MOV AH, 0x02 ; AH = 0x02 : 读盘 MOV AL, 1 ; 1个扇区 MOV BX, 0 ; MOV DL, 0x00 ; A驱动器 INT 0x13 ; 调用磁盘BIOS JNC fin ; 没出错的话跳转到fin ADD SI, 1 ; 往SI加1 CMP SI, 5 ; 比较SI与5 JAE error ; SI &gt;= 5时，跳转到error MOV AH, 0x00 MOV DL, 0x00 INT 0x13 JMP retry JNC是“Jump if not carry”的缩写。也就是说进位标志位是0的话就跳转。 JAE是“Jump if avove or equal”的缩写，意思是大于或等于时跳转。 AH=0x00，DL=0x00，INT 0x13。这是“系统复位”。它的功能就是复位软盘状态，再读一次。 harib00c读到18扇区 1234567891011121314151617181920212223242526272829303132 MOV AX, 0x0820 MOV ES, AX MOV CH, 0 ; 柱面0 MOV DH, 0 ; 磁头0 MOV CL, 2 ; 扇区2readloop: MOV SI, 0 ; 记录失败次数的寄存器retry: MOV AH, 0x02 ; AH = 0x02 : 读盘 MOV AL, 1 ; 1个扇区 MOV BX, 0 ; MOV DL, 0x00 ; A驱动器 INT 0x13 ; 调用磁盘BIOS JNC next ; 没出错的话跳转到next ADD SI, 1 ; 往SI加1 CMP SI, 5 ; 比较SI与5 JAE error ; SI &gt;= 5时，跳转到error MOV AH, 0x00 MOV DL, 0x00 INT 0x13 JMP retrynext: MOV AX, ES ADD AX, 0x0020 MOV ES, AX ; 因为没有ADD ES, 0x0020指令，所以这里绕了个弯 ADD CL, 1 ; 往CL里加1 CMP CL, 18 ; 比较CL与18 JBE readloop ; 如果CL &lt;= 18 跳转至readloop JBE是“jump if below or equal”的缩写，意思是小于或等于跳转。 harib00d读入10个柱面 C0-H0-S18扇区的下一个扇区，是磁盘反面的C0-H1-S1。按顺序读到C0-H1-S18后，接着读下一个柱面C1-H0-S1。照这样读到C9-H1-S18就好了。 12345678910111213141516171819202122232425262728293031323334353637383940; 读磁盘 MOV AX, 0x0820 MOV ES, AX MOV CH, 0 ; 柱面0 MOV DH, 0 ; 磁头0 MOV CL, 2 ; 扇区2readloop: MOV SI, 0 ; 记录失败次数的寄存器retry: MOV AH, 0x02 ; AH = 0x02 : 读盘 MOV AL, 1 ; 1个扇区 MOV BX, 0 ; MOV DL, 0x00 ; A驱动器 INT 0x13 ; 调用磁盘BIOS JNC next ; 没出错的话跳转到next ADD SI, 1 ; 往SI加1 CMP SI, 5 ; 比较SI与5 JAE error ; SI &gt;= 5时，跳转到error MOV AH, 0x00 MOV DL, 0x00 INT 0x13 JMP retrynext: MOV AX, ES ADD AX, 0x0020 MOV ES, AX ; 因为没有ADD ES, 0x0020指令，所以这里绕了个弯 ADD CL, 1 ; 往CL里加1 CMP CL, 18 ; 比较CL与18 JBE readloop ; 如果CL &lt;= 18 跳转至readloop MOV CL, 1 ADD DH, 1 CMP DH, 2 JB readloop ; 如果DH &lt; 2 则跳转到readloop MOV DH, 0 ADD CH, 1 CMP CH, CYLS JB readloop JB是“jump if below”的缩写，意思是小于的话就跳转。 EQU指令相当于C语言的#define命令。“CYLS EQU 10”意思是“CYLS=10：”。EQU是equal的缩写。我们把它定义为10个柱面 harib00e123fin: HLT JMP fin 将以上内容保存为haribote.nas，用nask编译，输出成haribote.sys。然后将这个文件保存到haribote.img里面。 打开haribote.sys查看内容，再打开haribote.img 查看0x002600和0x004200附近的内容。你会发现文件名写在0x2600以后的地方。文件的内容写在0x004200后面。 harib00f为了执行0x004200号的地址，现在的程序是从启动区开始，把磁盘的内容装载到内存0x8000号地址，所以磁盘0x4200处的内容就应该位于内存的0x8000+0x4200=0xc200号地址。 在haribote.sys里加上ORG 0xc200，然后在ipl.nas处理的最后加上JMP 0xc200这个指令。 harib00g如果只是让它输出一条信息就太没意思了，那就让它切换一下画面模式。5 123456789101112131415; haribote-os; TAB=4 ORG 0xc200 ; 这个程序将要被装到内存的什么地方 MOV AL, 0x13 ; VGA显卡，320*200*8位彩色 MOV AH, 0x00 INT 0x10fin: HLT JMP fin 如果画面模式正常，画面应该会变为一片漆黑。另外，想要把磁盘转载内容的结束地址告诉haribote.sys，所以我们在“JMP 0xc200”之前，加入了一行命令。将CYLS的值写到内存地址0x0ff0中。 harib00h画面模式的设定已经做完了，下面就从BIOS得到键盘状态 123456789101112131415161718192021222324252627282930; haribote-os; TAB=4; 有关BOOT_INFOCYLS EQU 0x0ff0 ; 设定启动区LEDS EQU 0x0ff1VMODE EQU 0x0ff2 ; 关于颜色数目的信息。颜色的位数SCRNX EQU 0x0ff4 ; 分辨率XSCRNY EQU 0x0ff6 ; 分辨率YVRAM EQU 0x0ff8 ; 图像缓存区的开始地址 ORG 0xc200 ; 这个程序要被装载到内存的什么地方 MOV AL,0x13 ; VGA 显卡，320*200*8位彩色 MOV AH,0x00 INT 0x10 MOV BYTE [VMODE],8 ; 记录画面模式 MOV WORD [SCRNX],320 MOV WORD [SCRNY],200 MOV DWORD [VRAM],0x000a0000; 用BIOS取得键盘上各种LED指示灯的状态 MOV AH,0x02 INT 0x16 ; keyboard BIOS MOV [LEDS],ALfin: HLT JMP fin 我们把画面的像素数、颜色数，以及BIOS取得的键盘信息都保存了起来。 harib00i运行C语言程序。 asmhead.nas 为了调用C语言写的程序，添加了100行左右的代码。下面是C语言部分 12345void HariMain(void)&#123; fin: goto fin;&#125; 1234567bootpack.c转成机器语言的过程：1. 使用cc1.exe从bootpack.c生成bootpack.gas2. 使用gas2nask.exe从bootpack.gas生成bootpack.nas3. 使用nask.exe从bootpack.nas生成bootpack.obj4. 使用obj2bim.exe从bootpack.obj生成bootpack.bim5. 使用bim2hrb.exe从bootpack.bim生成bootpack.hrb6. 使用copy指令将asmhead.bin和bootpack.hrb结合生成haribote.sys harib00j解决计算机处于HALT状态 123456789101112131415161718192021222324naskfun.nas; naskfunc; TAB=4[FORMAT &quot;WCOFF&quot;] ; 制作目标文件的模式 [BITS 32] ; 制作32位模式用的机械?言; 制作目?文件的信息[FILE &quot;naskfunc.nas&quot;] ; 源文件名信息 GLOBAL _io_hlt ; 程序中包含的函数名; 以下是??的函数[SECTION .text] ; 目标文件中写了这些之后再写程序_io_hlt: ; void io_hlt(void); HLT RET bootpack.c 文件调用 12345678void io_hlt(void);void HariMain(void)&#123; fin: io_hlt(); goto fin;&#125;","tags":[{"name":"磁盘","slug":"磁盘","permalink":"http://yoursite.com/tags/磁盘/"},{"name":"30天自制操作系统","slug":"30天自制操作系统","permalink":"http://yoursite.com/tags/30天自制操作系统/"},{"name":"C语言与汇编语言链接","slug":"C语言与汇编语言链接","permalink":"http://yoursite.com/tags/C语言与汇编语言链接/"}]},{"title":"2 自制操作系统第二天","date":"2017-11-23T16:00:00.000Z","path":"2017/11/24/omake_2/","text":"项目地址 继续改进helloos.nas1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465; hello-os; TAB = 4 ORG 0x7c00 ;指明程序的装载地址; 以下这段是标准FAT12格式软盘专用的代码 JMP entry DB 0x90 DB &quot;HELLOIPL&quot; ; 启动区的名称可以时任意的字符串(8字节) DW 512 ; 每个扇区(sector)的大小(必须是512字节) DB 1 ; 簇(cluster）的大小（必须是一个扇区) DW 1 ; FAT的起始位置(一般从第一个扇区开始) DB 2 ; FAT的个数(必须是2) DW 224 ; 根目录的大小(一般设成224项) DW 2880 ; 该磁盘的大小(必须是2880扇区) DB 0xf0 ; 磁盘的种类(必须是0xf0) DW 9 ; FAT的长度(必须是9扇区) DW 18 ; 1个磁道(track)有几个扇区(必须是18) DW 2 ; 磁头数(必须是2) DD 0 ; 不使用分区，必须是0 DD 2880 ; 重写一次磁盘大小 DB 0,0,0x29 ; 意义不明，固定 DD 0xffffffff ; (可能是)卷标号码 DB &quot;HELLO-OS &quot; ; 磁盘的名称(11字节) DB &quot;FAT12 &quot; ; 磁盘格式名称(8字节) RESB 18 ; 先空出18字节; 程序主体entry: MOV AX,0 ; 初始化寄存器 MOV SS,AX MOV SP,0x7c00 MOV DS,AX MOV ES,AX MOV SI,msgputloop: MOV AL,[SI] ADD SI,1 ; 给SI加1 CMP AL,0 JE fin MOV AH,0x0e ; 显示一个文字 MOV BX,15 ; 指定字符颜色 INT 0x10 ; 调用显卡BIOS JMP putloopfin: HLT ; 让CPU停止，等待指令 JMP fin ; 无限循环 msg: DB 0x0a, 0x0a ; 换行2次 DB &quot;hello, world&quot; DB 0x0a ; 换行 DB 0 RESB 0x7dfe-$ ; DB 0x55, 0xaa; 以下是启动区以外部分的输出 DB 0xf0, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00 RESB 4600 DB 0xf0, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00 RESB 1469432 ORG指令。这个指令会告诉 nask，在开始执行的时候，把这些机器指令装载到内存的哪个地址。另外，美元符号（$）也会随之改变。 JMP指令。相当于C语言的goto语句，来源英文的jump。 CPU里有一种名为寄存器的存储电路，在机器语言中就相当于变量的功能。具有代表性的有一下8个。 AX - accumulator，累加器 CX - counter，计数寄存器 DX - data，数据寄存器 BX - base，基址寄存器 SP - stack pointer，栈指针寄存器 BP - base pointer，基址指针寄存器 SI - source index，源变址寄存器 DI - destination index，目的变址寄存器 这些寄存器全是16位寄存器。虽然它们都有上面这种正式名称，但在平常的时候，人们往往用简单的英文字母来代替，称它们为“AX寄存器”、“SI寄存器”等。 “ADD CX, 0x1234”编译成81 C1 34 12，是一个4字节的命令而“ADD AX, 0x1234”编译成05 34 12，是一个3字节的命令 关于AX、CX、DX、BX这几个寄存器名字的由来，虽然找不到缩写为X的单词，但这个X表示扩展（extend）的意思。之所以说是扩展是因为在之前CPU的寄存器都是8位的，而现在一下子变成了16位，扩展了一倍，所以发明者在原来的寄存器的名字后面加了个X，意思就是说“扩张了一倍”。 这8个寄存器全部合起来才只有16个字节。 另一方面，CPU还有8个8位寄存器 AL - 累加寄存器低位 CL - 计数寄存器低位 DL - 数据寄存器低位 BL - 基址寄存器低位 AH - 累加寄存器高位 CH - 计数寄存器高位 DH - 数据寄存器高位 BH - 基址寄存器高位 AX寄存器共有16位，其中0位到7位的低8位称为AL，而8位到15位的高8位称为AH。所以，如果以为“再加上这个8个寄存器，CPU就又可以多保存8个字节了”就打错特错了。 BP、SP、SI、DI没有分为“L”和“H”。如果分别取高位和低位，就必须先用“MOV, AX, SI”将SI的值赋到AX中去，然后再用AL、AH来取值。 MOV AL, [SI] 这个记号代表内存。如果SI保存的是987的话，被解释为MOV, AL[987]。 MOV BYTE [678], 123，这个指令要用内存的“678”号地址来存储123这个数值。 MOV WORD [678], 123，这个情况下，内存地址中的678号和679号都会做出反应，一共是16位。这是，123被解释成一个16位的数值，也即是00000000 01111011，低位的01111011保存在678号，高位的00000000保存在679号。 只有BX、BP、SI、DI这几个可以用来指定内存地址。剩下的AX、CX、DX、SP不能用来指定内存地址，这是因为CPU没有处理这种指令的电路。所以想把DX内存里的内容赋值给AL的时候，可以这样写：MOV BX, DXMOV AL, BYTE [BX] MOV AL, BYTE [SI],由于 源数据和目的数据必须位数相同。所以这条语句可以简写为MOV AL, [SI] ADD是加法指令。若以C语言改写“ADD SI, 1”的话，就是SI=SI+1. CMP是比较指令。源自于compare。比如C语言中的if (a == 3){ 处理; }，将其翻译成机器语言时，必须先写“CMP a, 3”，告诉CPU比较的对象，然后下一步再写“如果二者相等，需要做什么” JE是条件跳转指令之一。源自于“jump if equal”。如果比较结果相等，则跳转到指定的地址；如果不相等，则不跳转，继续执行下一条指令。因此CMP AL, 0JE fin这两条指令，就相当于：if (AL == 0) { goto fin;} INT是软件中断命令。源自于interrupt。暂时把它看做一个函数调用吧。电脑有个名为BIOS的程序，出厂时就组装在电脑主板上的ROM单元里。电脑厂家在BIOS写入了操作系统开发人员经常用到的一些程序。BIOS是英文“basic input output system”的缩写，直译过来就是“基本输入输出系统” HLT是让CPU停止动作的指令，不过不是彻底地停止，而是让CPU进入待机状态。只要外部发生变化，比如按下键盘，CPU就会醒过来。 12345ORG 0x7c00是怎么回事？这个0x7c00是从哪里冒出来的？内存的0号地址，也就是最开始的部分，是BIOS程序用来实现各种不同功能的地方，如果我们随便使用的话，就会与BIOS发生冲突，结果不只是BIOS会出错，而且我们的程序也会出问题。0x00007c00-0x00007dff ：启动区内容的装载地址 制作启动区 先把helloos.nas的后半部分去掉，因为启动区只需要最初的512字节。 改造asm.bat，将输出的文件名改成ipl.bin。另外，也顺便输出列表文件ipl.lst。这个文件是用来简单地确认每个指令是怎么翻译成机器语言的。 增加一个makeimg.bat。它是以ipl.bin为基础，制作磁盘映像文件heloos.img的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101ipl.lst文件 1 00000000 ; hello-os 2 00000000 ; TAB = 4 3 ORG 0x7c00 ;指明程序的装载地址 4 00007C00 5 00007C00 ; 以下这段是标准FAT12格式软盘专用的代码 6 00007C00 7 00007C00 8 00007C00 EB 4E JMP entry 9 00007C02 90 DB 0x90 10 00007C03 48 45 4C 4C 4F 49 50 4C DB &quot;HELLOIPL&quot; ; 启动区的名称可以时任意的字符串(8字节) 11 00007C0B 0200 DW 512 ; 每个扇区(sector)的大小(必须是512字节) 12 00007C0D 01 DB 1 ; 簇(cluster）的大小（必须是一个扇区) 13 00007C0E 0001 DW 1 ; FAT的起始位置(一般从第一个扇区开始) 14 00007C10 02 DB 2 ; FAT的个数(必须是2) 15 00007C11 00E0 DW 224 ; 根目录的大小(一般设成224项) 16 00007C13 0B40 DW 2880 ; 该磁盘的大小(必须是2880扇区) 17 00007C15 F0 DB 0xf0 ; 磁盘的种类(必须是0xf0) 18 00007C16 0009 DW 9 ; FAT的长度(必须是9扇区) 19 00007C18 0012 DW 18 ; 1个磁道(track)有几个扇区(必须是18) 20 00007C1A 0002 DW 2 ; 磁头数(必须是2) 21 00007C1C 00000000 DD 0 ; 不使用分区，必须是0 22 00007C20 00000B40 DD 2880 ; 重写一次磁盘大小 23 00007C24 00 00 29 DB 0,0,0x29 ; 意义不明，固定 24 00007C27 FFFFFFFF DD 0xffffffff ; (可能是)卷标号码 25 00007C2B 48 45 4C 4C 4F 2D 4F 53 20 20 DB &quot;HELLO-OS &quot; ; 磁盘的名称(11字节) 00007C35 20 26 00007C36 46 41 54 31 32 20 20 20 DB &quot;FAT12 &quot; ; 磁盘格式名称(8字节) 27 00007C3E 00 00 00 00 00 00 00 00 00 00 RESB 18 ; 先空出18字节 00007C48 00 00 00 00 00 00 00 00 28 00007C50 29 00007C50 ; 程序主体 30 00007C50 31 00007C50 entry: 32 00007C50 B8 0000 MOV AX,0 ; 初始化寄存器 33 00007C53 8E D0 MOV SS,AX 34 00007C55 BC 7C00 MOV SP,0x7c00 35 00007C58 8E D8 MOV DS,AX 36 00007C5A 8E C0 MOV ES,AX 37 00007C5C 38 00007C5C BE 7C74 MOV SI,msg 39 00007C5F putloop: 40 00007C5F 8A 04 MOV AL,[SI] 41 00007C61 83 C6 01 ADD SI,1 ; 给SI加1 42 00007C64 3C 00 CMP AL,0 43 00007C66 74 09 JE fin 44 00007C68 B4 0E MOV AH,0x0e ; 显示一个文字 45 00007C6A BB 000F MOV BX,15 ; 指定字符颜色 46 00007C6D CD 10 INT 0x10 ; 调用显卡BIOS 47 00007C6F EB EE JMP putloop 48 00007C71 49 00007C71 fin: 50 00007C71 F4 HLT ; 让CPU停止，等待指令 51 00007C72 EB FD JMP fin ; 无限循环 52 00007C74 53 00007C74 msg: 54 00007C74 0A 0A DB 0x0a, 0x0a ; 换行2次 55 00007C76 68 65 6C 6C 6F 2C 20 77 6F 72 DB &quot;hello, world&quot; 00007C80 6C 64 56 00007C82 0A DB 0x0a ; 换行 57 00007C83 00 DB 0 58 00007C84 00 00 00 00 00 00 00 00 00 00 RESB 0x7dfe-$ ; 00007C8E 00 00 00 00 00 00 00 00 00 00 00007C98 00 00 00 00 00 00 00 00 00 00 00007CA2 00 00 00 00 00 00 00 00 00 00 00007CAC 00 00 00 00 00 00 00 00 00 00 00007CB6 00 00 00 00 00 00 00 00 00 00 00007CC0 00 00 00 00 00 00 00 00 00 00 00007CCA 00 00 00 00 00 00 00 00 00 00 00007CD4 00 00 00 00 00 00 00 00 00 00 00007CDE 00 00 00 00 00 00 00 00 00 00 00007CE8 00 00 00 00 00 00 00 00 00 00 00007CF2 00 00 00 00 00 00 00 00 00 00 00007CFC 00 00 00 00 00 00 00 00 00 00 00007D06 00 00 00 00 00 00 00 00 00 00 00007D10 00 00 00 00 00 00 00 00 00 00 00007D1A 00 00 00 00 00 00 00 00 00 00 00007D24 00 00 00 00 00 00 00 00 00 00 00007D2E 00 00 00 00 00 00 00 00 00 00 00007D38 00 00 00 00 00 00 00 00 00 00 00007D42 00 00 00 00 00 00 00 00 00 00 00007D4C 00 00 00 00 00 00 00 00 00 00 00007D56 00 00 00 00 00 00 00 00 00 00 00007D60 00 00 00 00 00 00 00 00 00 00 00007D6A 00 00 00 00 00 00 00 00 00 00 00007D74 00 00 00 00 00 00 00 00 00 00 00007D7E 00 00 00 00 00 00 00 00 00 00 00007D88 00 00 00 00 00 00 00 00 00 00 00007D92 00 00 00 00 00 00 00 00 00 00 00007D9C 00 00 00 00 00 00 00 00 00 00 00007DA6 00 00 00 00 00 00 00 00 00 00 00007DB0 00 00 00 00 00 00 00 00 00 00 00007DBA 00 00 00 00 00 00 00 00 00 00 00007DC4 00 00 00 00 00 00 00 00 00 00 00007DCE 00 00 00 00 00 00 00 00 00 00 00007DD8 00 00 00 00 00 00 00 00 00 00 00007DE2 00 00 00 00 00 00 00 00 00 00 00007DEC 00 00 00 00 00 00 00 00 00 00 00007DF6 00 00 00 00 00 00 00 00 59 00007DFE 55 AA DB 0x55, 0xaa Makefile Makefile是一个非常聪明的批处理文件 12345ipl.bin : ipl.nas Makefile ../../tolset/z_tools/nask.exe ipl.nas ipl.bin ipl.lst helloos.img : ipl.bin Makefile ../../tolset/z_tools/edimg.exe imgin:../../tolset/z_tools/fdimg0at.tek wbinimg src:ipl.bin len:512 from:0 to:0 imgout:helloos.img #代表注释。下一行“ipl.bin : ipl.nas Makefile”的意思是，如果想要制作ipl.bin，就先检查ipl.nas和Makefile文件是否存在。如果存在，make工具就会自动执行Makefile的下一行。打开cmd窗口，输入“make -r ipl.bin”，就会生成ipl.bin。 如果ipl.bin不存在，执行命令“make -r helloos.img”的话，它会先生成ipl.bin，然后生成helloos.img文件。 如果heools.img已经存在，执行命令“make -r helloos.img”，不会生成任何文件，而且会显示“helloos.img is up to date” 如果修改ipl.bin文件的话，即使helloos.img存在，它还是会生成新文件，因为它会判断文件的更新日期，以此来决定是否重新生成文件。 在Makefile里面添加如下命令1234567891011# 命令img : ../../tolset/z_tools/make.exe -r helloos.img asm : ../../tolset/z_tools/make.exe -r ipl.binrun : ../../tolset/z_tools/make.exe img copy helloos.img ..\\..\\tolset\\z_tools\\qemu\\fdimage0.bin ../../tolset/z_tools/make.exe -C ../../tolset/z_tools/qemu 只要输入make img就会与“make -r helloos.img”有一样的效果。","tags":[{"name":"30天自制操作系统","slug":"30天自制操作系统","permalink":"http://yoursite.com/tags/30天自制操作系统/"},{"name":"寄存器","slug":"寄存器","permalink":"http://yoursite.com/tags/寄存器/"},{"name":"Makefile","slug":"Makefile","permalink":"http://yoursite.com/tags/Makefile/"}]},{"title":"1 自制操作系统第一天","date":"2017-11-20T16:00:00.000Z","path":"2017/11/21/omake_1/","text":"项目地址 二进制文件有一种工具软件名为“二进制编辑器”（binary editor），是一种能够直接对二进制数进行编辑的软件。这里是下载地址，中间有一个Download标识的。我试过notepad++，但是里面不可以复制粘贴。 使用bz软件，退出去之后，再次打开某个文件，不可编辑，这是因为它是只读模式，在软件菜单里选择“编辑”（edit），然后把“只读”（read only）去掉对号，就可以再次编辑了。 建立一个二进制文件，这里是源文件地址。你可以直接用，但是我建议你把这些数字自己手动写一下。简单介绍一下这个文件怎么输入，首先000090以前的数字自己手打进去，然后从000090开始到168000这个地址，中间都输入00，你可以大量的复制粘贴。因为一共168000行，而168000是16进制，换成10进制是1474560，所以文件大小是1474560（1440*1024字节）字节，复制的时候可以看文件大小适当的停下。还没结束，中间有几行不全是0，在0000 01f0这一行、0000 0200这一行和0000 1400这一行，可以对照源文件进行修改。然后保存这个文件，建议后缀是img。 下载项目的地址中tolset，这里面有很多工具可以用。 12345下面是run.bat命令copy helloos.img ..\\..\\tolset\\z_tools\\qemu\\fdimage0.bin..\\..\\tolset\\z_tools\\make.exe -C ../../tolset/z_tools/qemu注意：根据自己的二进制文件名称和路径进行修改命令 我也不知道这个run命令是什么意思，应该是打开一个叫做QEMU的PC模拟器，然后把你的镜像文件（你创建的二进制文件），放到里面运行。 运行run命令之后，你的操作系统就制作好了。 汇编程序刚才那个二进制文件简直写的太麻烦，现在利用汇编程序把它缩短一些，汇编语言编译器在tolset里面，名为“nask”，其中的很多语法都模仿了自由软件里享有盛名的汇编器“NASM”，不过在“NASM”的基础上提高了自动优化的能力。 这个是汇编程序文件，我还是建议自己手动输出写一遍。12345678910111213141516171819202122DB 0xeb, 0x4e, 0x90, 0x48, 0x45, 0x4c, 0x4c, 0x4fDB 0x49, 0x50, 0x4c, 0x00, 0x02, 0x01, 0x01, 0x00DB 0x02, 0xe0, 0x00, 0x40, 0x0b, 0xf0, 0x09, 0x00DB 0x12, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00DB 0x40, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x29, 0xffDB 0xff, 0xff, 0xff, 0x48, 0x45, 0x4c, 0x4c, 0x4fDB 0x2d, 0x4f, 0x53, 0x20, 0x20, 0x20, 0x46, 0x41DB 0x54, 0x31, 0x32, 0x20, 0x20, 0x20, 0x00, 0x00RESB 16DB 0xb8, 0x00, 0x00, 0x8e, 0xd0, 0xbc, 0x00, 0x7cDB 0x8e, 0xdb, 0x8e, 0xc0, 0xbe, 0x74, 0x7c, 0x8aDB 0x04, 0x83, 0xc6, 0x01, 0x3c, 0x00, 0x74, 0x09DB 0xb4, 0x0e, 0xbb, 0x0f, 0x00, 0xcd, 0x10, 0xebDB 0xee, 0xf4, 0xeb, 0xfd, 0x0a, 0x0a, 0x68, 0x65DB 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x77, 0x6f, 0x72DB 0x6c, 0x64, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00RESB 368DB 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xaaDB 0xf0, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00RESB 4600DB 0xf0, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00RESB 1469432 1234汇编编译命令 asm.bat..\\..\\tolset\\z_tools\\nask.exe helloos.nas helloos.img注意：根据自己汇编程序文件名称和路径进行修改命令 编译之后，就会得到一个img文件，然后调用run命令就好了。 DB指令是“define byten”的缩写，也就是往文件里面直接写入1个文件的指令。 RESB指令是“reserve byte”的略写，如果想要从现在的地址开始空出10个字节来，就可以写成RESB 10。而且nask不仅仅是把指定的地址空出来，它还会在空出来的地址上自动填写0x00，所以我们这次用这个指令就可以输出很多0x00。 改进后的汇编程序这里是改进后的汇编程序文件，建议你自己手动打一遍。12345678910111213141516171819202122232425262728293031323334353637383940414243444546; hello-os; TAB = 4; 以下这段是标准FAT12格式软盘专用的代码 DB 0xeb, 0x4e, 0x90 DB &quot;HELLOIPL&quot; ; 启动区的名称可以时任意的字符串(8字节) DW 512 ; 每个扇区(sector)的大小(必须是512字节) DB 1 ; 簇(cluster）的大小（必须是一个扇区) DW 1 ; FAT的起始位置(一般从第一个扇区开始) DB 2 ; FAT的个数(必须是2) DW 224 ; 根目录的大小(一般设成224项) DW 2880 ; 该磁盘的大小(必须是2880扇区) DB 0xf0 ; 磁盘的种类(必须是0xf0) DW 9 ; FAT的长度(必须是9扇区) DW 18 ; 1个磁道(track)有几个扇区(必须是18) DW 2 ; 磁头数(必须是2) DD 0 ; 不使用分区，必须是0 DD 2880 ; 重写一次磁盘大小 DB 0,0,0x29 ; 意义不明，固定 DD 0xffffffff ; (可能是)卷标号码 DB &quot;HELLO-OS &quot; ; 磁盘的名称(11字节) DB &quot;FAT12 &quot; ; 磁盘格式名称(8字节) RESB 18 ; 先空出18字节; 程序主体 DB 0xb8, 0x00, 0x00, 0x8e, 0xd0, 0xbc, 0x00, 0x7c DB 0x8e, 0xdb, 0x8e, 0xc0, 0xbe, 0x74, 0x7c, 0x8a DB 0x04, 0x83, 0xc6, 0x01, 0x3c, 0x00, 0x74, 0x09 DB 0xb4, 0x0e, 0xbb, 0x0f, 0x00, 0xcd, 0x10, 0xeb DB 0xee, 0xf4, 0xeb, 0xfd; 信息显示部分 DB 0x0a, 0x0a ; 两个换行 DB &quot;hello, world&quot; DB 0x0a ; 换行 DB 0 RESB 0x1fe-$ ; 填写0x00，直到0x001fe DB 0x55, 0xaa; 以下是启动区以外部分的输出 DB 0xf0, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00 RESB 4600 DB 0xf0, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00 RESB 1469432 “;”命令就是注释命令 DW是“define word”的缩写，2个字节 DD是“define double-word”的缩写，4个字节 RESB 0x1fe-$，在这个程序里，我们已经在前面输出了132字节，所以这里的$就是132.因此nask先用0x1fe减去132，得出378这一结果，然后连续输出378个字节的0x00。为什么非要用$呢？这是因为如果将系那是信息从”hello, world”换成“this is a pen.”的话，中间要输出0x00的数量也会随之变化。换句话说，我们必须保证软盘的第510字节（即第0x1fe）开始的地方必须是0x55和0xaa。 专业术语 启动区（boot sector）软盘的第一个的扇区称为启动区。计算机读写软盘的时候，并不是一个字节一个字节第读写的，而是以512字节为一个单位进行读写。因此，软盘的512字节就是一个扇区。一张软盘的空间共有1440KB，也就时1474560字节，除以512得2880，也就是说一张软盘共有2880个扇区。那位神秘第一个扇区称为启动区呢？那是因为计算机首先从最初一个扇区开始读软盘，然后去检查这个扇区最后2个字节的内容。如果最后两个字节不是0x55AA，计算机会认为这张盘上没有所需的启动程序，就会报一个不能启动的错误。（也许有人会问为什么一定是0x55AA呢？那是当初的设计者随便定的）。如果计算机确定第一个扇区的最后两个字节正好是0x55AA，那它认为这个扇区的开头是启动程序，并开始执行和这个程序。 IPL(initial program loader)是启动程序加载器。启动区只有512字节，实际的操作系统不想hello-os这么小，根本装不进去。所以几乎所有的操作系统，都是把加载操作系统本身的程序放在启动区里的。有鉴于此，有时也将启动区成为IPL。但hello-os没有加载程序的功能，所以HELLOIPL这个名字不太顺理成章。 启动（boot）。boot这个词是bootstrap的缩写，原指靴子上附带的便于拿取的靴带。但自从有了《吹牛大王历险记》（德国）这个故事以后，bootstrap这个词就有了“自力更生完成任务”的意思。而且，磁盘上明明有操作系统，还要说读入操作系统的程序（即IPl）也放在磁盘里，这就像打开宝物箱的钥匙和宝物都在宝物箱里一样，是一种矛盾的说法。这种矛盾的操作系统自动启动机制，被称为bootstrap方式。boot这个说法就来源于此。","tags":[{"name":"30天自制操作系统","slug":"30天自制操作系统","permalink":"http://yoursite.com/tags/30天自制操作系统/"},{"name":"hello,world","slug":"hello-world","permalink":"http://yoursite.com/tags/hello-world/"}]},{"title":"25 图形化革命","date":"2017-11-18T04:00:00.000Z","path":"2017/11/18/code_25/","text":"矢量图形（vector graphics）在一些算法的帮助下，利用直线、曲线及填充区域生成图形。矢量图形在工程和体系结设计中有着十分重要的作用。矢量图形一般转化为图元文件（metafile）格式以存放到文件中。图元文件是由生成矢量图形的一系列绘制命令的集合组成的，这些命令通常已经被编码为二进制形式。 光栅图形（也称作位图）。位图（bitmap）将图形以矩阵阵列的形式进行编码，阵列中的一个单位对应着输出设备上的一个像素点。 要把现实世界的图像输入到计算机中，可以借助一些不同的硬件，这类设备统称为电荷耦合器（charge-coupled device， CCD），它是一种在光照下会起电的半导体器件。每个像素都需要一个CCD单元来采集。这些设备中最原始的可以算是扫描仪（scanner）了，其原理和影印机类似，都是利用一行CCD扫过需要复印的图像的表面，比如照片。由于光感度不同，不同区域CCD累积的电荷数不同。扫描仪的配套软件把图像转换成位图放在文件中。 位图的文件可能很大，催生了数据压缩这一领域。 如果画面的是一片天空、一栋房子和一块草坪。因此，图片中可能有大片的蓝色和绿色。如果有一种方法可以表示蓝色和绿色连续重复了多少次，这种方法就会让文件变得很小。这样的压缩方法称为游程长度编码（Run-Length Encoding），即RLE。属于无损（lossless）压缩技术。 JPEG（Joint Photography Experts Group）中，人们使用了一些列位图有损压缩技术。 CD（compact disc）声音信息采用的编码技术被称为脉冲编码调制技术（Pulse Code Modulation），简称PCM。振动是声音之源。声波可以被模拟，电流产生模拟（analog）声波。为了达到这个目的，使用模拟数字转换器（Analog To Digital Converter，ADC），将模拟电压转换成二进制数。 以电压形式表示的声波以恒定的频率被转换成数值。这些数值将以小孔的形式刻在光盘上，通过这种方式，电压就以数值的形式被存储在CD上。要读取这些信息时，可以通过分析从CD表面反射的激光读取到所存储的数值。在播放声音的时候，这些数值又被转换成电流，这个过程用到了数字模拟转换器（Digital-To-Analog converter， 即DAC），DAC还可以用在彩色图形板上，将像素值转换成模拟信号并传输到显示器。 计算机中的电影文件一般都是由一系列附带声音的位图组合而成。如果不经过压缩处理，一部电影文件的数据量将会很大。假如电影中每一帧包含的像素大小是640*480，每个像素为24位真彩色，那么每一帧的大小九尾921600字节。如果播放的速度是30帧/秒，则每秒需要的存储空间是27648000字节。照这样下午，每分钟需要的空间大小为1658880000字节，一部两小时的电影大约需要100GB。 就像JEPG压缩技术可以用来减少静态图像所占的数据空间一样，MPEG压缩技术用于处理动态电影文件。全称是Moving Pictures Expert Group。动态图像压缩技术基于的是一种客观事实，即每一帧继承了前一帧的大部分消息，也就是存在冗余消息。","tags":[{"name":"编码(隐匿在计算机软硬件背后的语言)","slug":"编码-隐匿在计算机软硬件背后的语言","permalink":"http://yoursite.com/tags/编码-隐匿在计算机软硬件背后的语言/"},{"name":"图像的存储","slug":"图像的存储","permalink":"http://yoursite.com/tags/图像的存储/"},{"name":"音乐的存储","slug":"音乐的存储","permalink":"http://yoursite.com/tags/音乐的存储/"},{"name":"图像压缩","slug":"图像压缩","permalink":"http://yoursite.com/tags/图像压缩/"}]},{"title":"24 高级语言与低级语言","date":"2017-11-18T04:00:00.000Z","path":"2017/11/18/code_24/","text":"使用机器码编码写程序就如同用牙签吃东西，伸出手臂使出较大的力气刺向食物，但每次只获取到小小的一块，这个过程是辛苦且漫长的。同样的，每个机器码字节所能完成的工作，是你能想象到的最微小且最简单的工作。 使用汇编语言编写程序要比使用机器语言简单的多，但微处理器并不能解释汇编语言，当你确实准确在微处理器上运行汇编程序，才会手工对其汇编，这样就可以将汇编语言程序的语句转换成了机器语言代码，并把它们输入内存。 当然我们希望计算机能独自完成语言转换的工作。CM/P系统中，有一个工具可以对其进行汇编。首先，建立一个文本文件，例如PROGRAM1.ASM。下一步要做的就是对其进行汇编，即将其转换成机器语言代码，可以利用CP/M中一个叫做ASM.COM的模块来完成这想工作。可以在CP/M的命令行中使用下面的语句：ASM PROGRAM1.ASM。产生一个名为PROGRAM1.COM的新文件，PROGRAM1.ASM包含了与我们编写的汇编程序相对应的机器码。现在就可以利用CP/M的命令行来运行PROGRAM1.COM文件。 想ASM.COM这样的汇编器（assembler）程序所做的工作是：读取一个汇编语言文件（source-code，通常称作源文件代码），将其转换得到一个包含机器码的文件——可执行文件（executable file）。从宏观角度来看，汇编器是非常简单的，因为构成汇编语言的助记符和机器码之间是一一对应的。汇编器拥有一张包含所有可能助记符机器参数的表，它逐行读取汇编语言程序，把每一行都分解成为助记符和参数，然后把这些短小的单词和字符与表中的内容匹配。通过这种匹配的过程，每一个语句都会找到与其对应的机器码指令。 第一个编写汇编器的人需要手工对程序汇编。如果要为机器写一个新的汇编器（或者对其修改），则可以用汇编语言编写改程序，然后使用原有的汇编器对其汇编。一旦新的汇编器通过了汇编，则它也就可以对其自身进行汇编。 汇编器也有两个主要问题。第一个问题，使用汇编语言非常乏味，因为这是在微处理器芯片级的编程，因此不得不考虑每一个微小的细节。第二个问题是不可“移植”。如果你位Intel 8080写了一个汇编语言程序，则该程序不能再Motorola 6800上运行，你必须在6800上重写一个相同功能的汇编语言程序。 汇编语言称作低级语言（low-level programming language），除了汇编语言以外的其他程序设计语言都可以称作高级程序设计语言（high-level programming langua） 运行时错误（run-time error）——程序被执行时才出现的错误。 123456789101112131415161718下面的ALGOL程序用来筛选2~10,000之间的所有素数。begin Boolean array a[2:10000]; integer i, j; for i := 2 step i until 10000 do a[i] := true; for i := 2 step 1 until 100 do if a[i] then for j := 2 step 1 unitl 10000 ÷ i do a[i × j] := false; for i := 2 step 1 until 10000 do if a[i] then print (i);end 程序设计是一门科学还是一门艺术？在程序设计中有一种现象：如果让100个人来编写输出素数的程序，你可能会得到100个不同的解决方案。就算所有的程序员都使用“爱拉托逊斯筛法”来解决这个问题，其最后所写的程序也不一定与本文所写程序完全相同。 编译性（compiler）读取源文件并生成一个可执行文件；解释性（interpreter）却采取边读边执行的方式，不会产生新的文件。 集成开发环境（integrated development environment），程序的文本编辑器和编译器在一起，这样就方便了程序的调试和运行，大大加快了程序开发速度。","tags":[{"name":"编码(隐匿在计算机软硬件背后的语言)","slug":"编码-隐匿在计算机软硬件背后的语言","permalink":"http://yoursite.com/tags/编码-隐匿在计算机软硬件背后的语言/"},{"name":"程序的艺术","slug":"程序的艺术","permalink":"http://yoursite.com/tags/程序的艺术/"}]},{"title":"23 定点数和浮点数","date":"2017-11-15T16:00:00.000Z","path":"2017/11/16/code_23/","text":"数字分类自然数，即计算机的整数，包括正整数和负整数，利用2的补数可以让正整数和负整数变得非常简单。 数的位数 正整数的范围 整数的2的补数的范围 8 0 ~ 255 -128 ~ 127 16 0 ~ 65,535 -32,768 ~ 32,767 32 0 ~ 4,294,967,295 -2,147,483,648 ~ 2,147,483,647 有理数（rational number）和无理数（irrational number）统称为实数（real number）。实数和虚数（imaginary numbers）构成了复数（complex number）。虚数存在于现实世界，它在解决电子学的某些高级问题中有着重要应用。 定点数在计算机中的表示小数表示成二进制最简单的办法就是利用BCD码。BCD编码在程序处理用美元和美分表示的钱款、账户时特别有用，许多数字只需要两个小数位。 通常把两个BCD数字存放在一个字节，这种方法成为压缩BCD（packed BCD），压缩BCD需要增加1位用来标识数的正负。 -4,325,120.25可以表示为下面5个字节：00010100 00110010 01010001 00200000 00100101最左边的半个字节构成的1用来指明该数是负数，如果半个字节是0，这说明该数是个正数。 如果表示的数的范围扩大到-99,999,999.99~99,999,999.99，则我们需要6个字节来实现，其中5个字节用来表示10个数字，另一个字节整个用来做符号位。 这种存储和标记方式被称作定点格式（fixed-point format），指小数点的位置总是在数的某个特定位置。小数点的计数信息并没有与整个数字一起存储。所以，使用定点小数的程序必须知道小数点的位置。 单精度浮点数和双精度浮点数科学家和工程师们喜欢使用一种称为“科学计数法”（scientific notation）的方法来记录较大或较小的数。科学计数法分为两部分，第一部分就是指数（exponent），第二部分是有效数（significand)。 除了定点格式外还有另外一种选择，他被称作浮点格式（floating-point notation），浮点格式是基于科学技术法的。 对于十进制来说，有效数的取值范围是大于或等于1而小于10；类似的，在二进制的科学计数法中，规范化的有效数应该大于或等于1而且小于10（即十进制的2）。这个规则暗示了这样一个有趣的现象：在规范化二进制浮点数中，小数点的左边通常只有一个1，除此之外没有其他数字。 IEEE（Institute of Electrical and Electronics Engineers，美国电气和电子工程协会）浮点数标准定义了两种基本的格式：以4个字节表示的单精度格式和以8个字节表示的双精度格式。 单精度格式的4个字节可以分为三个部分：1位的符号位（0代表正数，1代表负数），8位用作指数，最后的23位用作有效数。 左 中 右 s = 1位符号 e = 8位指数 f = 23位有效数 有效数的小数点左边只有一个1，因此在IEEE浮点数标准中，这一位没有分配存储空间。在该标准中，存储有效数的23位小数部分，尽管存储的只有23位，但仍然称其精度为24位。 8位指数部分的取值范围是0 ~ 255，成为便宜（biased）指数，对于有符号指数，为了确定其实际所代表的值必须从指数中减去一个值——称做偏移量（bias）。对于单精度浮点数，偏移量为127。 指数0和255用于特殊目的，如果指数的取值范围为1~254，那么对于一个特定的数，用s（符号位），e（指数）以及f（有效数）来描述它： $(-1)^s\\times1.f\\times2^{e-127}$ 如果s是0，则该数是正的；如果s=1，则该数是负的。 如果e=0且f=0，则该数为0。在这种情况下，通常把32位都设置为0以表示该数是0。但是符号位可以设置为1，这种数可以解释为负0。负0用来表示非常小的数，这些数极小以至于不能再单精度格式下用数字和指数表示，但它们仍然小于0。 如果e=0且f≠0，则该数是合法的，但不是规范化的。这类书可以表示为： $(-1)^s\\times0.f\\times2^{-127}$ 注意，在有效数中，小数点的左边是0。 如果e=255且f=0，则该小数被解释为无穷大或无穷小，这取决于符号位s的值。 如果e=255且f≠0，则该值被解释为“不是一个数”，通常被缩写为NaN（not a number）。NaN用来表示未知的数或非法操作的结果。 单精度浮点格式下，可以表示的规范化的最小正、负二进数是： $1.00000000000000000000000_2\\times2^{-126}$ 小数点后面跟着23个二进制0。单精度浮点数格式下，可以表示的规格化的最大正、负二进制数是： $1.11111111111111111111111_2\\times2^{127}$ 这个两个数的近似地表示$1.175494351\\times10^{-38}$和$3.402823466\\times10^{38}$ 10位二进制数可以近似地用3位十进制数来表示。这意味着：单精度浮点数格式存放的24位进制数大体上与7位的十进制数相等。因此，可以说单精度浮点格式提供的24位的二进制精度或者7位的十进制精度。这样说更合适：单精度浮点数的精度为$\\frac{1}{2^{24}}$,或1/16777216，或百万分之六，但其真正的含义是什么呢? 在单精度浮点格式下，16,777,216和16,777,216将表示一个数。 32位单精度浮点数：4B800000h。将该数按符号位、指数位和有效数位划分，可以表示为：0 10010111 00000000000000000000000也就是$1.00000000000000000000000_2\\times2^{24}$，也就是16,777,216下一个二进制浮点数可表示的最大有效数是$1.00000000000000000000001_2\\times2^{24}$，也就是16,777,218。 你的程序进行了一系列计算，应该得到的结果是3.50的，但由于使用浮点数，你得到的结果可能是3.499999999999。这种问题在浮点数运算中经常发生。 如果想在程序中使用浮点格式数，但使用单精度格式又会出现各种问题，这时可以考虑使用双精度浮点数（double-precision floating-point format） 左 中 右 s = 1位符号 e = 11位指数 f = 52位有效数 双精度浮点数的指数偏移量是1023，因此该格式存储的数字可以表示为：$(-1)^s\\times1.f\\times2^{e-1023}$ 上面提到的关于单精度浮点格式下的0，无穷大，无穷小和NaN的判断规则同样适用于双精度格式。 双精度浮点格式下，可以表示的规范化的最小正、负二进数是： $1.0000000000000000000000000000000000000000000000000000_2\\times2^{-126}$小数点后面跟着52个二进制0。单精度浮点数格式下，可以表示的规格化的最大正、负二进制数是： $1.1111111111111111111111111111111111111111111111111111_2\\times2^{127}$ 这个两个数的近似地表示$2.2250738585072014\\times10^{-308}$和$1.7976931348623158\\times10^{308}$ 双精度浮点格式的有效数是53位，大致相当于十进制的16位。不能避免两个不同的书存储同一个结果的情况。例如，140,737,488,355,328.00和140,737,488,355,328.01在内存中存放时，会被当做同一个数来处理。","tags":[{"name":"编码(隐匿在计算机软硬件背后的语言)","slug":"编码-隐匿在计算机软硬件背后的语言","permalink":"http://yoursite.com/tags/编码-隐匿在计算机软硬件背后的语言/"},{"name":"定点数","slug":"定点数","permalink":"http://yoursite.com/tags/定点数/"},{"name":"浮点数","slug":"浮点数","permalink":"http://yoursite.com/tags/浮点数/"}]},{"title":"22 操作系统","date":"2017-11-14T16:00:00.000Z","path":"2017/11/15/code_22/","text":"为了让一切能正常工作，微处理器在复位的时候需要执行一些代码，称为初始化代码（initialization code）。堆栈指针在运行初始化代码的时候会被设置，以保证堆栈处于内存的有效区域内。位了不让屏幕显示随机字符，初始化代码还把视频显示器内存中的每个字节设置成十六进制数20h，在ASCII码中这是一个空格符。此外，初始化代码还要把光标位在第一行第一列的位置——OUT（Output）指令可以完成这一操作：光标在视频显示器上是以画线的形式出现的——它可以显示出下一个要输入字符的位置。下一条命令是EI，它能开启中断，以便微处理器能够响应键盘中断。EI指令后面是HLT指令，它能是微处理器停止工作。 键盘处理程序对每个按键进行相应的处理，然后执行RET（Return）指令以返回HLT语句，等待另一个键盘中断。 在键盘处理程序内含有一个命令处理程序（command processor），它可以解释为三条命令：W命令、D命令和R命令。 W 1020 35 4F 78 23 9B AC 67运行这条命令，命令处理器会从内存地址1020h处开始，把35、4F等十六进制表示的字节写入内存中。要完成这项工作，键盘处理程序需要把ASCII码转换成字节。 D 1030命令处理程序会把地址1030h开始的11个字节的内容显示出来（之所以说是11字节，是因为每行可以容纳40个字符的显示器上，出去显示命令与地址标识，后面能显示的也只有这么多了）。 R 1000执行此命令意味着“处理器会运行从地址1000h开始的一段程序”。首先命令处理程序把1000h存储在寄存器对HL中，接着执行指令PCHL，把HL所存储的值加载到程序计数器中，然后跳转到程序计数器指向的地址并运行程序。 键盘处理程序及命令处理程序简化了许多工作，可以说是计算机发展的一个里程碑。 仅仅有上面的命令还是不够的，还需要向命令处理程序添加新命令。 S 2080 2 15 3运行这条命令后，在磁盘的第2面、第15道、第3扇区中将存放起始地址为2080h的内存块数据。类似的，还可以通过加载（Load）命令，把磁盘上相应扇区的内容写回到内存中，如下所示：L 2080 2 15 3 所有的东西存储在磁盘的什么位置，都需要你手工记录下来，这个工作挺多，也挺麻烦。处于这个原因，文件系统（file system）应运而生。 CP/M(Control Program for Micros)是最重要的8位微处理器操作系统。CM/P操作系统是放在磁盘上的。单面、8英寸的磁盘是早期的CP/M最常用的存储介质，他有77个磁道，每个磁道有26个扇区，每个扇区的大小是128个字节。CP/M系统存放在磁盘最开始的两个磁道。在启动计算机时，需要把CP/M从磁盘调入到计算机的内存中。 剩下的75个磁道中的扇区来存放文件，这些扇区按分配快（allocation blocks）进行分组。每个分配块中有8个扇区，总计1024个字节。可以计算，在磁盘上共有243个分配块，编号为0~242。 目录（directory）区占用最开始的两个分配块（编号为0和1）中。目录区是磁盘中的一个非常重要的区域，磁盘文件中每个文件的名字和其他的一些重要信息都存在该区域，根据目录就能够很方便、高效地查找文件。存放目录也需要占用空间，磁盘上每个文件对应的目录项（directory entry）大小均为32字节，由于目录大小为2048字节，所以这个磁盘上最多可以存放64个文件。 每一个32字节的目录项包含以下信息 字节 含义 0 通常设为0 1~8 文件名 9~11 文件类型 12 文件扩展 13~14 保留（设置为0） 15 最后一块扇区数 16~31 磁盘存储表 第一个字节用来设置文件的共享属性，只有文件系统被两个或更多人同时共享时才设置此字节为1。在CP/M中，这个字节跟地13、14字节一样，通常设置为0。 CP/M中每个文件的文件名有两部分构成，第一部分称为文件名（filename），文件名最多由8个字符构成，目录项的第1~8字节用来存储文件名。第二部分称为文件类型（file type），最多由3个字符表示，这些字符存储在目录项的第9~11字节中。txt表示文本文件，此文件只包含ASCII码，COM表示这个文件存放的是8080机器码指令，或者说是一段程序。当命名一个问及那时，通常一个点来隔开两部分，如下所示： myletter.txt calc.com 目录项中的第16~31字节是磁盘存储表，它能够标明文件所存放的分配块。假设磁盘存储表前4项分别为14h、15h、07h、23h，其余项全为0，这表明文件占 用了4个分配块的空间，大小为4KB，而实际上文件可能并没有用完4KB空间，因为最后一个分配块往往只有部分扇区被使用。目录项的15字节标明最后一个分配块到底用了多少个128字节的扇区。 磁盘存储表的长度为16字节，最多可以容纳16384字节的文件，如果文件的长度超过16KB，就需要多个目录项来表示，这种方法称为扩展。如果一个大文件使用目录项扩展来，则将第一个目录项的第12字节设置为0，第二个目录项的第12字节则设置为1，以此类推。 文本文件，通常称之为ASCII文件（ASCII file）、纯文本文件（text-onlu file）或纯ASCII文件（pure-ASCII file）。其余的文件称为二进制问及那（binary file），在CM/P中，COM文件存放的是二进制的8080机器码，它是二进制文件。 假设一个小文件中包含三个16位数，如：5A48h、78BFh和F510h。如果此文件的是二进制文件，只要6字节就可以了。48 5A BF 78 10 F5这是采用Intel格式来存储的，放在前面的是低位，放在后面的高位。 假如上面的三个16位数用ASCII文本文件来存放，则文件中保存的数据如下所示：35 41 34 38 68 0D 0A 37 38 42 46 68 0D 0A 46 35 31 30 68 0D 0A显示如下：5A48h78BFhF510h 也可以用如下的形式来表示包含的这三个数的ASCII文本文件：32 33 31 31 32 0D 0A 33 30 39 31 31 0D 0A 36 32 37 33 36 0D 0A这是用十进制数的ASCII码形式来表示上述三个数，这两种表示形式是等价的，如下所示：231123091162736 显然文本文件更易于人们阅读，同样，与十六进制相比，十进制更符合人们的习惯，没理由使用十六进制而拒绝十进制。 操作系统的引导过程完成后，随机存储器（RAM）的最高地址区域用来存放CP/M，加载完CP/M后，整个内存空间的组织结构如下所示。 地址 区域 0000h 系统参数 0100h 临时程序区域（TPA） 。 控制台命令处理程序（CCP） 。 基本磁盘操作系统（BDOS） 最高地址： 基本输入/输出系统（BIOS） 控制台命令处理程序（Console Command Processor，CCP）、基本磁盘操作系统（Basic Disk Operating System，BDOS）和基本输入/输出系统（Basic Input/Output System，BIOS）是CP/M的三个组成部分，这三个部分只占用了6KB大小的内存空间。在拥有64KB内存空间的计算机中，大约58KB被临时程序区（Transient Program Area，TPA）占用，但是这58KB一开始是空的。 操作系统一个重要功能就是让程序能够方便地访问计算机的硬件，操作系统提供的这种访问操作称为API（Application Programming Interface），即应用程序接口。 16位操作系统QDOS（Quick and Dirty Operating System）的开发在很多方面都借鉴了CP/M的思想。QDOS系统被微软公司注册后更名为86-DOS，后来将其更名为MS-DOS（Microsoft Disk Operating System）。这就是著名的MS-DOS系统。由于MS-DOS的影响力更大，其很快称为了标准。 CP/M的文件系统在MS-DOS没有被继续使用，在MS-DOS中，文件系统是以文件分配表（FAT，File Allocation Table）的形式来组织的。将磁盘空间分成簇（cluster），簇的大小由磁盘空间的大小来决定的——从512字节到16K字节不等。每个文件占用若干簇。文件的目录项只记录文件起始簇的位置，而磁盘上没一簇的下一簇的位置由FAT来记录。 每个目录项在MS-DOS磁盘上占用32字节，其命名形式跟CP/M上的8.3（名称8个字节，类型3个字节）一样，只是术语有点区别，最后的三个字符称作文件扩展名，而非CP/M中的文件类型。MS-DOS目录项中没有包含分配块列表，他主要包括如下所示的有用信息：文件的最后修改日期、时间、和文件的大小等。 硬盘容量越大存储的文件也就越多，存储的文件越多，查找某个指定的文件或组织文件也就越困难。 为了解决这个问题，MS-DOS 2.0引入了层次文件系统（hierarchical file system），他只是在原有的文件系统上做了一些小的改动。在层析文件系统中，有些文件本身可能就是目录，也就说这些文件包含其他文件，其中的一些可能还是目录。再次盘中，常规的目录称为根目录（root directory），子目录（subdirectories）是包含在其他目录里的目录。有了目录（有时称作文件夹，folder），就可以很方便地对相关文件进行分组，所以目录在磁盘文件的管理中骑着非常重要的作用。 MS-DOS的层析文件系统和其他一些功能都是从UNIX操作系统借鉴来的。UNIX不针对具体的计算机硬件平台，具有很好的可移植性（portable），也就意味着它在各种机器上都可以运行。 使用UNIX系统的计算机通过时分复用（time sharing）技术——这种技术允许多个用户同时与计算机进行交互——来达到这个目的。计算机连接多个配备了显示器和键盘的终端（terminals），每个用户通过这些终端访问计算机。通过在终端间的快速切换，使用户感觉在这台计算机似乎只为自己工作，而其实计算机同时在为多个用户服务。 如果在一个操作系统上同时运行多个程序，则成此系统为多任务（multitasking）操作系统。虚拟内存是指，在磁盘上划出部分空间用做保存临时文件，程序需要把暂时不需要的内存块放到临时文件里，带需要时再把它调入内存。 近年来，非常流行系统有开源系统Linux系统、苹果公司的Macintosh和微软的Windows系统。","tags":[{"name":"编码(隐匿在计算机软硬件背后的语言)","slug":"编码-隐匿在计算机软硬件背后的语言","permalink":"http://yoursite.com/tags/编码-隐匿在计算机软硬件背后的语言/"},{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/tags/操作系统/"},{"name":"键盘处理程序","slug":"键盘处理程序","permalink":"http://yoursite.com/tags/键盘处理程序/"},{"name":"命令处理程序","slug":"命令处理程序","permalink":"http://yoursite.com/tags/命令处理程序/"}]},{"title":"21 总线","date":"2017-11-13T16:00:00.000Z","path":"2017/11/14/code_21/","text":"地址总线。这些信号由微处理器产生，通常对RAM进行寻址操作，当然也可以用来对连接到计算机其他设备进行寻址从、操作。 数据输出信号。这些信号也是由微处理器产生的，用来吧数据写入到RAM或其他设备。 数据输入信号。这些信号由计算机的其他部分提供的，并由微处理器读取。通常情况下，数据输入信号由RAM输出，这就解释了微处理器是怎样从内存中读取内容的。 控制信号。这些信号是多种多样的，通常与计算机内所用的特定的微处理器相对应。控制信号可以产生于微处理器，也可以由与微处理器通信的其他设备产生。 总线还可以为计算机不同电路板供电。 如果设计出来的总线不适合高速传输的话，就会出现射频干扰，这会使附近的收音机和电视机产生静电或其他噪声。 片选信号置1时，芯片不被选中，意思就是说，不会响应读写信号。 2102是一款存储器芯片，存储容量可以达到1024位，这个数值可以根据地址信号（A0~A9）控制。若让你为8位的微处理器组织存储器的话，你会怎么做呢？ 把8个这样的芯片连在一起组成1024*8 RAM，即1KB的RAM。一块s-100板就能容纳64个。这样一来，就提供了8KB的存储空间。一般我们不这样做，更合适的方法是，用32个芯片组成一个4KB的存储器。位了存储完整的字节，而连在一起的芯片的集合，称为存储体。例如，一个4KB大小的存储器就由4个存储体组成，而每个存储体又包含8个芯片。 像8080、6800，由16位地址，可用来寻址64KB的存储空间。如果你制作了一个包含4个存储体、大小为4KB的存储器板，则存储器板上的16位地址信号就有如下所示的功能。 A15 A14 A13 A12 A11 A10 A9 A8 A7 A6 A5 A4 A3 A2 A1 A0 A0~A9 直接与RAM芯片相连接；A10和A11用来选择4个存储体中要被寻址的哪一个；A12~A15确定哪些地址申请用这块存储器板，换言之，就是这块存储器板响应哪些地址。微处理器整个存储空间的大小是64KB，被分为16个不同的区域，每个区域的大小是4KB，我们设计的4KB存储器板占用了其中一个区域。这个16个区域划分情况如下。 0000h~0FFFh1000h~1FFFh2000h~2FFFh…………F000h~FFFFh 如果4KB存储器板使用了A000h~AFFFh地址区域。这就意味着，第一个存储体占用了地址A000~A3FFh，第二个占用了地址A400h~A7FFh，第三个占用了地址A800h~ABFFh，剩下的AC00h~AFFFh地址空间分给了第四个存储体。 你可能会认为我们需要8个4-1选择器，用来从4个存储体中选择正确的数据输出信号。但我们并没有这么做，下面讨论下原因。 一个集成电路的输出为1，另一个集成电路为0，若把这两个输出连接在一起，结果又是什么呢？恐怕谁也无法回答。就是由于这种不确定性，一把你不会把集成电路的输出信号连接在一起。 2102芯片的数据输出信号是三态的，也就是说，除了逻辑0和逻辑1之外，数据输出信号还有第三种状态。我们必须清楚地认识这种状态——它其实是一种“真空”状态，就像芯片的引脚上什么也没连一样。当片选信号为1时，2102芯片的数据输出信号就会进入这种状态。这样一来，我们可以把四个存储体响应的数据输出信号连接在一起，并且把8个输出复用作为总线的8个数据输入信号。 之所以强调三态输出的概念，是因为它对总线的操作是至关重要的。几乎所有连接在总线上的器件都使用由总线传递而来的数据输入信号。但不管何时，连接在总线上的电路板中只有一个能确定总线数据输入信号的类型，其他电路板处于三种状态中的无效状态。 2102是一款静态随机访问存储器芯片（static random access memory，SRAM），它与动态访问存储器（Dynamic Random Access Memory，DRAM）是不同的。通常对于每1位存储空间，SRAM需要用4个晶体管，但DRAM只需要1个晶体管，但DRAM需要较复杂的外围支持电路，这正是它的缺点。 DRAM芯片在使用时需要定期访问其他存储器中的内容，尽管有时并不需要这些内容。这一过程称之为更新周期，每秒钟都必须进行几百次。这种做法就好像位不让某人入睡而每隔一段时间就用手肘轻推他一样。 尽管业界在使用DRAM上有些争论，但近年来，DRAM芯片的容量日益增加，使得DRAM最终成为标准。 电子射线管（cathode-ray tube， CRT），他从外观上看就像电视机一样。连接到计算机上的CRT为视频显示器（video display）或监视器（monito）。而称可以为视频显示器提供信号的电子元件为视频适配器（video display adapter）。通常在计算机中，视频适配器是独立存在的，它们拥有自己的电路板，也就是我们常说的显卡（video board）。 表面看来，视频显示器或电视机的二位图像很复杂，但实际上它是由一束连续的光束涉嫌迅速扫描屏幕而形成的。射线从屏幕左上角开始，从左到右进行扫描，到达屏幕边缘后又折回向左，进行第二行扫描。当完成了对最后一行的扫描时，射线不会停下来，它会从屏幕的右下角返回到屏幕的左上角（垂直），并重复上一过程。就拿美国的信号来说，每秒钟要进行60次这样的扫描。由于扫描的速度很快，所以不会看到图像出现闪烁的现象。 电视采用的隔行扫描技术。帧是一个完整的静态视频图像，两个场才能形成一个单独的帧。整个镇的扫描线分由两个场来完成——偶数扫描线属于第一个场，奇数扫描线属于第二个场。水平扫描频率，就是扫描每个水平行的速率，例如15750Hz。把这个数除以60Hz，结果是262.5行，这正是每个场所包含的扫描线的数目，这个帧的扫描线的数目是场的两倍，也即525行。 不管隔行扫描技术是怎么实现的，组成视频的图像的连续射线都是由一个连续的信号所控制。虽然一套电视节目的声音和图像部分是一起播出的，但若想把它们从广播出去或者通过有线电视系统传送出去，就不得不分开进行。 黑白电视机的视频信号十分简单。每秒钟扫描60次，扫描信号包含一个垂直同步脉冲（vertical sync pulse），用来指示一个场的开始。这个脉冲位0V，宽度约为400ms。相比较而言，水平同步脉冲（horizontal sync pulse）则用来指示每个扫描行的开始：视频信号为0V,宽度为5ms，每秒钟出现15750次。在两个水平同步脉冲之间，信号的电压是在0.5~2.0V范围变化的，其中0.5V表示黑色，2.0V表示是白色，处于两者之间的电压则表示一定的灰度。 电视能响应的信号变化频率是有上限的我们成这一上限位电视机带宽。带宽限制了视频信号从黑到白又回到黑这一变化的速率。 从计算机的角度来说，我们可以把视频图像想象成有离散点组成的矩形网格，这些离散点称为像素（picture element）。 如果电视机的带宽为4.2Mhz，它就允许2个像素每秒420万次的变化，或者——用2*42000000除以水平扫描速率15750——每个水平扫描行有533个像素。但并不是所有的像素都可用，约1/3的像素被隐藏了起来，这样算来，水平扫描行上可用的像素约为320个。 与水平方向类似，垂直方向上525个像素也不是都可用，垂直方向上有着合理的像素数目200。 因此我们可以说，早期普通电视机的视频适配器的分辨率是320×200，即水平方向上有320个像素、垂直方向上有200个像素。 每个字符用8*8的网格（64个像素）来表示。每个字符都被定义位一个7位的ASCII码，但每个字符也与64位比特（位）相关，这64比特决定了字符会显示为什么样子。 字符生成器也是视频适配器板上的一部分，包含了所有ASCII码字符的像素图。通常，它是只读存储器（read-only memory），即ROM。它是一种集成电路，在生产时里面已经填入了数据，固定的地址输出的数据是不变的。ROM中并没有数据输入信号，这点与RAM不同。 上述的显示适配器需要多大的RAM呢？视频显示器的没屏幕能显示25行、每行40个字符，总共1000个字符，每个字符有7位的ASCII码。1000*7bit，大约1024字节，即1KB。 你可以把ROM看做可以进行代码转换的电路。每片ROM都有7个地址信号（用来表示ASCII码）以及64个数据输出信号，里面存储了128个ASCII码字符的8*8像素图。因此，ROM可以实现7位ASCII码到64位码（定义了字符现实的外观）的转换。但是64个数据输出信号会使芯片变得很大。更合适的做法是，用10个地址信号和8个输出信号。其中7个地址信号是用来确定ASCII码字符的（这个7个地址位来自视频板上RAM的数据输出）。其他三个地址信号则用来表示行。举个例子来说，最高行用000表示，最低行用111表示。8个输出就是每行的8个元素。 ASCII码为41h，大写字母A。总共有8行，每行8位。下表给了字母A的10位地址和数据输出信号。 地址 数据输出 1000001 000 00110000 1000001 001 01111000 1000001 010 11001100 1000001 011 11001100 1000001 100 11111100 1000001 101 11001100 1000001 110 11001100 1000001 111 00000000 0 1 2 3 4 5 6 7 8 1 * * 2 * * * * 3 * * * * 4 * * * * 5 * * * * * * 6 * * * * 7 * * * * 8 像不像一个大写的A！！！ 有的显示适配器不仅仅只显示文本，还可以显示其他数据，我们称这样的显示适配器位图形适配器（图形显卡）。通过向图像显卡的RAM写入数据，微处理器就可以画出图形了。320*200的图形显卡有64000个像素，如果每个像素需要1位RAM，那么这样的图形显卡就需要64000位的ram，即8000字节。然而，这只是最低的要求。1位是和1个像素相对应的，只能用来表示两种颜色——例如黑色和白色。 电视机不仅仅显示黑色和白色，还可能显示不同灰度的色彩。为了让图像显卡拥有这种功能，通常每个像素对应的RAM中的一整个字节，其中00h表示黑色，FFh表示的是白色，介于两者之间的数值对应不同的灰度。一个320*20的视频版若能显示256中灰度，就需要64000字节的RAM。 如果想要显示出丰富多彩的颜色，每个像素需要至少3个字节，因为每种颜色都是由红、绿、蓝三原色的不同组合而形成的。这么算来，就需要192000字节的RAM。 颜色数量 = 2的每个像素赋予的比特数次方 电影图像的宽比高多出1/3.图像的宽和高之比，称为屏幕长宽比。通常，我们把爱迪生和迪克生所确定的这个表示为1.33：1，或者不想使用小数点的话，就表示位4：3。 其实键盘上的每个按键就是一个简单的开关。按键按下，开关就会闭合。现在个人计算机的键盘有100多个按键，但类似打字机的键盘可能只有48个按键。 键盘硬件提供的代码为扫描码（scan code）。当按下键盘的某个按键时，一小段计算机程序就会计算出这个按键对应的ASCII。 如果键盘上有64个键，就需要6位的扫描码，也就需要一个6位的几乎器，因为2^6=64。用一个3-8译码器和一个8-1选择器就可以把这些按键组成一个8×8的阵列。如果键盘上的数目为65~128个，就需要7位的扫描码。你就可以用一个4-16译码器和一个8-1的选择器（或一个3-8译码器和一个16-1选择器）把这些按键组成一个8×16的阵列。 介绍一下能够长期存储信息的外围设备。前面曾提到，无论是用继电器、电子管，还是用晶体管作为介质构成随机访问存储器，一旦掉电，他存储的内容就会丢失。长期以来，人们通过在纸上或卡片上打孔来保存永久信息。 打孔卡带和纸带的使用存在一些问题：不可重用性，效率很低。 磁介质存储器（magnetic storage）逐渐发展成目前最为流行的长期存储器。录音电话机，声音通过电磁特和可变长度的金属丝来记录，它根据声音的高低来磁化金属丝。当磁化的金属丝切割电磁线圈运动的时候，产生的电流强度与其磁化程度有关。不论使用何种磁化介质，记录和读取信息都是利用电磁铁的磁头（head）来完成的。 将铁粒子覆盖在很长度纸带上，不久以后，纸带被强度更高的醋酸盐纤维取代，而一种更耐久、更知名的记录介质从此诞生——卷轴式磁带。 想要快速移动到磁带的任一位置是不可能的，它只能顺序访问，频繁地快进和倒带会话费很多时间。 从几何学角度来看，磁盘是能够实现快速访问的介质。磁盘围绕其中心旋转，连到臂上的一个或多个磁头从磁盘外沿向中间移动，通过磁头可以快速访问磁盘上的任何区域。 磁盘分为软盘（floppy disk）和硬盘（hard disk， 或fixed disk）。软盘是由单面覆盖磁性物质的塑料片组成，外面是由厚纸板包装，起到保护作用。使用软盘时候，必须将其插入到软盘驱动器。 硬盘是由多个金属磁盘构成的，他永久驻留在驱动器里。相对于软盘来说，它的存取速度更快、存储量更大，唯一的缺点就时硬盘本身是固定的，不能移动。 磁盘的表面被划分为许多同心圆，称为磁道（tracks），每个磁道又被划分为像圆饼切片形状的扇区（sectors），每个扇区可以存放一定数量的字节，统称为512字节。 为了能和微处理器交互数据，这些电气接口与微处理器之间还需要有额外的接口与之相连。这些接口都利用DMA（direct memory access）技术来使用总线，DMA可以不经过微处理器，实现数据在随机访问存储器和硬盘之间直接传送。这样的传送是以块位单位进行的，每次传输的块大小是磁盘扇区自己的倍数，通常是512字节。 memory（内存）仅仅表示半导体随机访问存储器；storage（存储器）用来指任何的存储设备，通常包括软盘、硬盘和磁带。 当微处理器发出一个地址信号，通常是寻址随机访问存储器，而非磁介质存储器。微处理器不能直接从磁盘读取数据，需要将所需的数据从磁盘调入内存（随机访问存储器），然后才能对其访问，当然这需要额外的步骤。微处理器需要执行一段小程序，这段小程序会访问磁盘，并将数据从磁盘调入内存。 关于随机访问存储器和磁介质存储器之间的差别，有个形象的比喻可以帮助我们加深理解：随机访问存储器就想办公桌的桌面，上面的任何东西都可以拿来直接使用；而磁介质存储器就行一个文件柜，里面的东西不能直接使用，如果想要使用放在文件柜里的某件东西，你需要站起来，走到文件柜面前，查找需要的文件，然后带回桌面。如果桌面太拥挤，没有空间放置需要的文件，还需要把桌面上暂时不用的东西线放回到文件柜中。","tags":[{"name":"编码(隐匿在计算机软硬件背后的语言)","slug":"编码-隐匿在计算机软硬件背后的语言","permalink":"http://yoursite.com/tags/编码-隐匿在计算机软硬件背后的语言/"},{"name":"微处理器和RAM之间的调用","slug":"微处理器和RAM之间的调用","permalink":"http://yoursite.com/tags/微处理器和RAM之间的调用/"},{"name":"图像的形成","slug":"图像的形成","permalink":"http://yoursite.com/tags/图像的形成/"},{"name":"磁盘","slug":"磁盘","permalink":"http://yoursite.com/tags/磁盘/"}]},{"title":"20 ASCII码和字符转换","date":"2017-11-12T16:00:00.000Z","path":"2017/11/13/code_20/","text":"数字计算机中断存储器唯一可以存储的是比特，因此如果要想在计算机上处理信息，就必须把它们按位存储。 1874年由法国电报服务公司职员埃米尔·波多发明了可以打印的电报机，划时代的波多电传码也应运而生。。即使在今天看来，这种编码十分“经济划算”，每一个文本字符都采用5位编码。 十六进制 Baudot字符 十六进制 Baudot 字符 00 10 E 01 T 11 Z 02 回车 12 D 03 O 13 B 04 空格 14 S 05 H 15 Y 06 N 16 F 07 M 17 X 08 换行 18 A 09 L 19 W 0A R 1A J 0B G 1B 数字转义符号 0C I 1C U 0D P 1D Q 0E C 1E K 0F V 1F 字符转义符号 是打印机的滑架回到起始位置，这样打印下一行可以从纸的最左边开始，这就是回车。将打印机的滑架移至正在使用中的位置的下一行，这就是换行。这两个操作构成了键盘上的enter键。 数字转义编码后的所有的编码都会被解释位数字或标点符号。 十六进制 Baudot字符 十六进制 Baudot 字符 00 10 3 01 5 11 + 02 回车 12 身份不明 03 9 13 ? 04 空格 14 ‘ 05 # 15 6 06 , 16 $ 07 . 17 / 08 换行 18 - 09 ) 19 2 0A 4 1A 响铃 0B &amp; 1B 数字转义符号 0C 8 1C 7 0D 0 1D 1 0E : 1E ( 0F = 1F 字符转义符号 使用转义码会出现很多麻烦。 所有的大小写字母加起来共需52个编码，0~9数字需要10个编码，加起来共62个，如果算上一些标点符号，数量超过了64个，也就是说，一个编码至少需要64比特。但无论如何字符数应该不超过128个，而且应该远远不够128个，也就是说编码长度不会超过8位。所以答案就是7。在采用7位编码时，不需要转义字符，而且可以区分字母的大小写。 这种标准已经存在并且被广泛使用，它被称为美国信息交换标准码（American Standard Code for Information Interchange），简称为ASCII码。 十六进制 ASCII 字符 十六进制 ASCII 字符 20 空格 30 0 21 ! 31 1 22 “ 32 2 23 # 33 3 24 $ 34 4 25 % 35 5 26 &amp; 36 6 27 ‘ 37 7 28 ( 38 8 29 ) 39 9 2A * 3A : 2B + 3B ; 2C , 3C &lt; 2D - 3D = 2E . 3E &gt; 2F / 3F ? 十六进制 ASCII 字符 十六进制 ASCII 字符 40 @ 50 P 41 A 51 Q 42 B 52 R 43 C 53 S 44 D 54 T 45 E 55 U 46 F 56 V 47 G 57 W 48 H 58 X 49 I 59 Y 4A J 5A Z 4B K 5B [ 4C L 5C \\ 4D M 5D ] 4E M 5E ^ 4F O 5F _ 十六进制 ASCII 字符 十六进制 ASCII 字符 60 ` 70 p 61 a 71 q 62 b 72 r 63 c 73 s 64 d 74 t 65 e 75 u 66 f 76 v 67 g 77 w 68 h 78 x 69 i 79 y 6A j 7A z 6B k 7B { 6C l 7C 6D m 7D } 6E n 7E ~ 6F o 在ASCII码中，一个大写字母与其对应的小写字母的ASCII码值相差20h。这种规律大大简化了程序代码的编写。 如果一个小写字母在累加器A中，把它转换成大写字母，有两种方法。第一种：SBI A, 20h第二种：ANI A, DFh ANI指令是用来”与”一个立即数。在上面的例子中，累加器中的数值与DFh执行按位与操作，其中DFh转成成二进制数就是1101 1111。除了自左向右数的第3位被置为0外，A中的其他位军被保留。通过将这一位置为0，我们是实现了将小写字母的ASCI码转换成大写字母的目的。 十六进制编码 缩写 控制字符的含义 00 NUL 空字符 01 SOH 标题开始 02 STX 文本开始 03 ETX 文本结束 04 EOT 传输中止 05 ENQ 询问 06 ACK 应答 07 BEL 响铃 08 BS 回退 09 HT 水平制表 0A LF 换行 0B VT 垂直制表 0C FF 换页 0D CR 回车 0E SO 移出 0F SI 移入 10 DLE 转义 11 DC1 设备控制1 12 DC2 设备控制2 13 DC3 设备控制3 14 DC4 设备控制4 15 NAK 否定应答 16 SYN 同步 17 ETB 块传输结束 18 CAN 取消 19 EM 媒介取消 1A SUB 替代字符 1B ESC 跳出 1C FS 文件分割或信息分割4 1D GS 组分割或信息分割3 1E RS 记录分割或信息分割2 1F US 单元分割或信息分割1 7F DEL 删除 TAB的作用就是在下一个水平位置即在距前一个字符的间距为字符长度8倍的位置打印下一个字符。 有一些控制字符甚至沿用至今，例如换页符，它使得打印机跳出当前页，并开始准备打印下一页。 回退符可以用来打印复合字符，比如说声调。 回车符使得打印头移至当前页面的最左端，换行符使打印头转移至当前位置下一行。这两个控制符都使得打印头移至新的一行。单独使用回车符可以在现有行上打印，而单独使用换行符可以跳到下一行，无需移动到最左端。 在ASCII码刚刚问世的那个时代，存储器的价格贵的令人咋舌，有一些观点认为ASCII码可以采用6位编码并配合转义字符来使用，这样既可以区分大小写又节约了存储器。这种方案并没有被采纳，当时还有一些人认为ASCCI码应采用8位编码。今天看来，8位的字节存储已经作为了一种标准。尽管ASCCI码从技术的本质上来看是7位编码，但仍以8位的形式存储。 尽管ASCCI码是计算机领域最重要的标准，但它并不是十全十美的，因为它太 美国化了！ASCII码中包含美元符号，而英镑符号怎么办？ 近十年来出现了不同版本的扩展的ASCII码，多个不同的版本严重影响了编码的一致性，导致了混淆和不兼容。 Unicode（统一化字符编码标准）。相对于ASCII的7位编码，Unicode采用了16位编码，每一个字符需要2个字节。编码范围为0000h~FFFFh，总共可以表示65536个不同字符。","tags":[{"name":"编码(隐匿在计算机软硬件背后的语言)","slug":"编码-隐匿在计算机软硬件背后的语言","permalink":"http://yoursite.com/tags/编码-隐匿在计算机软硬件背后的语言/"},{"name":"ASCII码","slug":"ASCII码","permalink":"http://yoursite.com/tags/ASCII码/"}]},{"title":"19 两种典型的微处理器","date":"2017-11-11T16:00:00.000Z","path":"2017/11/12/code_19/","text":"微处理器是将计算机中央处理器的所有构件整合在一起，集成在一个硅芯片上。 8080中，加载指令和保存指令的操作码分别是3Ah和32h，它们的助记符分别是STA（Store Accumulator） 和LDA（Load Accumulator）： 操作码 指令 32 STA [aaaa], A 3A LDA A, [aaaa] 8080芯片的微处理器的内部除累加器外还设置了6个寄存器（register），每个寄存器可以放一个8位数。这些寄存器和累加器非常相似，事实上累加器被视为一种特殊的寄存器。这个6个寄存器和累加器一样，本质上都是锁存器。 通常把两个8位的寄存器H和L合起来构成一个16位的寄存器对（register pair），称作HL，H用来保存高字节而L用来保存低字节。这个16位的值通常用来对存储器寻址。 很多计算机程序都同时用到多个数据，将这些数据存存放在寄存器比存放在存储器更便于访问，因为程序访问内存的次数越少其执行速度越快。 MOV指令主要用来把一个寄存器中的内容转移到另一个寄存器（也可能就是原来的寄存器）。 操作码 指令 操作码 指令 40 MOV B,B 50 MOV D,B 41 MOV B,C 51 MOV D,C 42 MOV B,D 52 MOV D,D 43 MOV B,E 53 MOV D,E 44 MOV B,H 54 MOV D,H 45 MOV B,L 55 MOV D,L 46 MOV B,[HL] 56 MOV D,[HL] 47 MOV B,A 57 MOV D,A 48 MOV C,B 58 MOV E,B 49 MOV C,C 59 MOV E,C 4A MOV C,D 5A MOV E,D 4B MOV C,E 5B MOV E,E 4C MOV C,H 5C MOV E,H 4D MOV C,L 5D MOV E,L 4E MOV C,[HL] 5E MOV E,[HL] 4F MOV C,A 5F MOV E,A 60 MOV H,B 70 MOV [HL],B 61 MOV H,C 71 MOV [HL],C 62 MOV H,D 72 MOV [HL],D 63 MOV H,E 73 MOV [HL],E 64 MOV H,H 74 MOV [HL],H 65 MOV H,L 75 MOV [HL],L 66 MOV H,[HL] 76 HLT 67 MOV H,A 77 MOV [HL],A 68 MOV L,B 78 MOV A,B 69 MOV L,C 79 MOV A,C 6A MOV L,D 7A MOV A,D 6B MOV L,E 7B MOV A,E 6C MOV L,H 7C MOV A,H 6D MOV L,L 7D MOV A,L 6E MOV L,[HL] 7E MOV A,[HL] 6F MOV L,A 7F MOV A,A LDA A, [aaaa]MOV B, [HL]第一种方式称做直接寻址；第二种方式称做间接寻址。 MOV操作码由8位组成：01dddsss其中ddd这3位是目标操作数的代码，sss这3位是源操作数的代码。它们所表示的意义如下：000 = 寄存器 B001 = 寄存器 C010 = 寄存器 D011 = 寄存器 E100 = 寄存器 H101 = 寄存器 L110 = 寄存器 HL 保存的存储器地址中的内容111 = 累加器 A 例如，指令MOV L, E 对应的操作码是01101011 用十六进制表示是6B。这与前面的表格是一致的。 可以设想一下，在8080内部可能是这样的：标记为sss的3位用于8-1数据选择器，标记为ddd的3位用来控制3-8译码器以此确定哪一个寄存器锁存了值。 寄存器B和C也可以组成16位的寄存器对BC，同样还可以用D和E组成寄存器对DE。如果这些寄存器对也包含要读取或保存的字节的存储器地址，可以用一下的指令实现： 操作码 指令 操作码 指令 02 STAX [BC], A 0A LDAX A, [BC] 12 STAX [DE], A 1A LDAX A, [DE] 另一种类型的传送指令称做传送立即数，它的助记符写作MVI。传送立即数指令是一个双字节指令，第一个字节为操作码，第二个是数据。这个单字节数据从存储器转移到某个寄存器，或转移到存储器的某个单元，改存储单元由HL寄存器对寻址。 操作码 指令 06 MVI B, xx 0E MVI C, xx 16 MVI D, xx 1E MVI E, xx 26 MVI H, xx 2E MVI L, xx 36 MVI [HL], xx 3E MVI A, xx MVI E, 37h 执行后，寄存器E存放的字节就是37h。这就是立即数寻址。 加法（ADD）、进位加法（ADC）、减法（SUB）和借位减法（SBB） 操作码 指令 操作码 指令 80 ADD A, B 90 SUB A, B 81 ADD A, C 91 SUB A, C 82 ADD A, D 92 SUB A, D 83 ADD A, E 93 SUB A, E 84 ADD A, H 94 SUB A, H 85 ADD A, L 95 SUB A, L 86 ADD A, [HL] 96 SUB A, [HL] 87 ADD A, A 97 SBB A, A 88 ADC A, B 98 SBB A, B 89 ADC A, C 99 SBB A, C 8A ADC A, D 9A SBB A, D 8B ADC A, E 9B SBB A, E 8C ADC A, H 9C SBB A, H 8D ADC A, L 9D SBB A, L 8E ADC A, [HL] 9E SBB A, [HL] 8F ADC A, A 9F SBB A, A CF(进位标志位)、ZF（零标志位）、SF（符号标志位）、PF（奇偶标志位）、AF（辅助仅为标志位）、 LDA、STA和MOV指令始终不会影响标志位，而ADD、SUB、ADC以及SBB指令会影响标志位的状态，集体情况如下： - 如果运算结果的最高有效位是1，那么符号位SF标志位置为1，表示该计算结果是负数。 - 如果运算结果为0，则零标志位ZF为1. - 如果运算结果“1”的位数是偶数，即具有偶数性，则奇偶标志位PF置为1；反之，如果“1”的位数是奇数，即运算结果具有奇数性，则PF置0.由于PF的这个特点，有时会被用来进行简单的错误检查。 - 当ADD和ADC运算产生仅为或者SUB和SBB运算不发生借位时，CF置为1。 - 辅助进位标志位AF只有在运算结果的低4位向高4位有进位时才置1。它只用于DAA（Decimal Adjust Accumulator， 十进制调整累加器）指令中。 操作码 指令 含义 37 STC 令CF置1 3F CMC 令CF取反 算数运算和逻辑运算指令 操作码 指令 操作码 指令 A0 AND A, B B0 OR A, B A1 AND A, C B1 OR A, C A2 AND A, D B2 OR A, D A3 AND A, E B3 OR A, E A4 AND A, H B4 OR A, H A5 AND A, L B5 OR A, L A6 AND A, [HL] B6 OR A, [HL] A7 AND A, A B7 OR A, A A8 XOR A, B B8 CMP A, B A9 XOR A, C B9 CMP A, C AA XOR A, D BA CMP A, D AB XOR A, E BB CMP A, F AC XOR A, H BC CMP A, H AD XOR A, L BD CMP A, L AE XOR A, [HL] BE CMP A, [HL] AF XOR A, A BF CMP A, A CMP指令通SUB指令类似，也是两个数相减，不同之处在于它并不在累加器中保存计算结果，计算的目的是为了设置标志位。这个标志位的值可以告诉我们两个操作数至今的大小关系。 MVI B, 25hCMP A, B指令执行后，累加器A中的值并没有变化。改变的是标志位的值，如果A中的值等于25h，则零标志位ZF置1；如果A中的值小于25h（没有发生借位），则进位标志位CF置1。 也可以对立即数进行这八种算术逻辑操作 操作码 指令 操作码 指令 C6 ADI A, xx E6 ANI A, xx CE ACI A, xx EE XRI A, xx D6 SUI A, xx F6 ORI A, xx DE SBI A, xx FE CPI A, xx 操作码 指令 27 DAA 2F CMA CMA是Complement Accumulator的简写。它对累加器按位取反。 DAA 即十进制调整累加器。DAA指令提供了一种用二进制码表示十进制的方法，成为BCD吗，程序员可以在该指令的帮助下实现十进制数的算术运算。BCD码采用的表示方法为，没4位为一段，每段所能表示的范围是：0000~1001，对应十进制的0~9。因为1字节有8位故可分割为2个段，因此在BCD码格式下，一个字节可以表示两位十进制数。 MVI A, 27hMVI B, 94hADD A, B累加器的结果是BBh，当然，这肯定不是BCD码。如果我们执行指令DAA，那么累加器最后保存的结果为21h，而且进位标志位CF置为1。因为十进制的27和94相加的结果为121。由此可以看到，使用BCD码进行十进制的算术运算是很方便的。 为了实现对一个数减1，我们把该数与FFh相加，它是-1的补码。8080提供了专门的指令用来对寄存器或存储器的数进行加1（称作增量）或减1（称作减量）操作。 操作码 指令 操作码 指令 04 INR B 05 DCR, B 0C INR C 0D DCR, C 14 INR D 15 DCR, C 1C INR E 1D DCR, E 24 INR H 25 DCR, H 2C INR L 2D DCR, L 34 INR [HL] 35 DCR, [HL] 3C INR A 3D DCR, A INR 和 DCR 都是单字节指令，它们可以影响CF之外的所有标志位。 循环移位（Rotate）指令，这些指令可以把累加器中的内容向左或向右移动1位，它们的具体操作如下： 操作码 指令 含义 07 RLC 使累加器循环左移 0F RRC 使累加器循环右移 17 RAL 带进位的累加器循环左移 1F RAR 带进位的累加器循环右移 这些指令只对进位标志位CF有影响。 假设累加器中存放的数是A7h，即二进制1010 0111。RLC指令使其每一位都向左移一位。最终的结果是，最低位（左端位低位，右端为高位）移出顶端移至尾部成为最高位。在这个例子中CF置1。执行RLC之后将变为0100 1111，同时CF置1。执行RRC之后将变为1101 0011，同时CF置1。 执行RAL指令时，累加器的数仍然按位左移，把CF中原来的值移至累加器中数值的最后一位，同时把累加器中的数据的原最高位移至CF。例如，假设累加器中一位之前的数是1010 0111且CF为0，执行RAL指令后，累加器中的数变为0100 1110而CF变为1。类似的，如果执行的是RAR指令，累加器中的数变为0101 0011而CF变为1。 当我们在程序中需要对某个数进行乘2（左移）或除2（右移）运算时，使用移位操作会使运算变得非常简单。 假设你在办公室工作，有人回到你办公桌前为你分配任务，每一项工作都用到某种文件夹。这些工作通常有这样的特点，在你完成某项工作之前首先要做另一项工作，并用到另一个文件夹。因此你只能放下第一个文件夹，并在它上面打开第二个文件夹继续工作。现在又有一个人给你分配了一个比前一项优先级跟高的工作，于是你打开第三个文件夹放在前面两个上，继续工作。而这项工作也需要先做一项相关工作，于是你只好打开第四个文件夹，现在你的办公桌上已经堆叠了四个文件夹了。 你可能已经注意到了，事实上，这些堆叠的文件夹很有序地保存了你干活的顺序轨迹。最上面的的文件夹总是代表优先级最高的工作，完成该工作之后就可以最接下来的工作了，以此类推。最后当你处理完办工桌上最后一个文件夹后，就可以回家了。 这种形式的存储器称作栈。使用栈时，我们已从底部到顶部的顺序把数据存入栈，并以相反的顺序把数据从栈中取出，因此该技术也称作后进先出存储器。 栈的功能是怎么实现的呢?首先，栈其实就是一段普通的RAM存储空间，只是这段空间相对独立不另作他用。8080微处理器设置了一个专门的16位寄存器对这段存储空间寻址，这个特殊的寄存器称为栈指针（SP, Stack Pointer）。 8080中，执行PUSH指令实际上是把16位的数据保存到栈，执行POP指令是把这些数据从栈中取回寄存器。 操作码 指令 操作码 指令 C5 PUSH BC C1 POP BC D5 PUSH DE D1 POP DE E5 PUSH HL E1 POP BC F5 PUSH PSW F1 POP PSW PUSH BC 指令将寄存器B和C的数据保存到栈，而POP BC则将这些数据从栈取回到寄存器B和C中，并且保持原来的顺序。最后一行指令中的PSW代表程序状态字，如前所述，这是一个8位的寄存器，用于保存标志位。最后一行到PUSH和POP指令的操作对象实际上是累加器和PSW，即压入和弹出栈的数据有累加器和PSW中的内容组成。如果你想把所有寄存器中的数据及全部标志位保存到栈，可以使用下面的命令：PUSH PSWPUSH BCPUSH DEPUSH HL 8080使用LXI指令为栈寄存器赋值，LXI是Load Extended Immediate的缩写即加载扩展的立即数。 操作码 指令 01 LXI BC, xxxx 11 LXI DE, xxxx 21 LXI HL, xxxx 31 LXI SP, xxxx 指令：LXI BC, 527Ah和下面两条指令等价：MVI B, 52hMVI C, 7Ah LXI指令保存一个字节。而且上表中最后一条指令LXI为栈指针赋了一个特殊的值。 类似的，还可以对寄存器对和栈指针对进行加1和减1操作，即把它们看做16寄存器。 操作码 指令 操作码 指令 03 INX BC 0B DCX BC 13 INX DE 1B DCX DE 23 INX HL 2B DCX HL 33 INX SP 3B DCX SP 下面的指令可以把任意两个寄存器组成的16位寄存器对的内容加到寄存器对HL中。 操作码 指令 09 DAD HL, BC 19 DAD HL, DE 29 DAD HL, HL 39 DAD HL, SP 这些指令可以减少操作的字节数。上面的第一条指令一般情况下需要6个字节。MOV A, LADD A, CMOV L, AMOV A, HADC A, BMOV H, ADAD指令一般用来计算存储器地址，只对进位标志位CF有影响。 接下来我们来认识一下各种各种的指令。下面两条指令的特点是操作码后面跟着2字节的地址，第一条指令把HL寄存器对的内容保存到该地址，第二条指令把该地址的内容加载到HL寄存器对。 操作码 指令 含义 22h SHLD [aaaa], HL 直接保存到HL中的数据 2Ah LhLD HL, [aaaa] 直接加载数据到HL 操作码 指令 含义 E9h PCHL PC, HL 将HL保存的数据加载到程序计数器 F9h SPHL SP, HL 将HL的数据加载到栈指针 操作码 指令 含义 E3h XTHL HL, [SP] 将HL中的内容和栈顶部2个字节进行交换 FBh XCHG HL, DE 把DE中的内容和HL中的内容进行交换 Call指令：执行指令后，程序计数器加载一个新的地址，而处理器会把原来的地址保存起来，保存到何处呢？最好的选择自然是栈了。 栈中保存的地址可以使处理器最后返回到转移前的位置。用于返回的指令称为Return（返回）。Return指令从栈中弹出两个字节，并把它们加载到PC中，这样就完成了返回到跳转点的工作。 在Call和Return指令的帮助下，程序员可以在程序中使用子程序，子程序是一段频繁使用的完成特定功能的代码。对于汇编语言来说，子程序是其基本的组成部分。 条件 操作码 指令 操作码 指令 操作码 指令 None C9 RET C3 JMP aaaa CD CALL aaaa Z not set C0 RNZ C2 JNZ aaaa C4 CNZ aaaa Z set C8 RZ CA JZ aaaa CC CZ aaaa C not set D0 RNC D2 JNC aaaa D4 CNC aaaa C set D8 RC DA JC aaaa DC CC aaaa Odd parity E0 RPO E2 JPO aaaa E4 CPO aaaa Even parity E8 RPE EA JPE aaaa EC CPE aaaa S not set F0 RP F2 JP aaaa F4 CP aaaa S set F8 RM FA JM aaaa FC CE aaaa OUT（输出）指令把累加器中的 内容写入到紧跟该指令后的字节所寻址的端口（port）。IN（输入）指令把一个字节从端口读入到累加器。它们的格式如下所示。 操作码 指令 D3 OUT PP DB IN PP 外围设备有时候需要获得处理器的注意。例如，当你按下键盘的某个键时，处理器应该马上注意到这个事件。这个过程由一个称为中断（interrupt）的机制实现，这是一个由外围设备产生的信号，连接至8080的INT输入端。 但是，当8080复位后，就不再响应中断。程序必须执行EI（Enable Interrupt）指令来允许中断，然后执行DI（Disable Interrupts）禁止中断。 操作码 指令 F3 DI FB EI 操作码 指令 操作码 指令 C7 RST 0 E7 RST 4 CF RST 1 EF RST 5 D7 RST 2 F7 RST 6 DF RST 3 FF RST 7 上面列出的指令都称为Restart（重新启动）指令，在其执行的过程中也会把当前PC中的数据保存到栈，这一点与CALL指令类似。但Restart指令在保存PC数据之后会立刻跳转到特定的地址，而且是根据参数的不同跳转到不同的地址：比如RST 0 将跳转到地址0000h处，RST 1将会跳转到地址0008h，一次类推，最后的RST 7 将跳转到0038h处。这些地址存放的代码都是用来处理中断的。例如，由键盘引起的中断将执行RST 4指令，程序将跳转到地址0020处，改地址存放的代码将负责从键盘读入数据。 操作码 指令 00 NOP NOP代表no op（operation）。无操作。NOP指令使处理器什么操作也不执行。 6800有一个16位的程序计数器PC、一个16位的栈指针SP、一个8位的状态寄存器（用来保存标志位），以及两个8位的累加器A、B。A和B都可以用做累加器（而不是把B作为普通的寄存器）。与8080不同，6800没有设置其他的8位寄存器。 6800设置了一个16位的索引寄存器，它可以用来保存16位的地址，其功能与8080的HL寄存器对相似。 6800实现的操作和8080大致相同，但对应的操作码和助记符是完全不同的。 8080假设低字节在前，高字节在后；而6800假设高字节在前，低字节在后。这两种方式分别称为little-endian（Intel方式）和big-endian（Motorola方式）。 微处理器的晶体管数量没18个月翻一倍，人们不禁要问：增加的这些大量的晶体管用来做什么呢？ 一些晶体管用来适应处理器不断增加的数据宽度——从4位、8位、16位到32位；另外一些新增的晶体管用来应对新的指令。例如支持浮点数的指令；还有在屏幕上呈现图片和电影。 现代处理器包括一个Cache（高速缓冲存储器），它是一个设置在处理器内部，访问速度非常快的RAM阵列，用来存放处理器最近要执行的指令。 上面提到的这些都需要在处理器内部增加更多的逻辑组件和晶体管。","tags":[{"name":"编码(隐匿在计算机软硬件背后的语言)","slug":"编码-隐匿在计算机软硬件背后的语言","permalink":"http://yoursite.com/tags/编码-隐匿在计算机软硬件背后的语言/"},{"name":"8080","slug":"8080","permalink":"http://yoursite.com/tags/8080/"},{"name":"6800","slug":"6800","permalink":"http://yoursite.com/tags/6800/"},{"name":"汇编语言","slug":"汇编语言","permalink":"http://yoursite.com/tags/汇编语言/"}]},{"title":"18 从算盘到芯片","date":"2017-11-10T16:00:00.000Z","path":"2017/11/11/code_18/","text":"算盘计算。 对数：两个数乘积就可以简单地表示为其对数之和。 一些人设计一些小装置期望代替对数表。其中，一种带对数刻度的滑尺久负盛名。 差分机和解析机。 人口普查：利用卡片上的288个穿孔来存储288位信息。 用继电器来构建计算机，被称为机电化计算机。资金的花费、空间的占用和能源的耗费。 真空管代替继电器。价格昂贵、耗电量大，以及产生的热量太多。 晶体管代替真空管。体积小、耗电量低，以及持久耐用。 集成电路需要经过复杂的工艺流程才能被制造出来，包括将硅片分层，然后非常精确地掺入杂质以及蚀刻不同的区域形成微小组件。 使用集成电路在一块电路板上制造一个完成的计算机处理器。 衡量微处理器性能的三个标准：（1） 4004是一个4位微处理器，这意味着处理器中数据通路宽度是4位。每次做加、减运算时，他只能处理4位的数字。（2） 4004每秒最大时钟频率为108, 000周期，即108KMz。也成主频。时钟频率决定了执行一条指令所需要的时间。（3） 4004的可寻址存储器只有640字节。","tags":[{"name":"编码(隐匿在计算机软硬件背后的语言)","slug":"编码-隐匿在计算机软硬件背后的语言","permalink":"http://yoursite.com/tags/编码-隐匿在计算机软硬件背后的语言/"},{"name":"微处理器的发展","slug":"微处理器的发展","permalink":"http://yoursite.com/tags/微处理器的发展/"}]},{"title":"17 自动操作","date":"2017-10-31T16:00:00.000Z","path":"2017/11/01/code_17/","text":"如果要把100个二进制加起来，你必须端坐在加法器前，并且耐心地输入所有的数并累加起来。但是当你终于完成时，却发现其中有两个数错了，而你只能重复一遍所有的功能。 如果把这100个二进制数输入到RAM阵列中而不是直接输入到加法器中，一旦修改一些数据，我们的功过将会变得容易的多。 用一个16位的计数器（第十四章构造的那种）就可以控制RAM阵列的地址信号。 我们没有办法使它停下来，在某一个时刻，RAM中剩余的所有待加之数都是00h，于是灯泡将不再“闪烁”。这时，你可以读取二进制的运算结果。但是当计数器达到FFFFh时，它会重新回滚到0000h，这时自动加法器会再一次把所有的数累加到已经计算出来的结果中去。 另外它只能做加法运算，并且只能做8位数的加法。 如果你不需要把100个数加在一起呢？如果你想做的是用自动加法器把50对数分别相加，得出50个不同的结果呢？ 先前的自动加法器都是用连接在锁存器的灯泡来显示运行结果的，但是如果你想对50对数分别求和的时候，这就不是一个好办法了。你可能会想到把运算结果存回到RAM阵列中。 如何配置一个自动加法器，使它不仅仅可以对一对数字做累加运算，还希望它能够自主确定要累加多少个数字，而且还能记住在RAM中存放了多少个计算结果。 我们希望它能做四件事：进行加法操作，首先它要把一个字节从存储器中传送到累加器中，这个操作称为加载（Load）。第二个操作吧存储其中的一个自家加（Add）到累加器的内容中去。第三个操作把累加器中的计算结果取出并存放（Store）到存储器中。另外我们需要一个方法令自动加法器停下（Halt）。 也许存放这些代码的最简单的方法是把它们存放在一个独立的RAM中。这个RAM和第一个RAM同时被访问。但是这个RAM中要存放的是不需要求和的数，而是一些代码，用来标记自动加法器对第一个RAM中指定地址要做的一种操作。这两个RAM可以分别被标记为“数据”RAM和“代码”RAM。 操作码 代码 Load（加载） 10h Store （保存） 11h Add （加法） 20h Halt （停止） FFh 以前8位加法器的输出是8位锁存器的输入，但现在为了执行Load指令，数据RAM阵列的输出有时也要作为8位锁存器的输入，这个新的变化需要一个2-1选择器来实现。 RAM阵列输出是Load指令，选择数据RAM的输出。只有当操作码是指令Store时，数据RAM的“写”（W）输入必须是1。 利用最少的附加硬件和一些新增的代码，可以让这个电路从累加器中减去一个数。第一步就是想操作码表增加一些代码。 操作码 代码 Load（加载） 10h Store （保存） 11h Add （加法） 20h Subtract （减法） 21h Halt （停止） FFh 对于Add和Subtract的代码，其区别就是最低有效位。如果操作码为21h，除了数据RAM阵列的数据传入加法器之前要取反，并且加法器进位输入置位1之外，电路所做的操作与执行Add指令所做的操作相同。 还有一个问题：加法器及连接到它的所有设备的宽度只有8位。以前提出过的一个解决办法是把两个8位加法器（其他的大部分设备也用两个）连在一起，构成一个16位的设备。 还有代价更小的解决方法，加入你想把两个16位的数相加，比如76ABh + 232Ch。这种16位的加法先单独处理最右边的字节，通常称为低字节，ABh+2Ch= D7h。然后再计算最左边的字节，即高字节的和：76h+23h=99h。得到相同的结果99D7h。 这里还有一个问题，就是低字节相加有时会产生一个进位，我们需要做的就是在第一步运算时保存低字节数运算的进位输出，并把它作为下一步高字节数运算的进位输入。如何保存1位呢？1位锁存器就是最好的选择了，该锁存器被称为进位锁存器。 为了使用进位锁存器，我们还需要另一个操作码，称之为“进位加法”。如果进行16位数的减法运算，则还需要一个新的指令，称为“借位减法”。 操作码 代码 Load（加载） 10h Store （保存） 11h Add （加法） 20h Subtract （减法） 21h Add With Carry （加法） 20h Subtract With Borrow（减法） 21h Halt （停止） FFh 增加了两个新的操作码之后，不再局限于8位数的加运算。通过执行进位加法操作，可以对16位数、24位数、32位数、40位数，甚至更多位数进行加法运算。假如要进行两个32位数加法运算，我们仅需要1条Add指令和3条Add with Carry指令。 当前的设计的自动加法器不允许在随后的计算中重复使用前面的计算结果。这个求和结果已经不能被访问了，每次我们使用它的时候都必须重新计算。 产生上述原因就在于我们构造的自动加法器具有如下的特性：它的代码存储器和数据存储器是同步的、顺序的，并且都从0000h开始寻址。代码存储器中的每一条指令对应数据存储器中相同地址的存储单元。一旦执行了一条store指令，相应的，就会有一个数被保存到数据存储器中，而这个数将不能重新加载到累加器中。 每个操作码在存储器中占1个字节。现在除了Halt操作外，每个指令在存储器中占据3个字节的空间，其中第一个字节为代码本身，另外两个字节用来存放1个16位存储器单元地址。对于Load指令，后两个字节保存的地址用来指明数据RAM阵列的一个存储单元，该单元存放的是需要被加载到累加器中的字节。 设计的关键是把代码RAM阵列的数据输出到3个8位锁存器中。每个锁存器保存改3字节指令的一个字节。第一个锁存器保存指令本身，第二个和第三个锁存器的输出构成了数据RAM阵列的16位地址。 每条指令的长度是3个字节。因此每次从存储器取回一个字节，所以取每条指令需要的时间为3个时钟周期，一个完整的指令周期需要4个时钟周期。而且，操作码和操作数可以存放在同一个RAM阵列。 通常，指令从0000h开始存放，这是因为计数器复位后从该位置访问RAM阵列。加入你计算了三个数的结果，你现在想利用这个结果，你可能需要把halt指令去掉，新增一个Load指令，然后再增加一条Add指令、Store指令和一条心的Halt指令。 也许你更想在其他的位置增加这些指令，而不是紧跟着这些指令来存放。可以用一条名为Jump（跳转）的新指令来替换Halt指令。 操作码 代码 Load（加载） 10h Store （保存） 11h Add （加法） 20h Subtract （减法） 21h Add With Carry （加法） 22h Subtract With Borrow（减法） 23h Jump（跳转 ） 30h Halt （停止） FFh 无论何时，只要自动加法器遇到Jump指令，计数器就会被强制输出改Jump指令后的16位地址。可以同过d型边沿触发器的预置和清零输入来实现。我们需要为16位计数器的每一位设置一个这样的触发器。一旦加载了某个特定的值，计数器就会从该值开始计数。 从RAM阵列锁存得到的16位地址既可以作为2-1选择器的输入，也可以作为16位计数器置位信号的输入。 毋庸置疑，Jump指令很有用。但与之相比，一个在我们想要的情况下跳转的指令更加有用，这种指令称作条件跳转。也许说明该命令重要性的最好方法是这样一个问题：怎样让自动加法器进行两个8位数的乘法运算？ 你可以先写6条指令，这6条指令是一次相乘后的结果，可以把这6条指令连续输入几次。也可以将复位键连续按几次得到最终结果。当然，这两种方法都不理想。 我们需要这样一种Jump指令，它只让过程重复执行所需要的次数，这种指令就是条件跳转指令。零锁存器存1一个数，称作零标志位。当加法器的输出全部为0时，零标志位等于1；当加法器的输出不全为0时，零标志位位0。 操作码 代码 Load（加载） 10h Store （保存） 11h Add （加法） 20h Subtract （减法） 21h Add With Carry （加法） 22h Subtract With Borrow（减法） 23h Jump（跳转 ） 30h Jump If Zero（零转移 ） 30h Jump If Carry（进位转移 ） 30h Jump If Not Zero（非零转移 ） 30h Jump If Not Carry（无进位转移） 30h Halt （停止） FFh Load指令的代码10h，称作机器码，或机器语言。 机器码都分配了对应的简短助记符，这些助记符都用大写字母来表示。 操作码 代码 助记符 Load（加载） 10h LOD Store （保存） 11h STO Add （加法） 20h ADD Subtract （减法） 21h SUB Add With Carry （加法） 22h ADC Subtract With Borrow（减法） 23h SBB Jump（跳转 ） 30h JMP Jump If Zero（零转移 ） 30h JZ Jump If Carry（进位转移 ） 30h JC Jump If Not Zero（非零转移 ） 30h JNZ Jump If Not Carry（无进位转移） 30h JNC Halt （停止） FFh 左边称为目标操作数，右边的操作数称为源操作数LOD A, [1003h] A代表累加器，把地址1003上的字节加载到累加器中ADD A, [001Eh] 把001Eh地址的字节加到累加器中STO [1003h], A 把累加器中的内容保存到1003h地址JNZ 0000h 如果零标志不是1则跳转到0000h地址处，这里没有用方括号，因为跳转指令要转移的地址是0000h，而不是保存于0000h的值，即0000h地址就是跳转指令的操作数 通过一个十六进制地址后面加一个冒号，可以表示某个指令保存在某个特定地址空间，例如：0000h: LOD A, [1003h] 下面的语句表示了数据在特定地址空间的存储情况。 1000h: 00h, A7h1002h: 00h, 1Ch1004h: 00h, 00h 上面的两个字节是用逗号分开的，它表示第一个字节保存在左侧的地址空间中，第二个字节保存在改地址后的下一个地址空间中。上面三条语句等价与这条语句： 1000h: 00h, A7h, 00h, 1Ch, 00h, 00h 这里给出的是一种汇编语言。它是全数字的机器语言和指令的文字描述的一种结合体。需要手工对其汇编，得出对应的机器语言，然后通过开关把这些机器码输入到RAM阵列中并运行该程序，","tags":[{"name":"编码(隐匿在计算机软硬件背后的语言)","slug":"编码-隐匿在计算机软硬件背后的语言","permalink":"http://yoursite.com/tags/编码-隐匿在计算机软硬件背后的语言/"},{"name":"汇编语言的由来","slug":"汇编语言的由来","permalink":"http://yoursite.com/tags/汇编语言的由来/"}]},{"title":"16 存储器组织","date":"2017-10-31T09:00:00.000Z","path":"2017/10/31/code_16/","text":"之所以被称为随机访问存储器，是因为读写操作很自由，我们只需要改变地址及相关的输入，就可以从8个锁存器中读出或写入需要的数据。相反，一些其他类型的存储器必须顺序读取，也就是说，读取地址101中存储的数据之前不得不线读取存储在地址100的数据。 8×1 RAM。阵列是以1比作为存储单位，共存储8个单位数据。所以这个RAM阵列中能存储的位数等于8于1的乘积 通过共享地址的方式可以把两个8×1的RAM阵列连接起来，就得到了8×2RAM。这个RAM阵列可存储的二进制数依然是8个，但每个数的位宽是2位。 还可以把两个8×1的RAM阵列看做是两个锁存器，使用一个2-1选择器和一个1-2译码器就可以把它们按照单个锁存器连接方式进行集成，本质上扮演了第4根地址线的角色。这种结构实质是一种16×1的RAM阵列。存储容量为16个单位，每个单位占1位。 RAM阵列的存储容量与其地址输入端的数量有直接的联系。在没有地址输入端的情况下，只能存储一个单位的数据；当存在1个地址输入端时，可以存储2个单位的数据；有两个地址输入端的时候，可以存储4个单位的数据；有3个地址输入端时，可以存储8个单位的数据；有4个地址输入端时，可以存储16个单位的数据。RAM阵列的存储容量 = 2 的 （地址输入端的个数）次方 1024×8 RAM可以存储 8192个比特信息，每8个比特位一组，共分为1024个组。 从专业的角度来讲，这个RAM阵列的存储容量为1024个字节。就好比一个邮局放置了1024个邮箱，而每个邮箱里面都可以存放1字节大小的邮件。 1024字节通常简称为1千字节，1千字节代表这1024个字节，并非1000个字节。 1KB = 1024 B = 2^10 B1MB = 1024 KB = 2^20 B1GB = 1024 MB = 2^30 B1TB = 1024 GB = 2^40 B1PB = 1024 TB = 2^50 B 64K×8 RAM 为65536个字节，需要配备16位的寻址端。 一个辛辛苦苦装满65536字节珍贵数据的64K×8 RAM阵列，如果断掉电源，会发生什么事情呢？首先所有的电磁铁都将因为没有电流而失去磁性，随着“梆”的一声，金属片讲弹回原位，所有继电器将还原到未触发状态。RAM中存储的数据呢？它们将如风中残烛般消失在黑暗中。 正因为如此，随机访问存储器也被称为易失性存储器。为了保证存储的数据不丢失，易失性存储器需要恒定的电流。","tags":[{"name":"编码(隐匿在计算机软硬件背后的语言)","slug":"编码-隐匿在计算机软硬件背后的语言","permalink":"http://yoursite.com/tags/编码-隐匿在计算机软硬件背后的语言/"},{"name":"RAM","slug":"RAM","permalink":"http://yoursite.com/tags/RAM/"}]},{"title":"15 字节与十六进制","date":"2017-10-31T04:00:00.000Z","path":"2017/10/31/code_15/","text":"一个字节有8位，取值范围是00000000~11111111 字节的一半，即4比特，我们称之为半字节。 一个8位二进制数表示10110110，这种表达方式自然又直观，但它还不够简洁。 我们完全可以采用十进制表示法来表示字节，但从二进制转换到十进制需要一些列计算，计算方法并不复杂，但是比较麻烦。 二进制 八进制 000 0 001 1 010 2 011 3 100 4 101 5 110 6 111 7 10 110 1110 = 2 6 6 10110110这个字节表示为八进制数266。这种方法简洁明了，但是还是有那么一点美中不足。 如果我们将16位二进制数直接表示为八进制会得到一下结果：1 011 001 111 000 101 = 1 3 1 7 0 5 如果我们把这个16位二进制数平分为两个字节并将其分别表示为八进制会得到如下所示的不同结果。10 110 0112 6 311 000 1013 0 5 为了使多字节值能和分开表示的单字节值取得一致，我们需要一种等分单个字节的系统，按照这种思想，我们可以把每个字节等分位4组，每组2比特（基于4的计数系统）；还可以等分为2组，每组4比特（基于16比特的计数系统）","tags":[{"name":"编码(隐匿在计算机软硬件背后的语言)","slug":"编码-隐匿在计算机软硬件背后的语言","permalink":"http://yoursite.com/tags/编码-隐匿在计算机软硬件背后的语言/"},{"name":"十六进制","slug":"十六进制","permalink":"http://yoursite.com/tags/十六进制/"}]},{"title":"14 反馈与触发器","date":"2017-10-30T09:00:00.000Z","path":"2017/10/30/code_14/","text":"振荡器，也被称为时钟。 R-S 触发器 输入 输出 S \\ R Q \\ Q非 1 \\ 0 1 \\ 0 0 \\ 1 0 \\ 1 0 \\ 0 Q \\ Q非 1 \\ 1 0 \\ 0 (不符合要求) 改进后： 输入 输出 数据 \\ 保持位 Q 0 \\ 1 0 1 \\ 1 1 0 \\ 0 Q 1 \\ 0 Q 输入 输出 数据 \\ 保持位 Q 0 \\ 1 0 1 \\ 1 1 X \\ 0 Q 电平触发的D型锁存器 输入 输出 D \\ Clk Q \\ Q非 0 \\ 1 0 \\ 1 1 \\ 1 1 \\ 0 X \\ 0 Q \\ Q非 2-1选择器 选择端 A B Q 0 0 X 0 0 1 X 1 1 X 0 0 1 X 1 1 边沿触发的D型触发器D | Ckl | Q | Q非 |:-:| :-: | :-:| :-: |0 | ↑ | 0 | 1 |1 | ↑ | 1 | 0 |X | 0 | Q | Q非 | 分频器：如果这个振荡器的频率是20Hz，那么Q的输出频率是它的一半，即10Hz，由于这个原因，这种电路称为分频器。 带预置和清零功能的边沿触发的D型触发器 Pre Clr D Ckl Q Q非 1 0 X X 1 0 0 1 X X 0 1 0 0 0 ↑ 0 1 0 0 1 ↑ 1 0 0 0 X 0 Q Q非","tags":[{"name":"编码(隐匿在计算机软硬件背后的语言)","slug":"编码-隐匿在计算机软硬件背后的语言","permalink":"http://yoursite.com/tags/编码-隐匿在计算机软硬件背后的语言/"},{"name":"减法的实现","slug":"减法的实现","permalink":"http://yoursite.com/tags/减法的实现/"},{"name":"触发器","slug":"触发器","permalink":"http://yoursite.com/tags/触发器/"}]},{"title":"13 如何实现减法","date":"2017-10-30T04:00:00.000Z","path":"2017/10/30/code_13/","text":"前言这一章让我明白了很久以前的一个困惑，那就是如何把减法转化成加法的，而且为什么用取反加一来表负数。 过程253 - 176 = 77 需要借位 怎样才能不需要借位呢？999 - 176 = 823823 + 253 = 1076现在应该减去999，但是为了避免借位，应该加上1减去10001076 + 1 - 1000 = 77 将十进制转化为二进制：11111101 - 10110000 = 01001101 11111111 - 10110000 = 01001111取反的实质是求1的补码01001111 + 11111101 = 101001100101001100 + 1 - 100000000 = 01001100 加入-500~499之间，总共1000个数，这个约束说明只能用三位十进制数，且不用负号就可以表示所有需要的数字。我们并不需要用到从500到999之间的正数，因为我们所需要的数的最大值是499。因此从500到599的三位数可以用来表示负数。具体情况如下： 用500表示-500用501表示-499用502表示-498……用998表示-2用999表示-1用000表示0用001表示1用002表示2……用497表示497用498表示498用499表示499 如果999加上1就是1000。由于我们处理的是三位数，这个结果实际上是000。 这种标记称为10的补数。为了将三位负数转化为10的补数，我们用999减去它再加上1。 减一个数等于加上一个负数。利用10的补数，我们将不会再用到减法。所有的步骤都用加法来进行。 这样的机制在二进制中被称为2的补数。以8位二进制为例。范围为00000000~11111111，对应0~255。但是如果你还想表示负数的话，则以1开头的每个八位表示一个负数，如下表所示 二进制数 十进制数 10000000 -128 10000001 -127 10000010 -126 …… …… 11111101 -3 11111110 -2 11111111 -1 00000000 0 00000001 1 00000010 2 …… …… 01111101 125 01111110 126 01111111 127 计算2的补码，首先计算1的补数，然后再加1.这等价于将每位取反再加1。用同样的步骤，每位取反再加1，可以将数值还原。 一般来说，对于涉及正数和负数的加法，如果两个操作数的符号位相同，但结果的符号位不同，则结果是无效的。 总结无符号的8位二进制数所表示的范围是0~255。有符号的8位二进制表示的范围是-128~127。无论有符号还是无符号的，数字本身是无法显示的。 二进制数的麻烦之处就是他们只是一些0和1，本身并没有任何含义。","tags":[{"name":"编码(隐匿在计算机软硬件背后的语言)","slug":"编码-隐匿在计算机软硬件背后的语言","permalink":"http://yoursite.com/tags/编码-隐匿在计算机软硬件背后的语言/"},{"name":"减法的实现","slug":"减法的实现","permalink":"http://yoursite.com/tags/减法的实现/"},{"name":"补码","slug":"补码","permalink":"http://yoursite.com/tags/补码/"}]},{"title":"12 二进制加法器","date":"2017-10-29T13:00:00.000Z","path":"2017/10/29/code_12/","text":"前言如果我们可以造出加法器，同样地，就可以利用假发来实现减法、乘法和除法，计算按揭付款，引导火箭飞到火星、下棋，以及填写我们的话费账单。 过程 + 加法 0 1 0 0 1 1 1 0 + 进位 0 1 0 0 0 1 0 1 AND 0 1 0 0 0 1 0 1 利用与门可以计算两个二进制数加法的进位。 OR 0 1 0 0 1 1 1 1 NAND 0 1 0 1 1 1 1 0 或门和加法的结果很相似，除了右下角的结果。与非门和加法的结果也很相似，除了左上角的结果。 如果把 OR的结果和NAND的结果相于，那么结果就和加法的结果是一样的。实际上电路中有一个专门的名称，叫做异或门。 XOR 0 1 0 0 1 1 1 0 异或门，不同则为1，相同则为0。 两个二进制数相加的结果是由异或门的输出给出的，而进位位是由与门的输出给出的。这样就构成了一个半加器。半加器的原因是，它将两个二进制数相加，得出了一个加法位和一个进位位。但是绝大多数是多于一位的。半加器没有做到的是将之前一次的加法可能产生的进位位纳入下一次运算。 三个十进制是这样计算的，8+6+7=21，首先8+6的加法位是4，进位位是1，加法位4和7相加得出加法位是1，进位位是1，然后进位位继续相加得出2，所以最终结果是，进位位是2，加法位是1。 二进制也是一样的。第一个半加器的输入A和输入B的输出结果是一个加和及相应的进位。这个和必须和前一列的进位输入相加，然后在把它们输入到第二个加法器中。第二个半加器的输出和是最后的结果。两个半加器的进位输出又被输入一个或门中。你可能会觉得，两个进位应该用异或门来相加得出和，但是你会发现两个半加器的进位输出是不会同时为1的。或门在这里已经足够，因为或门除了在输入都为1的时候以外，其他情况下结果和异或门结果相同。 两个半加器和一个或门构成一个全加器。 全加器的所有情况如下表 输入A 输入B 进位位M(A+B) 加法位N(A+B) 进位输入X 最终加法位(N+X) 进位位Z(N+X) 最终进位位(M+Z) 0 0 0 0 0 0 0 0 0 1 0 1 0 1 0 0 1 0 0 1 0 1 0 0 1 1 1 0 0 0 0 1 0 0 0 0 1 1 0 0 0 1 0 1 1 0 1 1 1 0 0 1 1 0 1 1 1 1 1 0 1 1 0 1 过程更为了然，输入A和B得出进位位M和加法位N，加法位N和前一列的结果的进位X得出最终加法位和进位位Z，然后加法Z和之前的进位位M相加得出最终进位，由于进位Z和进位M不可能同时为1，因为或门和异或门只有1，1这种情况不同，其他情况都相同，所以使用或门代替异或门。 扩展 一旦你搭建起了8位二进制加法器，你就可以再搭建另外一个加法器。把它们级联起来就可以很容易地扩展出一个16位加法器，只要把第一个8位二进制加法器的进位输出到第二个8位二进制加法器的进位输入即可。 真相计算机已经不再使用继电器了！第一台数字计算机在20世纪30年代被建造完成，但是所使用的就是继电器，后来也是用过真空管。今天的计算机使用的是晶体管。 晶体管的工作方式与继电器基本形同，晶体管要比继电器计算速度更快、体积更小，而且噪声更弱、耗能也更低，而且更便宜。","tags":[{"name":"编码(隐匿在计算机软硬件背后的语言)","slug":"编码-隐匿在计算机软硬件背后的语言","permalink":"http://yoursite.com/tags/编码-隐匿在计算机软硬件背后的语言/"},{"name":"二进制加法器","slug":"二进制加法器","permalink":"http://yoursite.com/tags/二进制加法器/"}]},{"title":"11 门","date":"2017-10-29T09:00:00.000Z","path":"2017/10/29/code_11/","text":"与门 AND 0 1 0 0 0 1 0 1 与门的符号不仅仅代表了两个串联的继电器。与门的输入未必一定要和开关相连，而且输出也不一定只能和灯泡相连。我们真正处理的是输入端的电压和输出端的电压。 OR 0 1 0 0 1 1 1 1 反相器 它能将低电平转换为高电平，将高电平转化为低电平 2-4译码器 4个与门和两个反相器连接成的电路叫做2-4译码器。输入为2个二进制位，各种组合共表示4个不同的值。输出是4个信号，任何时刻只能有一个是1，至于哪一个是1取决于两个输入。利用同样的道理，我们可以构造出3-8译码器或者4-16译码器。 或非门 NOR 0 1 0 1 0 1 0 0 与非门 NAND 0 1 0 1 1 1 1 0 带有两个反向输入的与门和或非门是相等的 带有两个反向输入的或门和与非门是相等的 这两组等价关系就是摩根定律在电路中的实现。 摩根定律可以简单地表示如下形式： 摩尔定律是简化布尔表达式的一种重要手段，因此也可以简化电路。","tags":[{"name":"编码(隐匿在计算机软硬件背后的语言)","slug":"编码-隐匿在计算机软硬件背后的语言","permalink":"http://yoursite.com/tags/编码-隐匿在计算机软硬件背后的语言/"},{"name":"门","slug":"门","permalink":"http://yoursite.com/tags/门/"}]},{"title":"10 逻辑与开关","date":"2017-10-29T04:00:00.000Z","path":"2017/10/29/code_10/","text":"代数安雅有3磅豆腐。贝蒂的豆腐是安雅的2倍。卡门的豆腐比贝蒂多5磅。迪尔德丽的豆腐是卡门的3倍。试问迪尔德丽有多少豆腐？ 首先将文字叙述转化为数学语言，下面用四个字母分别表示每个人所拥有的豆腐有多少磅：A = 3B = 2 AC = B + 5D = 3 C将四个表达式带入同一个式子进行合并：D = 3 CD = 3 (B + 5)D = 3 ((2 A) + 5)D = 3 ((2 3) + 5)D = 3 * 33 布尔的天才之处就是把代数从数的概念中抽离出来而使其更加抽象。操作数不是数字而是类，一个类就是一个事物的集合，它后来被称为集合。 集合中的并与交和电路中的并联与串联集合中的交集和并集： AND 0 1 0 0 0 1 0 1 这个运算与常规的乘法的结果是完全相同的。 OR 0 1 0 0 1 1 1 1 这个运算与常规的加法的结果是完全相同的。 电路中，开关闭合代表1，开关断开代表0。 串联 0 1 0 0 0 1 0 1 这与AND表示一模一样的 并联 0 1 0 0 1 1 1 1 这与OR表示一模一样的","tags":[{"name":"编码(隐匿在计算机软硬件背后的语言)","slug":"编码-隐匿在计算机软硬件背后的语言","permalink":"http://yoursite.com/tags/编码-隐匿在计算机软硬件背后的语言/"},{"name":"逻辑与开关","slug":"逻辑与开关","permalink":"http://yoursite.com/tags/逻辑与开关/"}]},{"title":"9 二进制数","date":"2017-10-27T16:00:00.000Z","path":"2017/10/28/code_9/","text":"bit（比特）代表一个二进制位。 在计算机时代，比特被看做是组成信息块的基本单位。 一个耐人寻味的利用二进制传递重要信息的例子：他对他的朋友说：“今晚如果从镇里来的英国军队通过海路或陆路入侵，你就在北教堂钟楼的拱门处高高挂起提灯作为特殊信号——一盏提灯表示英军从陆路进军，两盏则表示英军从海路入侵……” 假设两盏提灯是永久固定在教堂钟楼里上的。通常他们不会被点亮。这代表英军还没有入侵。如果一盏提灯亮起：表示英军从陆路入侵。如果两盏灯都亮：表示英军从海路入侵。 每一盏灯都代表一个比特。点亮的提灯表示比特值1；未点亮的提灯表示0。 四种信息的可能：00 = 英军不会入侵01 = 英军从陆路入侵10 = 英军从陆路入侵11 = 英军从海路入侵 UPC（Universal Product Code）是由30条不同宽度的垂直黑色条纹组成的，他们的间隙宽度也不同，条纹下面标有数字。 可以把这些条纹看成是细条和黑条、窄间隙和款间隙的排列。在UPC中，黑色条纹有四中不同的宽度，宽条纹的宽度分别是最细条纹宽度的两倍、三倍或四倍。同样，款间隙的宽度分别是最窄间隙宽度的两倍、三倍或四倍。 扫描仪只识别整个条形码的一条窄带，条形码做得很大为了便于操作人员用扫描仪对准。看起来像莫尔斯码。 当计算机从左向右扫描这个信息时，它会首先给遇到的第一个黑条分配一个值为1的比特，给与这个黑条相邻的白色间隙分配一个值为0的比特。随后的条纹好间隙被读作一行中的一系列比特，每个系列的比特可以是1位、2位、3位或4位，而这个位数取决于条纹和间隙的宽度。整个upc只不过是95位二进制数。 前三位通常都是101，这就是最左边的护线，它帮助计算机扫描仪定位。从护线中，扫描仪可以确定代表danger别特的条和间隙的宽度是多少。 最左边的护线之后是6组比特串，每串含有7个比特位。其中每一组可以是数字0~9的编码。接下来是一个5比特位的中间护线，这是一个固定的模式（始终是01010），它是一个内置式的检错码。如果计算机扫描仪没有在应有的位置找到中间护线，他就无法破解UPC码。这条中间护线是用来预防条形码被篡改或被印错的一种方法。 中间护线后面仍然是6组比特串，每组中含有7个比特位。之后最右边的护线，最后边的护线通常为101.最右边的护线可以实现UPC的反向扫描。 左边的编码：0001101 = 00011001 = 10010011 = 20111101 = 30100011 = 40110001 = 50101111 = 60111011 = 70110111 = 80001011 = 9 每个7位编码都是以0开头的，以1结尾的。另外每组编码仅有两组连续为1的比特位。每组编码含有奇数个1。这是预防条形码被篡改的一种方法。 如果每组比特位中含有偶数个1，它就称为偶校验；如果含有奇数个1，那么它称为奇校验。 右边的编码：1110010 = 01100110 = 11101100 = 21000010 = 31011100 = 41001110 = 51010000 = 61000100 = 71001000 = 81110100 = 9 这些编码都是之前编码的补码：之前出现0的点，现在都换成了1，反之亦然。这些编码都是以1开头，以0结尾的。除此之外，每组编码都含有偶数个1，属于偶校验。 一共十二个数字，编码解除的数字与UPC下面印刷的数字完全形同，当扫描仪由于某种原因无法解读条形码时，收银员可以手动输入这些数字，毫无疑问你也看到过这一幕。 第一个数字被称为数字系统符。0意味着这是一个常规的UPC。称重的商品，例如肉、农场品，这个编码就会是2。票券的upc的第一个数字通常为5。 接下来的5个数字表示是制造商编码。51000就是campbell公司的编码。所有campbell公司的产品都是这个编码。后面的五位代码是这个公司的某种商品的编码。只有和制造商编码同时出现的时候这个编码才有意义。不同的公司相同的商品的编码可能是不一样的。 UPC不包含物品的价格信息。价格信息可以从商店使用与该扫描仪相连的计算机中检索到。 最后一个字符称为模校验位。这个字符用来进行另外一种错误校验。将前11个数字用字母代替：A BCDEF GHIJK然后计算下式的值：3 （A+C+E+G+I+K） + （B+D+F+H+J）从这个值最近并且大于或等于它的一个10的整倍数中减去它，其结果称为模校验字符。3 （0+1+0+0+2+1） + （5+0+0+1+5） = 23紧挨23并且大于或等于23的10的整倍数是30，因此：30-23=7 通常情况下，要表示0~9的十进制数字只需要4个比特位就足够了。upc中每个数字用了7个比特位。这样，upc总共用了95个比特位来表示11个足够有效的十进制数。实际上，upc中还有空白位置（相当于9个0比特），它们位于左、右护线的两侧。这就意味着整个upc需要113个比特位来编码11个十进制数，平均每个十进制数所用的比特位超过了10个！ 如我们所看到的，有部分冗余对于检错来讲是非常重要的。这种商品编码如果能够被顾客用笔轻易地改动，那么这种产品编码措施也就没有任何意义了。 upc可以从两个方向度，这一点是非常方便的。如果扫码装置解码的第一个数是符合偶校验的，扫码仪机会知道，他正从右边向左边扫描upc码。 逆向扫描时右边数字的编码0100111 = 00110011 = 10011011 = 20100001 = 30011101 = 40111001 = 50000101 = 60010001 = 70001001 = 80010111 = 9 逆向扫描时左边数字的编码 1011000 = 01001100 = 11100100 = 21011110 = 31100010 = 41000110 = 51111010 = 61101110 = 71110110 = 81101000 = 9 所有这些7位编码都与由左向右扫描时得到的upc完全不同。这里不会有模棱两可的现象存在。","tags":[{"name":"编码(隐匿在计算机软硬件背后的语言)","slug":"编码-隐匿在计算机软硬件背后的语言","permalink":"http://yoursite.com/tags/编码-隐匿在计算机软硬件背后的语言/"},{"name":"二进制","slug":"二进制","permalink":"http://yoursite.com/tags/二进制/"}]},{"title":"8 十的替代品","date":"2017-10-27T09:00:00.000Z","path":"2017/10/27/code_8/","text":"10之所以指十只鸭子，唯一理由就是我们的手指有十只，如果我们有八只，那么10就会代表八，如果我们只有四只手指，那么10就会代表四，如果我们只有两只手指，那么10就会代表二。 如果我们采用八进制数字系统，那么我们不用符号9和8。因在十进制中，10没有特定的符号，因此在8进制中，同样没有表示8的特定符号。 十进制中，我们的计数方式是：0、1、2、3、4、5、、6、7、8、9，然后是10。在八进制计数数字系统中计数方式是：0、1、2、3、、4、5、6、7，然后是10。 使用非十进制的数字系统中，你可以将“10”读作“一零”，这样可以避免混淆。类似地，“13”读作一三，“20”读作“二零”。要想真正避免混淆，可以将“20”读作“基于8进制的数二零”或“八进制二零”。 8进制的数字： 0，1，2，3，4，5，6，7，10，11，12，13，14，15，16，17，20，21，22，23，24，25，26，27，30，31，32，33，34，35，36，37，40，41，42，43，44，45，46，47，50，51，52，53，54，55，56，57，60，61，62，63，64，65，66，67，70，71，72，73，74，75，76，77，100，……最后一个数字，我们读作“一零零”。这是卡通人物手指的数量自身想乘所得的结果。 八进制中：3725 = 3000(Eight) + 700(Eight) + 20(Eight) + 5(Eight)3725 = 3 512(Ten) + 7 64(Ten) + 2 8(Ten) + 5 1(Ten)3725 = 3 1000(Eight) + 7 100(Eight) + 2 10(Eight) + 5 1(Eight)3725 = 3 8^3(Ten) + 7 8^2(Ten) + 2 8^1(Ten) + 5 8^0(Ten) 八进制中： + 0 1 2 3 4 5 6 7 0 0 1 2 3 4 5 6 7 1 1 2 3 4 5 6 7 10 2 2 3 4 5 6 7 10 11 3 3 4 5 6 7 10 11 12 4 4 5 6 7 10 11 12 13 5 5 6 7 10 11 12 13 14 6 6 7 10 11 12 13 14 15 7 7 10 11 12 13 14 15 16 乘法表如下： * 0 1 2 3 4 5 6 7 0 0 0 0 0 0 0 0 0 1 0 1 2 3 4 5 6 7 2 0 2 4 6 10 12 14 16 3 0 3 6 11 14 17 22 25 4 0 4 10 14 20 24 30 34 5 0 5 12 17 24 31 36 43 6 0 6 14 22 30 36 44 52 7 0 7 16 25 34 43 52 61 既然已经为卡通人物开发了一套数字系统，就让我们在制定一套适合龙虾的吧。适于龙虾的数字系统是4为基数的四进制数字系统。 四进制的数字系统是这样的：0，1，2，3，10，11，12，13，20，21，22，23，30，31，32，33，100，101，102，103，110，等等。 在四进制系统中： 31232 = 3 256(Ten) + 1 64(Ten) + 2 16(Ten) + 3 4(Ten) + 2 1(Ten)31232 = 3 10000(Four) + 1 1000(Four) + 2 100(Four) + 3 10(Four) + 2 131232 = 3 4^4 + 1 4^3 + 2 4^2 + 3 4^1 + 2 * 4^0 如果我们是海豚，这个数字系统成为以2为基数的数字系统，或二进制。 二进制中，1的下一位就是10。这让人惊讶，但也并不是什么意外。无论使用哪种基数系统，当单个的数字用完时，第一个两位数就是10。二进制系统是这样计数的：0，1，10，11，100，101，110，111，1000，1001，1010，1011，1100，1101，1110，1111，等等 2的整数次幂 十进制数 八进制数 四进制数 二进制数 2^0 1 1 1 1 2^1 2 2 2 10 2^2 4 4 10 100 2^3 8 10 20 1000 2^4 16 20 100 10000 2^5 32 40 200 100000 2^6 64 100 1000 1000000 2^7 128 200 2000 10000000 2^8 256 400 10000 100000000 2^9 512 1000 20000 1000000000 2^10 1024 2000 100000 10000000000 2^11 2048 4000 200000 100000000000 2^12 4096 10000 1000000 1000000000000 101101011010(Two) = 1 2048(Ten) + 0 1024(Ten) + 1 512(Ten) + 1 256(Ten) + 0 128(Ten) + 1 64(Ten) + 0 32(Ten) + 1 16(Ten) + 1 8(Ten) + 0 4(Ten) + 1 2(Ten) + 0 1(Ten) 101101011010(Two) = 1 2^11 + 0 2^10 + 1 2^9 + 1 2^8 + 0 2^7 + 1 2^6 + 0 2^5 + 1 2^4 + 1 2^3 + 0 2^2 + 1 2^1 + 0 2^0 + 0 1 0 0 1 1 1 10 * 0 1 0 0 0 1 0 1 电线可以表示二进制数字。如果有电流流过这根电线就代表二进制数字1，如果没有，则代表二进制数字0。 开关可以表示二进制数字。如果开关闭合就代表二进制数字1，如果开关断开，则代表二进制数字0。 灯泡可以表示二进制数字。如果灯泡点亮，就代表二进制数字1，如果没点亮，则代表二进制数字0。 电报继电器可以表示二进制数字。如果继电器闭合，就代表二进制数字1，如果断开，则代表二进制数字0。 二进制数与计算机之间有着紧密的联系。","tags":[{"name":"编码(隐匿在计算机软硬件背后的语言)","slug":"编码-隐匿在计算机软硬件背后的语言","permalink":"http://yoursite.com/tags/编码-隐匿在计算机软硬件背后的语言/"},{"name":"十进制的延伸","slug":"十进制的延伸","permalink":"http://yoursite.com/tags/十进制的延伸/"}]},{"title":"7 我们的十个数字","date":"2017-10-27T04:00:00.000Z","path":"2017/10/27/code_7/","text":"这个星球上几乎所有人都用以下方式来书写数字：1 2 3 4 5 6 7 8 9 10 大多数文明都是机那里在以10为基数的数字系统上的，因为我们的手指是10个。 早期的数字系统中，只有罗马数字沿用到了今天。I表示1，V表示5，X表示10，L是50，C是100，D是500，M表示1000。 阿拉伯数字起源于印度，被阿拉伯人导入欧洲。 阿拉伯数字系统时和位置有关的。100和1,000,000这两个数中都只有一个1，而我们知道1,000,000比100大得多。实际上，早前的阿拉伯系统的10是用专门的符号来表示的。小小的零是数字和数学史上最重要的发明之一。它支持位置计数法，因此可以将25、205和250区分开来。 4825 = 4000 + 800 + 20 + 54825 = 4 1000 + 8 100 + 2 10 + 5 14825 = 4 10^3 + 8 10^2 + 2 10^1 + 5 10^0 每一个位置代表10的幂次方。我们不需要一个专门的符号来表示数字“10”，因为我们可以将1放在不同的位置，并用0作为占位符。 另外一个好处是，以同样的方式将数字置于小数点右边可以表示分数。数字4825.684就是： 4 1000 +8 100 +2 10 +5 1 +6 ÷ 10 +8 ÷ 100 +4 ÷ 1000 也就是： 4 1000 +8 100 +2 10 +5 1 +6 0.1 +8 0.01 +4 * 0.001 也就是： 4 10^3 +8 10^2 +2 10^1 +5 10^0 +6 ÷ 10^(-1) +8 ÷ 10^(-2) +4 ÷ 10^(-3) 加法表如下： + 0 1 2 3 4 5 6 7 8 9 0 0 1 2 3 4 5 6 7 8 9 1 1 2 3 4 5 6 7 8 9 10 2 2 3 4 5 6 7 8 9 10 11 3 3 4 5 6 7 8 9 10 11 12 4 4 5 6 7 8 9 10 11 12 13 5 5 6 7 8 9 10 11 12 13 14 6 6 7 8 9 10 11 12 13 14 15 7 7 8 9 10 11 12 13 14 15 16 8 8 9 10 11 12 13 14 15 16 17 9 9 10 11 12 13 14 15 16 17 18 乘法表如下： * 0 1 2 3 4 5 6 7 8 9 0 0 0 0 0 0 0 0 0 0 0 1 0 1 2 3 4 5 6 7 8 9 2 0 2 4 6 8 10 12 14 16 18 3 0 3 6 9 12 10 18 21 24 27 4 0 4 8 12 16 20 24 28 32 36 5 0 5 10 15 20 25 30 35 40 45 6 0 6 12 18 24 30 36 42 48 54 7 0 7 14 21 28 35 42 49 56 63 8 0 8 16 24 32 40 48 56 64 72 9 0 9 18 27 36 45 54 63 72 81 位置计数系统的好处并不在于它有多么好用，而在于对非十进制的系统而言，它仍然易于实现计数的。以10位基数的数字系统最大的问题就是它对于卡通人物没有任何意义。大多数卡通人物每只手只有4根手指，因此他们需要一个以8为基数的计数系统。而有意思的是，许多我们在十进制数中所了解到的知识同样适合卡通朋友们所钟爱的八进制计数系统。","tags":[{"name":"编码(隐匿在计算机软硬件背后的语言)","slug":"编码-隐匿在计算机软硬件背后的语言","permalink":"http://yoursite.com/tags/编码-隐匿在计算机软硬件背后的语言/"},{"name":"十进制数","slug":"十进制数","permalink":"http://yoursite.com/tags/十进制数/"}]},{"title":"6 电报机和继电站","date":"2017-10-25T16:00:00.000Z","path":"2017/10/26/code_6/","text":"摩尔斯的发明问世前的几十年里，人们为了提高远距离通信的速度，做过很多尝试。技术上比较简单的方法是，雇用一些人站在山上，作为中继系统，挥旗发出旗语。而在技术上稍复杂的解决方案是，使用带有机械的大型装置，代替人做挥旗的工作。 电报机的原理：在线路的这一段采取一些措施，使线路的另一端发生某种变化。 电磁现象：如果你有一根铁棒，那么在上面用细导线绕上几百圈，然后在导线上接通电流，铁棒就变成了一块磁铁。现在它可以吸引其他的铁块和钢块，电磁铁上缠绕足够多的细导线，会产生足够强的电阻，能防止电磁铁产生短路现象。断开电流，铁棒将会丧失磁性。 电磁铁是电报机的基础。在线路的一端闭合或断开开关，可以使线路另一端的电磁铁有所动作。 早期时，莫尔斯认为应该在纸张上写出什么东西。当然，电报机输出的不一定非得是单词，因为那样做太复杂了。 保持电键的按下状态一小段时间，就会产生一个“点”的莫尔斯码。按下状态保持的时间更长一些就会产生一个“划”的莫尔斯码。 线路的另一端是一个接收器，它主要是由一块电磁铁拉动一根金属杆构成的。最初，电磁铁控制的是一只钢笔。有一个装置通过使用一个压紧的弹簧来拉动一卷纸经过设备，与电磁铁连接着的钢笔就会弹起或者落下，在纸上画出点或划。能读懂莫尔斯码的人员可以把这些“点”或“划”译成字母和单词了。 当然，电报操作人员很快发现，他们很容易地通过听钢笔弹起和落下的声音来翻译成电码。然后，钢笔最终被废弃。 电报机的电键被按下时，发生器中的电磁铁拉动上面的活动横杠下降，它会发出“滴”的声音。当松开电键的时候，横杠弹回到原来的位置，发出“嗒”的声音。一次快速的“嘀-嗒”声代表点；一次慢速的“嘀-嗒”声则代表划。 设置中继系统时解决问题的一个方案。每隔200英里左右，为一个工作人员装配好发生器和电键，他就可以接收信息，然后再把它转发出去。 现在，想象你已经被一个电报公司聘用，把你仍在纽约和加利福尼亚之间的一个无名之地，让你在一个只有一桌一椅的小屋里工作。一条导线从东面的窗户伸进来，连接到发生器上。而你的电报机电键连到电池上，最后线路从西窗伸出去，你的职责就是接收从纽约发来的信息，然后转发它们，最终使它们到达加利福尼亚。 开始时，你喜欢接收完一条完整的信息后再把它转发。最后，你掌握了诀窍，在听到滴答声的同时就可以发送信息。 有一天，你瞄了瞄发生器那根上蹿下跳的横杆，又看了看在电键上上下翻飞的手指。恍然发现发生器上上下跳跃的节奏与电键是一致的。因此你就去外面找了根小木棍，然后用木棍和一些细绳把发生器和电键连接到了一起。现在设备可以自己工作了，而下午的时间，你可以去休个假，钓个鱼。 这是个有趣的想法，但是事实上，莫尔斯在早些时候就已经领会了这个设备的概念。这个称作“继电器”。传进来的电流驱动电磁铁拉动金属杆，金属杆同时又作为一个开关的组成部分，而这个开关连接着电池和输出线路。 继电器是一个意义非凡设备。当然，它是一个开关，但是这个开关的闭合和断开不是由人来操纵的，而是由电流控制的。","tags":[{"name":"编码(隐匿在计算机软硬件背后的语言)","slug":"编码-隐匿在计算机软硬件背后的语言","permalink":"http://yoursite.com/tags/编码-隐匿在计算机软硬件背后的语言/"},{"name":"电报机","slug":"电报机","permalink":"http://yoursite.com/tags/电报机/"},{"name":"继电站","slug":"继电站","permalink":"http://yoursite.com/tags/继电站/"}]},{"title":"5 绕过拐角的通信","date":"2017-10-24T16:00:00.000Z","path":"2017/10/25/code_5/","text":"你12岁了。你最好的朋友跟随家人搬到别的镇子。你另外的一个好朋友，也就是你的邻居，现在成了你的新的密友。问题是，这位新朋友的卧室窗户和你卧室的窗户不是对着的。尽管两栋房子挨着，但是卧室窗户是朝向同一个方向的。除非你能想个办法，在室外摆上一面镜子，不然手电筒就不能用来夜谈了。 怎么办？ 也许现在你已经懂得一些关于电学的只是，所以你打算用电池、灯泡、开关和导线自制一个“手电筒”。在第一次尝试中，你把电池还有开关放在卧室中接好，然后从窗户引出两根导线，绕过围墙，街道你朋友的卧室里，在那里把它们街道一个灯泡上。 既然你已经成功地安装了这个“手电筒”，你就可以照样再安装另一套这样的“远距离”设备，好让你的朋友也能够给你发信息。 恭喜你！你已经架好了一套双向电报系 聪敏的你可以采用如下方式对这套系统加以改进，这样可以节省25%的导线。 地球充当导体，这个大球直径7900英尺，由金属、岩石、水，以及有机质（其中大部分是没有生命的）组成。 想要用地球充当导体，可不是随便在西红柿地里插根线那么简单。你必须使用跟地球有充分接触的物体，也就是有很大表面积的导体。捏可以使用一个至少8英尺长、1/2英寸粗的铜柱电极砸进地里，然后在上面接上一根导线。或者，如果你家中的水管是用铜做的，并且是从屋外的地下接下来的，那么你可以在管上接上导线。 1英尺(ft)=0.3048米(m)8英尺(ft)=2.4384米(m)1英寸(in)=0.0254米(m)0.5英寸(in)=0.0127米(m)=1.27厘米(cm) 关于电流的接地，英国人们称其为“earth”，在美国叫“ground”。 电子从你朋友的房子地下出发，经过灯泡、导线和你房间的开关，最后回到电池的正极。而电子最初是从电池的负极传入地下的。 每时每刻地球都在充当着全世界成千上万条电路的导线，想到这些，你可能感到迷茫：电子怎么知道它要去什么地方？其实它们不知道。 地球是一个巨大的导体。地球是一个近乎无尽的电子之源，同是也是一个无比庞大的电子池。不过地球还是有一定电阻的。所以当我们使用1.5伏干电池和灯泡时，不同通过接地来节约我们所需的线路开支。 如果你使用的是高电压电池和大灯泡，你只需要在你和你朋友的房子之间接一根导线，因为可以把地球当成一条导线。 把电池和接地用V来代替它，想象成一个电子吸尘器，然后把地面想象成电子的海洋。电子吸尘器通过电路把电子从地下拉起来，让它们沿设计好的线路开始工作。 本章中，我们已在通信的演变中迈出了重要的一步。之前我们使用莫尔斯码交流时，必须要在视线直视的范围里，并且要保证在手电筒管线可以传播的距离之内。 如果跨越成百上千英里来进行通信，只需铺设足够长的线路即可。不过有个问题，线路越长它们的电阻就越大。电阻越大，线路的电流就越少。电流越少，灯泡就越暗。 假如现在使用的是原来的4条导线的双向电路，并且还用手电筒和小灯泡。买20号规格的电话线，花费为没100英尺9.99美元。如果你和你朋友的卧室之间的距离小于50英尺，这卷电话线就足够了。20号规格的电话线，直径大约是0.032英寸，大约每1000英尺只有10欧的电阻，也就是你们卧室间的往返距离——100英尺，大约有1欧的电阻。 1英里(mi)=1.609344千米(km)1英里(mi)=5280英尺(ft) 情况其实还不错，如果我们需要铺设一英里的线路呢？导线的电阻将大于100欧。小灯泡是4欧，电流是3/4=0.75安，现在电阻变成50欧，电流变成3/50=0.06安，几乎可以肯定，这点电流不足以点亮灯泡。 使用粗一点的导线是不错的解决方案，但是那会比较昂贵。10号规格线，没35英尺11.99美元，这种线只有一个接口，大约有0.1英寸粗，所以你需要两倍长度，没1000英尺只有1欧的阻抗，也就是每英里5欧。 另一种方法就是增加电压，使用更大电阻的灯泡。导线的电阻对这个电路的影响将变得小许多。 150年期，人们铺设第一个跨越美洲和欧洲的电报系统时，这些都是面临的问题。系统的极限是200英里。这个长度与纽约和加利福尼亚数千英里的距离相比，还是有很大差距的。 这个难题的解决方案不是给手电筒的，而是给“滴答滴答”的近代电报系统的，尽管它只不过是一个很简陋的装置，但是正是基于和这个装置，整个计算机系统才被构建起来。","tags":[{"name":"编码(隐匿在计算机软硬件背后的语言)","slug":"编码-隐匿在计算机软硬件背后的语言","permalink":"http://yoursite.com/tags/编码-隐匿在计算机软硬件背后的语言/"},{"name":"电路分析","slug":"电路分析","permalink":"http://yoursite.com/tags/电路分析/"}]},{"title":"4 手电筒的剖析","date":"2017-10-23T16:00:00.000Z","path":"2017/10/24/code_4/","text":"手电筒的构造：一对电池、一个灯泡、一个开关、一些金属片，还有一个可以容纳这些元件的塑料外壳。 一个电路就是一个环路。只有从电池到导线，再到灯泡和开关，然后再通过导线回到电池的整个回路是连通的，灯泡才能被点亮。 电路这种环状回路的特性说明电路中有某种东西在循环流动，或许有些像水流过水管那样。 电流是由电子的运动而产生的。 所有的物质都是有原子构成的。每一个原子由三种粒子构成：它们分别是中子、质子和电子。你可以把原子的结构画成一个小太阳系，其中中子和质子被束缚在原子核内，而电子则围绕着原子核旋转，犹如行星围绕着太阳旋转一样。 原子之间可以通过化学的方式结合成分子。分子的性质通常与组成它的原子大相径庭。例如，水是由水分子组成的，每个水分子由两个氢原子和一个氧原子组成。很明显，水跟氢气或氧气都是截然不同的。 氢、氧、钠和氯都是元素。水和盐都是化合物。不过盐水是混合物而不是化合物，因为水和盐都各自保留着他们自己的性质。 一个原子中电子的数目一般情况下是与质子数目相同。但是在某些情况下，电子可能从原子中脱离。这就是电流产生的原因。 用琥珀在羊毛上摩擦使得羊毛掠夺了琥珀的部分电子。结果羊毛因为电子超过了质子数数而卷曲，而琥珀的电子数比质子少了。结果羊毛因为电子数超过了质子数而卷曲。 质子和电子都具有带电荷的性质。质子和电子所带的电荷是相反的。 当质子和电子在相同数目的条件下共存时，它们都处于最和谐、最稳定的状态。如果质子和电子出现失衡现象，它们就会试图进行自我修复。当地毯偷偷摸摸地从你的鞋子上挖走电子之后，一切会在你接触到一些东西时而感到被电了一下时，又回到了平衡状态。静电火花就是电子运动引起的，是电子通过一个回路——从地毯传到你的身体，在回到鞋子中的过程造成的。 在风暴中，底层的云积聚了大量电子而顶端的云失去电子；最后一道闪电划破长空，使这一切又回到了平衡。闪电就是大量电子从一端快速地移动到另一端所形成的。 手电筒电路的电流显然要比火花或者闪电更容易驾驭的多。电路中，某原子所含有的一个电子逃逸到它相邻的下一个原子中，与此同时，这个原子又从相邻的上一个原子中获取一个电子，而失去电子的原子又会从与其相邻的一个原子获得电子，如此循环。电路中的电子不断地从一个原子移动到下一个原子，就形成了电流。 所有的电池的内部都会发生化学反应，也就是说一些分子被分裂成其他的分子，或者分子间互相结合形成了新分子。它们之间的化学反应能够使多余的自由电子聚集到标符号“-”的那端，而标有正好“+”的那端则变得急需额外的电子。于是，化学能就转化成了电能。 串联：两块电池合在一起，一块1.5伏，串联后，电压变成3伏。并联：并联后的电压还是1.5伏，没有串联电池的灯泡亮，电池的使用寿命将会延长一倍。 对于电流来说容易“导通”的，被称作导体。最好的导体是铜、银河金。其中铜是用来制作导线最常见的材料。到导电性相反的是阻抗性。它几乎不能传导任何电流，被称作为绝缘体。橡胶和塑料都是很好的绝缘体，它们常常被用来包裹导线。不过事实上，只要电压足够高，任何物质都可以导电。 导线越长，阻抗性越高。导线越粗，阻抗性越低。 电压——亚历山大·伏特（Alessandro Volta， 1745-1827），电流做功的势。不管电池是否连接到电路中，电压都是存在的。想想一块砖，当它在地板上，只有很少的势能。把它从地面上举到离地板四英尺的高度，现在这块砖就会有比较多的势能。你只是拿着这块砖，它并没有做什么，但是这块砖的势能却差别迥异。 电流的计量单位是安培，得名已安德烈·玛丽·安培（André Marie Ampère， 1775-1836），简称安 电阻的单位是欧姆，得名于乔治·西蒙·欧姆（George Simon Ohm， 1789-1854）。著名的欧姆定律就是他提出的。1I = E/R I表示电流，E用来表示电压，R表示电阻。 一段铜线直接将正负极连接起来，这种情形称为短路。电阻非常小，电流变大非常大。如果电池足够大的话，导线将会变热，甚至融化。 如果导线电阻较低的话，它将变热并且发光。这就是白炽灯发光的道理。通常，白炽灯的发明者是托马斯·阿尔瓦·爱迪生（Thomas Alva Edison， 1847-1931），但是这种观点是在他取得灯泡的专利之后被广为传播的，实际上在这个领域上很多科学家都有过研究。 灯泡里面有一根很细的金属丝，我们称之为灯丝，一般情况下灯丝是用钨做成的。金属丝的电阻使它开始发热。如果暴露在空气中，钨丝将达到燃点并开始燃烧，但是在灯泡的真空泡室内，钨丝就会发出光亮。 瓦特这个单位得名于詹姆斯·瓦特（James Watt， 1736-1819）。瓦特是功率的计量单位，计算公式如下： 1P = E * I 开关只能是闭合状态或断开状态。电流只能是有或者无。灯泡只能是发光或者不发光。就像莫尔斯码和布莱叶发明的二进制码一样，这个简单的手电筒要么是开着的，要么是关着的。","tags":[{"name":"编码(隐匿在计算机软硬件背后的语言)","slug":"编码-隐匿在计算机软硬件背后的语言","permalink":"http://yoursite.com/tags/编码-隐匿在计算机软硬件背后的语言/"},{"name":"电流的产生","slug":"电流的产生","permalink":"http://yoursite.com/tags/电流的产生/"},{"name":"电的相关概念","slug":"电的相关概念","permalink":"http://yoursite.com/tags/电的相关概念/"}]},{"title":"3 布莱叶盲文与二进制码","date":"2017-10-22T16:00:00.000Z","path":"2017/10/23/code_3/","text":"一、布莱叶盲文前传路易斯·布莱叶（Louis Braille）于1809年出生于法国的库普雷，距离巴黎市东25英里的小镇。布莱叶的父亲是一个马具匠人。在布莱叶3岁的时候，在父亲的工作间玩耍，不小心被一个尖锐的工具刺伤了一只眼睛。伤口感染也影响到了他的另一只眼睛，最后双目失明。10岁送往巴黎皇家盲人学校学习。 瓦尔丁·霍伊是巴黎皇家盲人学校的创始人，发明过一种在纸面上印下凸起文字的系统。霍伊先生实力健全，因此他被自身的感知模式所禁锢。对他来说，一个字母A就是一个A，而且字母A在记录时也不许看起来（或者感觉起来）像一个A（如果让他用手电筒交流的话，估计他会试图在空中比划要表达的字母，但是其实我们发现这个法子根本不灵）。 查尔斯·巴比尔，法国军队的以为军官，在1819年发明了一种自称为夜间书写的文字系统。厚纸上使用凸起的点和划的组合来表示文字，即使光线很暗，士兵们也可以传递信息。使用一个锥形的铁笔在厚纸的背面书写，这样纸的正面就会有相应的凸起。 巴比尔文字系统的缺点是太过复杂了。该系统并非使用与字母相对的点划编码串来表示字母，而是用与读音相对的编码串表示，因此有时仅仅是为了表示一个单词，就不得不使用很多的码字。 布莱叶在12岁的时候很熟悉巴比尔的这种文字系统了。凸起的点通过手指很容易阅读，写起来也比较简单。3年以后（15岁）就创建了自己的系统，这个系统的一些基本规范，知道今天还在被人们使用。1835年，路易斯·布莱叶患上了肺结核。1852年，过完43岁生日不久，就去世了。 二、布莱叶盲文 字母、数字和标点符号都被编码成2×3的点码单位中的一个或者多个凸起的点。这个点码单位包含的点通常使用1到6的数字来编号。现代应用中，使用特殊的打印机或轧花机可以将布莱叶盲文引到纸上。 大点表示一个凸起的点，小点则表示对应的位置是平的。例如上面的布莱叶盲文，其中，1，3，5是凸起的，二第2，4，6的位置是平的。 这些点码都是二进制的。一个单独的点不是平的就是凸起的。每组6个点，也就是一共2^6=64中组合。 小写字母表 词组you and me 一个单词之间每个字母所对应的点码单元之间都用一小块空白分开；而单词之间则用一个大的空格(实际上是没有凸点的点码单元)所分隔开来。 目前在英文出版物中最常用的盲文系统被称为二级布莱叶盲文。用了很多缩写。例如，如果字母的码字单独出现，他们就表示一个普通的单词。 you and me 使用二级布莱叶盲文表示。 字母a到j的码字加上6号凸点的组合，表示字母串的缩写，还有w字母。 a到j的码字，降低他们的凸点，只用到2、3、5和6的点，这样就得到了新的码字。根据上下文环境，它们用来表示一些标点符号或者字符串缩写。 表示字符串缩写“ble”的码字很重要，因为当它不是用来作为单词的一部分时候、，它的出现就意味着之后的码字应被译为数字。表示数字的码字与表示字母a到j的码字是相同的。 6号凸点，大写标识符。这个符号表示它之后的字母都被译为大写。","tags":[{"name":"编码(隐匿在计算机软硬件背后的语言)","slug":"编码-隐匿在计算机软硬件背后的语言","permalink":"http://yoursite.com/tags/编码-隐匿在计算机软硬件背后的语言/"},{"name":"布莱叶盲文","slug":"布莱叶盲文","permalink":"http://yoursite.com/tags/布莱叶盲文/"}]},{"title":"2 编码与组合","date":"2017-10-21T16:00:00.000Z","path":"2017/10/22/code_2/","text":"大多数人都会发现莫尔斯码的发送比接受比较方便。即使你并不熟记莫尔斯码，也可以很方便地使用这张按字母顺序排列的表格。比起发送莫尔斯码，接收编码并进行解码要费事费力的多，因为译码者不得不根据一串由“点”、“划”组成的晦涩的编码序列来反查字母。例如，如果你接收到一串形如“划-点-划-划”的编码，那么你就必须从表的第一个字母开始逐个搜索，知道找到与这串编码相符的字母“Y”为止。 一、点或划的格式表示 或许根据编码中所包含点、划的多少来对其进行分组，是一个更好的组织这些编码的方法。例如，一个点或一个划的莫尔斯码只能代表两个字母：“E”和“T”。 . E - T .. I -. N .- A – M … S -.. D ..- U -.- K .-. R –. G .– W — O …. H -… B …- V -..- X ..-. F -.-. C ..– Ü -.– Y .-.. L –.. Z .-.- Ä –.- Q .–. P —. Ö .— J —- Š 二、码字个数 点和划的数目 码字的数目 1 2 2 4 3 8 4 16 点和划的数目 码字的数目 1 2 2 2×2 3 2×2×2 4 2×2×2×2 点和划的数目 码字的数目 1 2^1 2 2^2 3 2^3 4 2^4 三、莫尔斯码的树形图 四、莫尔斯码的个数的延伸 编码系统可以扩展到5位或者更长。如果是6位的话，第六位的个数有2^6=64，一共有2+4+8+16+32+64=126种。 点和划的数目 码字的数目 1 2^1=2 2 2^2=4 3 2^3=8 4 2^4=16 5 2^5=32 6 2^6=64 7 2^7=128 8 2^8=256 9 2^9=512 10 2^10=1024 五、总结莫尔斯码称作二进制码，因为这种编码的组成元素只有两个——“点”和“划”。","tags":[{"name":"编码(隐匿在计算机软硬件背后的语言)","slug":"编码-隐匿在计算机软硬件背后的语言","permalink":"http://yoursite.com/tags/编码-隐匿在计算机软硬件背后的语言/"},{"name":"编码与组合","slug":"编码与组合","permalink":"http://yoursite.com/tags/编码与组合/"}]},{"title":"1 至亲密友","date":"2017-10-20T16:00:00.000Z","path":"2017/10/21/code_1/","text":"一、问题场景 你今年10岁，你的朋友就住在你街对面。实际上，你们各自的卧室的窗户正好彼此相对。每当夜幕降临之后，你们父母就会逼你们上床睡觉，但是你和你朋友想要再交流一会。怎么办？没有电话，没有手机，没有电脑，只有一个手电筒，怎么交流？ 二、解决方案办法①：用手电筒在天空中画字母。对于字母o，就在天空中画一个圈。但是，你很快就会发现，这个办法行不通。当你看着朋友的手电筒在空中圈圈点点，会发现很难再头脑中组合出那么多复杂的笔画。这些光线画出来的字母不太准确。 办法②：每个字符对应一连串的手电筒闪烁。“A”是闪一次，“B”是闪两次，“C”是闪三次，以此类推，“Z”就是闪26次。单词BAD可以用闪2次，闪1次，闪4次这样的一个组合来表示，而且字符之间设置小停顿使得这个单词不至于被误认为闪7次的字母“G”。另外单词之间停顿可以少为长一些。 这种方案听起来好像不错，如果你想发送的第一个消息是“how are you？”，那么你将要让手电筒闪131次！而且，这还忽略了标点符号的，你还没有设计闪多少次来对应一个问号。 三、莫尔斯电码 办法二已经离答案很接近了。我们能够肯定的是，在此之前一定有人也遇到了类似的问题，而你办法二的思路也是非常正确的。到了白天，跑一趟图书馆，查查资料，你发现了一个被称为摩尔斯电码的伟大发明。 你的办法二中，闪1下为“A”，闪26下为“Z”。而在摩尔斯电码里，只有两种闪烁——短闪和长闪。句子”how are you?”现在只有闪32下，而不再是131下，而且这其中包括了一个代表符号的编码。 当问及摩尔斯电码是如何工作的时候，人们不会谈论“短闪”和“长闪”。相反，他们使用“点（dot）”和“划（dash）”，因为这是在打印纸上显示编码的一个便利方法。 四、编码与生活 实际上，编码就是交流。有时候，我们认为编码就是指秘密的东西（密码）。但是大部分编码不是这样的。毕竟，大部分编码必须易于理解，因为他们是人类交流的基础。 在《百年孤独》这本书的开篇里，加利亚·马尔克斯回忆了一个时代，那时“这世界刚刚出现，以至于很多东西缺乏命名，这时就有必要亲自用手指明这些事物”。我们赋予这些东西名字时往往是很随意的。这就好比说为什么猫不被叫做“狗”而狗不被叫做“猫”一样，没有什么理由可言。你可以说英文词汇是一种编码。 我们发出的声音所形成的词语就是一种可识别的编码，这种编码称之为“口头话语”或“言辞”。 对于写在纸上的词，我们叫它“书面语言”或“文本”。许多语言中，语言和文字之间存在着很紧密的联系。 对于那些丧失听说能力的聋哑人来说，手语就是一种编码 对于那些失明的人，书面语言可以用布莱叶盲文来替代。 五、编码与计算机 我们会看见，各种类型的编码也用在计算机里存储和传递数字、声音、音乐、图片和电影。 计算机不能直接处理人类的编码，因为计算机无法通过与人类的眼睛、耳朵、嘴巴和手指完全相同的方式来接收人类发出的信息。 现在的个人计算机能够获取、存储、处理和呈现一切用于与人类沟通的信息，无论视觉信息（文字和图片），还是听觉信息（口语、声音、和音乐），或两者的结合（动画和电影）。 所有这些类型的信息都需要他们各自的编码，就像人类说话需要一套器官（嘴和耳朵）而写作和阅读需要另一套（手和眼）一样。 六、摩尔斯编码实际应用 对于手电筒，我们发送“点”和“划”对应的闪烁光。 使用手电筒发送摩尔斯编码时，迅速地打开和关闭开关代表一个“点”（快闪），让闪光时间保持的相对长一些代表“划”（慢速闪光）。例如在发送A时，首先以非常快的速度打开并关闭手电，然后再以稍慢的速度进行一次。在发送下一个字符前，需要暂时停一会。再次约定，一个“划”的时长是“点”的3倍。例如，如果一个“点”的时长是1秒，那么一个“划”的时长就应当是3秒。（在现实中，莫尔斯码的传输速度远远比这快的多）。接受者看到一个短促的闪烁和一个拖长的闪光后，就知道这是个A了。 在摩尔斯电码中，“点”和“划”之间的停顿是至关重要的。例如，当发送一个字母A时，在发送的“点”和“划”之间，手电筒要关闭一段时间，这相当于一个点的闪烁时长（如果“点”的时长是1秒，那么“点”和“划”之间的停顿也应当是1秒）。对于同一个单词的字母，则通过较长的停顿来分割，这相当于一个“划”的时长（或者说是3秒，如果一个“划”的时长就是3秒的话）。单词与单词则通过相当于两个“划”的时长来分割（如果一个“划”的时长为2秒，那么这个停顿就应当为6秒）。 七、摩尔斯编码中的规律 乍一看，摩尔斯编码的定义与打字机字母的排列一样都是随意的。然而，仔细研究之后，我们就会发现事实并非如此。 简单且短促的编码，被分配给字母表中使用频率较高的字母，例如E和T。而不太常用的字母，比如Q和Z则被分配以较长的编码。 三个点、三个划，再加上三个点就表示SOS，即国际求救信号。SOS不是一个缩写，这只是一个易于记忆的摩尔斯编码序列。 摩尔斯编码的一个缺点是，它没有区分大写字母和小写字母。 八、马尔斯编码的口语 当你和朋友最终熟记了摩尔斯编码之后，你们甚至可以在口语中使用它，用来取代正常的语言。 为了使编码发送的速度最快，你可以把“点”读成“嘀（dib）”，把“划”读成“嗒（dab）”。文字也可以用同样的方式简化成“点”和“划”的序列，摩尔斯编码的口语版把讲话内容缩减到只剩下两个声音了。 九、总结 问题的关键就在于数字2。两种闪烁，两种声音。 事实上，两个不同的事物，只要经过适当的组合，就可以表示所有类型的信息，这的确是千真万确的。","tags":[{"name":"编码(隐匿在计算机软硬件背后的语言)","slug":"编码-隐匿在计算机软硬件背后的语言","permalink":"http://yoursite.com/tags/编码-隐匿在计算机软硬件背后的语言/"},{"name":"莫尔斯电码","slug":"莫尔斯电码","permalink":"http://yoursite.com/tags/莫尔斯电码/"}]},{"title":"word文档题库转化为xml文件","date":"2017-07-28T12:47:00.000Z","path":"2017/07/28/wordToXml/","text":"需求：123456789101112131415161718192021222324252627282930313233343536373839404142434445word文档转为xml文件 word文档如下：一、单选题（220题）1、消防头盔经高温、低温、浸水、热辐射预处理后进行冲击吸收性能试验，头模所受冲击力的最大值应不大于，帽壳不得有碎片脱落。（A）A、3780NB、3380NC、3580N D、3680N 二、多选题（200题） 1、消防员灭火防护服撕破强力不小于多少N，下列错误的是（ BCD）A、100 B、200 C、300 D、400 三、是非题（180题） 1、消防员灭火防护服的面料由外层、防水透气层、隔热层、舒适层组成。（√） 转为xml文件如下： &lt;ArrayOfTopic&gt; &lt;Topic&gt; &lt;TopicType&gt;1&lt;/TopicType&gt; &lt;Ask&gt;消防头盔经高温、低温、浸水、热辐射预处理后进行冲击吸收性能试验，头模所受冲击力的最大值应不大于，帽壳不得有碎片脱落。（）&lt;/Ask&gt; &lt;Answer&gt;A&lt;/Answer&gt; &lt;Option&gt; &lt;string&gt;A、3780N&lt;/string&gt; &lt;string&gt;B、3380N&lt;/string&gt; &lt;string&gt;C、3580N&lt;/string&gt; &lt;string&gt;D、3680N&lt;/string&gt; &lt;/Option&gt; &lt;/Topic&gt; &lt;Topic&gt; &lt;TopicType&gt;2&lt;/TopicType&gt; &lt;Ask&gt;消防员灭火防护服撕破强力不小于多少N，下列错误的是（）&lt;/Ask&gt; &lt;Answer&gt;BCD&lt;/Answer&gt; &lt;Option&gt; &lt;string&gt;A、10&lt;/string&gt; &lt;string&gt;B、20&lt;/string&gt; &lt;string&gt;C、30&lt;/string&gt; &lt;string&gt;D、400&lt;/string&gt; &lt;/Option&gt; &lt;/Topic&gt; &lt;Topic&gt; &lt;TopicType&gt;3&lt;/TopicType&gt; &lt;Ask&gt;消防员灭火防护服的面料由外层、防水透气层、隔热层、舒适层组成。（）&lt;/Ask&gt; &lt;Answer&gt;A&lt;/Answer&gt; &lt;/Topic&gt;&lt;/ArrayOfTopic&gt; 开发环境： 语言：java工具：myeclipse处理word文档：poi相关jar包处理xml文件：dom4j相关jar包 参考网址：java使用poi读取doc和docx文件利用dom4j创建xml文件并保存到本地实例 发现：poi会把word文档转化为一个字符串，我就把它输出来了，发现它是一行一行输出的。 于是我用split函数把它分割成了字符串数组。基本上是题目一行，当然有的题目也是两行，答案有的是一行，有的答案是大于两行的。 总体思路：就是一行一行的找，如果是题型就记下题型，如果是题目，就提取答案和题目，如果是答案选项，就提取答案选项。 然后我发现了这样一个现象：如果某一行以一、二、三开头的就表示题型，如果以1~9开头的就表示题目，如果A~F开头的就表示答案选项。 提取答案和题目：如果这一行是题目，就在这一行中提取答案，最开始的方法是：找括号里面的东西，利用 indexOf找到（和）的位置，利用substring截取。然后发现题目中也会出现括号，而且频率很高。于是换了一种方法，找到（并且它的下一位是字母，然后（后面找），这个）一定是离刚才找的（是最近的。 其实找到（和）位置之后，就可以把里面的答案替换成空字符就可以了。发现string类没有这个函数，StringBuffer里面的replace有这个方法。 提取答案选项：怎么得到答案选项呢？最开始的方法是以顿号分割，然后在截取拼接。发现这样也不行，因为答案选项中也有很多顿号的。于是换了一种方法，就是：从A开始，截取B前面那一位；在从B开始，截取到C前面那一位……D到最后。 注意的地方：文档很不标准，有的括号是英文的，有的括号是中文的。答案选项的A~F有的这种字体的，有的是另一种字体的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543package cn.leagle;import java.io.FileInputStream;import java.io.FileWriter;import java.io.IOException;import java.io.InputStream;import java.io.Writer;import org.apache.poi.xwpf.extractor.XWPFWordExtractor;import org.apache.poi.xwpf.usermodel.XWPFDocument;import org.dom4j.Document;import org.dom4j.DocumentHelper;import org.dom4j.Element;import org.dom4j.io.OutputFormat;import org.dom4j.io.XMLWriter;import org.junit.Test;/** * * @author leagle * * * * 一、 首先必须去掉换行 * * 比如： 消防头盔左、右水平视野应不小于____，上视野应不小于____，下视野 应不小于____。 * ( C ) * 改成：消防头盔左、右水平视野应不小于____，上视野应不小于____，下视野应不小于____。( C ) * * 二、输出所有题目的答案，以便查找的答案是否正确 * * 比如：(BMW) (B46) (ACF) * * * 有很多漏洞： * (1) 诸如包括字符串(ACF)的题目，解析的答案便会有错。 * (2) 诸如：A、3780EB、3380EC、3580E D、3680E这样的答案选项，解析的答案也会有错。 * * * */public class PoiTestDocx &#123; /* * 答案的漏洞测试 */ @Test public void optionTest() &#123; String temp = &quot;A、3780EB、3380EC、3580E D、3680E&quot;; temp = temp.replaceAll(&quot; &quot;, &quot;&quot;); int i = 0; for (char c = (char) (temp.charAt(i) + 1); c &lt;= &apos;F&apos;; c++) &#123; if (!temp.contains(&quot;&quot; + c)) &#123; char index = (char) (c - 1); String opString = temp.substring(temp.indexOf(index, temp.indexOf(index - 1))); System.out.println(opString); break; &#125; char index = (char) (c - 1); String opString = temp.substring(temp.indexOf(index), temp.indexOf(c, temp.indexOf(index))); System.out.println(opString); &#125; &#125; /** * * 生成的xml文件如下： * * &lt;ArrayOfTopic&gt; * &lt;Topic&gt; * &lt;TopicType&gt;1&lt;/TopicType&gt; * &lt;Ask&gt;消防头盔经高温、低温、浸水、热辐射预处理后进行冲击吸收性能试验，头模所受冲击力的最大值应不大于，帽壳不得有碎片脱落。（）&lt;/Ask&gt; * &lt;Answer&gt;A&lt;/Answer&gt; * &lt;Option&gt; * &lt;string&gt;A、3780N&lt;/string&gt; * &lt;string&gt;B、3380N&lt;/string&gt; * &lt;string&gt;C、3580N&lt;/string&gt; * &lt;string&gt;D、3680N&lt;/string&gt; * &lt;/Option&gt; * &lt;/Topic&gt; * * &lt;Topic&gt; * &lt;TopicType&gt;3&lt;/TopicType&gt; * &lt;Ask&gt;消防员灭火防护服的面料由外层、防水透气层、隔热层、舒适层组成。（）&lt;/Ask&gt; * &lt;Answer&gt;A&lt;/Answer&gt; * &lt;/Topic&gt; * &lt;/ArrayOfTopic&gt; */ @Test public void xmlTest() &#123; Document document = DocumentHelper.createDocument(); Element arrayOfTopic = document.addElement(&quot;ArrayOfTopic&quot;); Element topic = arrayOfTopic.addElement(&quot;Topic&quot;); Element topicType = topic.addElement(&quot;TopicType&quot;); topicType.addText(&quot;1&quot;); Element ask = topic.addElement(&quot;Ask&quot;); ask.addText(&quot;消防头盔经高温、低温、浸水、热辐射预处理后进行冲击吸收性能试验，头模所受冲击力的最大值应不大于，帽壳不得有碎片脱落。（）&quot;); Element answer = topic.addElement(&quot;Answer&quot;); answer.addText(&quot;A&quot;); Element option = topic.addElement(&quot;Option&quot;); Element strElement = option.addElement(&quot;string&quot;); strElement.addText(&quot;A、3780N&quot;); strElement = option.addElement(&quot;string&quot;); strElement.addText(&quot;B、3380N&quot;); strElement = option.addElement(&quot;string&quot;); strElement.addText(&quot;C、3580N&quot;); strElement = option.addElement(&quot;string&quot;); strElement.addText(&quot;D、3680N&quot;); topic = arrayOfTopic.addElement(&quot;Topic&quot;); topicType = topic.addElement(&quot;TopicType&quot;); topicType.addText(&quot;3&quot;); ask = topic.addElement(&quot;Ask&quot;); ask.addText(&quot;消防员灭火防护服的面料由外层、防水透气层、隔热层、舒适层组成。（）&quot;); answer = topic.addElement(&quot;Answer&quot;); answer.addText(&quot;A&quot;); try &#123; OutputFormat outputFormat = OutputFormat.createPrettyPrint(); outputFormat.setLineSeparator(&quot;\\r\\n&quot;); Writer writer = new FileWriter(&quot;D:\\\\dom4jTest2.xml&quot;); XMLWriter outPut = new XMLWriter(writer, outputFormat); outPut.write(document); outPut.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; @Test public void answerTest() &#123; String string = &quot;A、3780NB、3380NC、3580ND、3680N&quot;; int a = string.indexOf(&apos;A&apos;); int b = string.indexOf(&apos;B&apos;); int c = string.indexOf(&apos;C&apos;); int d = string.indexOf(&apos;D&apos;); System.out.println(string.substring(a, b)); System.out.println(string.substring(b, c)); System.out.println(string.substring(c, d)); System.out.println(string.substring(d)); &#125; /* 对于汉字, charAt函数适用不适用 */ @Test public void stringTest() &#123; String s = &quot;我是中国人&quot;; System.out.println(s.charAt(0)); System.out.println(s.charAt(1)); &#125; /* 测试去掉所有空格 */ @Test public void stripSpaceTest() &#123; String s = &quot;2、消防头盔左、右水平视野应不小于____，上视野应不小于____，下视野应不小于____。( C )&quot;; s = s.replaceAll(&quot; &quot;, &quot;&quot;); System.out.println(s); &#125; /** * @throws IOException * * word文档转为xml文件 * * word文档如下： * 一、单选题（220题） * 1、消防头盔经高温、低温、浸水、热辐射预处理后进行冲击吸收性能试验，头模所受冲击力的最大值应不大于，帽壳不得有碎片脱落。（A） * A、3780NB、3380NC、3580N D、3680N * * 二、多选题（200题） 1、消防员灭火防护服撕破强力不小于多少N，下列错误的是（ BCD） * A、100 B、200 C、300 D、400 * * 三、是非题（180题） 1、消防员灭火防护服的面料由外层、防水透气层、隔热层、舒适层组成。（√） * * 转为xml文件如下： * * &lt;ArrayOfTopic&gt; * &lt;Topic&gt; * &lt;TopicType&gt;1&lt;/TopicType&gt; * &lt;Ask&gt;消防头盔经高温、低温、浸水、热辐射预处理后进行冲击吸收性能试验，头模所受冲击力的最大值应不大于，帽壳不得有碎片脱落。（）&lt;/Ask&gt; * &lt;Answer&gt;A&lt;/Answer&gt; * &lt;Option&gt; * &lt;string&gt;A、3780N&lt;/string&gt; * &lt;string&gt;B、3380N&lt;/string&gt; * &lt;string&gt;C、3580N&lt;/string&gt; * &lt;string&gt;D、3680N&lt;/string&gt; * &lt;/Option&gt; * &lt;/Topic&gt; * * &lt;Topic&gt; * &lt;TopicType&gt;2&lt;/TopicType&gt; * &lt;Ask&gt;消防员灭火防护服撕破强力不小于多少N，下列错误的是（）&lt;/Ask&gt; * &lt;Answer&gt;BCD&lt;/Answer&gt; * &lt;Option&gt; * &lt;string&gt;A、10&lt;/string&gt; * &lt;string&gt;B、20&lt;/string&gt; * &lt;string&gt;C、30&lt;/string&gt; * &lt;string&gt;D、400&lt;/string&gt; * &lt;/Option&gt; * &lt;/Topic&gt; * * &lt;Topic&gt; * &lt;TopicType&gt;3&lt;/TopicType&gt; * &lt;Ask&gt;消防员灭火防护服的面料由外层、防水透气层、隔热层、舒适层组成。（）&lt;/Ask&gt; * &lt;Answer&gt;A&lt;/Answer&gt; * &lt;/Topic&gt; * &lt;/ArrayOfTopic&gt; * * * * * 注意的地方： * 1. 括号分两种,一种是（）,另一种是() * 2. 答案选项的字母分两种,一种是A~F,另一种是Ａ~Ｆ * */ @Test public void wordToXmlTest() throws IOException &#123; InputStream is = new FileInputStream(&quot;D:\\\\test.docx&quot;); XWPFDocument doc = new XWPFDocument(is); @SuppressWarnings(&quot;resource&quot;) XWPFWordExtractor extractor = new XWPFWordExtractor(doc); /* 把word文档转成string */ String text = extractor.getText(); /* 把每行分出来 */ String[] textString = text.split(&quot;\\n&quot;); String topicType = &quot;&quot;; String number = &quot;&quot;; /* 创建xml总结点ArrayOfTopic */ Document document = DocumentHelper.createDocument(); Element root = document.addElement(&quot;ArrayOfTopic&quot;); Element option = null; /* 遍历每一行 */ for (String string : textString) &#123; if (string.length() == 0) continue; /* * 获取每行的第一个字符, 根据第一个字符来判断属于哪种情况 * * 第一种情况：一、单选题（220题） * 结果：类型 * 判断：其中有一、二、三代表地址一种情况 * * 第二种情况：1、消防头盔经高温、低温、浸水、热辐射预处理后进行冲击吸收性能试验，头模所受冲击力的最大值应不大于，帽壳不得有碎片脱落。（A） * 结果：题目和答案 * 判断：其中1~9代表第二种情况 * * 第三种情况：A、3780NB、3380NC、3580N D、3680N * 结果：答案选项 * 判断：其中A~F代表第三种情况 */ int i = 0; /* * 去掉所有空格 * * 原因：( A ) 变成 (A) * 目的：找出答案前面那个括号的位置 * 同时也规范了题目和答案 */ String temp = string.replaceAll(&quot; &quot;, &quot;&quot;); /* topic节点 */ Element Topic = null; /* 得到类型 */ if (temp.charAt(i) == &apos;一&apos;) &#123; topicType = &quot;1&quot;; &#125; else if (temp.charAt(i) == &apos;二&apos;) &#123; topicType = &quot;2&quot;; &#125; else if (temp.charAt(i) == &apos;三&apos;) &#123; topicType = &quot;3&quot;; &#125; /* * 属于题目类型 * 原型为：1、消防头盔经高温、低温、浸水、热辐射预处理后进行冲击吸收性能试验，头模所受冲击力的最大值应不大于，帽壳不得有碎片脱落。（A） * * 需求: 得到答案：A * 得到题目：消防头盔经高温、低温、浸水、热辐射预处理后进行冲击吸收性能试验，头模所受冲击力的最大值应不大于，帽壳不得有碎片脱落。（） */ if (&apos;0&apos; &lt;= temp.charAt(i) &amp;&amp; temp.charAt(i) &lt;= &apos;9&apos;) &#123; Topic = root.addElement(&quot;Topic&quot;); /* * 得到题目的序号 * * 原型：1、消防头盔经高温 序号：1 解决：截取开始到顿号之间的字符串 */ number = temp.substring(i, temp.indexOf(&quot;、&quot;)); /* 添加TopicType节点并且赋予内容 */ Element TopicType = Topic.addElement(&quot;TopicType&quot;); TopicType.addText(topicType); int start = 0, end = 0; /* * 去掉序号和顿号 * * 原型：1、消防头盔经高温、低温、浸水、热辐射预处理后进行冲击吸收性能试验，头模所受冲击力的最大值应不大于，帽壳不得有碎片脱落。（A） * 结果：消防头盔经高温、低温、浸水、热辐射预处理后进行冲击吸收性能试验，头模所受冲击力的最大值应不大于，帽壳不得有碎片脱落。（A） * 解决：截取顿号到最后之间的字符串 */ String substr = temp.substring(temp.indexOf(&quot;、&quot;) + 1); /* * 找到答案前面括号前面的括号的位置 * * 原型为：消防头盔经高温、低温、浸水、热辐射预处理后进行冲击吸收性能试验，头模所受冲击力的最大值应不大于，帽壳不得有碎片脱落。（A） * * 解决： * 找到到( 或者 （ 并且下一位是字母, 就代表找到了位置 * 当然这也不是正确答案, 比如(BMW) (B46)(ACF) * 需要自己查看找出的答案是否正确 */ for (int j = 0; j &lt; substr.length(); j++) &#123; if (substr.charAt(j) == &apos;（&apos; || substr.charAt(j) == &apos;(&apos;) &#123; if (&apos;A&apos; &lt;= substr.charAt(j + 1) &amp;&amp; substr.charAt(j + 1) &lt;= &apos;F&apos;) &#123; /*发现有一个例子(B46), 防止它的出现*/ if (&apos;0&apos; &lt;= substr.charAt(j + 2) &amp;&amp; substr.charAt(j + 2) &lt;= &apos;9&apos;) &#123; continue; &#125; start = j; break; &#125; else if (&apos;Ａ&apos; &lt;= substr.charAt(j + 1) &amp;&amp; substr.charAt(j + 1) &lt;= &apos;Ｆ&apos;) &#123; /*发现有一个例子(B46), 防止它的出现*/ if (&apos;0&apos; &lt;= substr.charAt(j + 2) &amp;&amp; substr.charAt(j + 2) &lt;= &apos;9&apos;) &#123; continue; &#125; start = j; break; &#125; else if (substr.charAt(j + 1) == &apos;√&apos; || substr.charAt(j + 1) == &apos;×&apos;) &#123; /*发现有一个例子(B46), 防止它的出现*/ if (&apos;0&apos; &lt;= substr.charAt(j + 2) &amp;&amp; substr.charAt(j + 2) &lt;= &apos;9&apos;) &#123; continue; &#125; start = j; break; &#125; &#125; &#125; /* * 检测题目中是否只有一个换行符 * * 原型： * 1、消防头盔经高温、低温、浸水、热辐射预处理后进行冲击吸收性能试验，头模所受冲击力的最大值应不大于， * 帽壳不得有碎片脱落。（A） * * 这样的话,是没有括号的,必须要把它变成一行 * * 变成这样： * 1、消防头盔经高温、低温、浸水、热辐射预处理后进行冲击吸收性能试验，头模所受冲击力的最大值应不大于，帽壳不得有碎片脱落。（A） */ if (start == 0) &#123; System.out.println(&quot;TopicType:&quot; + topicType + &apos;\\t&apos; + number + &quot;题目中出现了两个换行符&quot;); continue; &#125; /* * 找出答案后面的那个括号 * * 解决： 既然找到了左边括号, 就从这个位置开始查找右边括号 两个式子的原因是 因为有两种括号 */ end = Math.max(end, substr.indexOf(&quot;)&quot;, start)); end = Math.max(end, substr.indexOf(&quot;）&quot;, start)); /* * 使用StringBuffer的原因是想使用它的replace(int start, int end, Stringstr) */ StringBuffer s = new StringBuffer(substr); /* 把答案替换成空格,以便得出题目 */ String ask = s.replace(start + 1, end, &quot;&quot;).toString(); /* 添加Ask节点并且赋予内容 */ Element Ask = Topic.addElement(&quot;Ask&quot;); Ask.addText(ask); /* 获取答案 */ String answer = substr.substring(start + 1, end); // System.out.println(answer); /* 添加Answer节点 */ Element Answer = Topic.addElement(&quot;Answer&quot;); /* * 如果题目是判断对错类型 * * √用A表示,×用B表示 */ if (answer.equals(&quot;√&quot;)) &#123; answer = &quot;A&quot;; &#125; else if (answer.equals(&quot;×&quot;)) &#123; answer = &quot;B&quot;; &#125; else &#123; /* 添加Option节点 */ option = Topic.addElement(&quot;Option&quot;); &#125; /* 给Answer节点赋予内容 */ Answer.addText(answer); &#125; /* * 属于答案类型, 需要获取答案选项 * * 原型为：A、3780NB、3380NC、3580N D、3680N * * 需求: * A、3780N * B、3380N * C、3580N * D、3680N * * 截取A到B前面那个字符, 即为：A、3780N * 截取B到C前面那个字符, 即为：B、3380N * 截取C到D前面那个字符, 即为：C、3580N * 截取D到最后, 即为：D、3680N * * 还是有漏洞 * 比如：A、3780EB、3380EC、3580E D、3680E * 会分成： * A、3780E * B、3380E * C、3580E * D、3680 * E * * * 因为有A和Ａ,所以分了两种情况 */ if (&apos;A&apos; &lt;= temp.charAt(i) &amp;&amp; temp.charAt(i) &lt;= &apos;F&apos;) &#123; for (char c = (char) (temp.charAt(i) + 1); c &lt;= &apos;F&apos;; c++) &#123; if (!temp.contains(&quot;&quot; + c)) &#123; char index = (char) (c - 1); String opString = temp.substring(temp.indexOf(index, temp.indexOf(index - 1))); Element str = option.addElement(&quot;string&quot;); str.addText(opString); break; &#125; char index = (char) (c - 1); String opString = temp.substring(temp.indexOf(index), temp.indexOf(c, temp.indexOf(index))); Element str = option.addElement(&quot;string&quot;); str.addText(opString); &#125; &#125; else if (&apos;Ａ&apos; &lt;= temp.charAt(i) &amp;&amp; temp.charAt(i) &lt;= &apos;Ｆ&apos;) &#123; for (char c = (char) (temp.charAt(i) + 1); c &lt;= &apos;Ｆ&apos;; c++) &#123; if (!temp.contains(&quot;&quot; + c)) &#123; char index = (char) (c - 1); String opString = temp.substring(temp.indexOf(index, temp.indexOf(index - 1))); Element str = option.addElement(&quot;string&quot;); str.addText(opString); break; &#125; char index = (char) (c - 1); String opString = temp.substring(temp.indexOf(index), temp.indexOf(c, temp.indexOf(index))); Element str = option.addElement(&quot;string&quot;); str.addText(opString); &#125; &#125; &#125; try &#123; OutputFormat outputFormat = OutputFormat.createPrettyPrint(); outputFormat.setLineSeparator(&quot;\\r\\n&quot;); Writer writer = new FileWriter(&quot;D:\\\\dom4jTest.xml&quot;); XMLWriter outPut = new XMLWriter(writer, outputFormat); outPut.write(document); outPut.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; close(is); &#125; /** * 关闭输入流 * * @param is */ private static void close(InputStream is) &#123; if (is != null) &#123; try &#123; is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 使用方法：根据提示，把题目中间的换行符去掉。然后输出所有答案，如果答案有错的，那只有手动书写这道题目了。 奇葩问题：然后我就遇到了一个很奇葩的问题，我需要取字符串的第一个字符，在遍历的时候会出错，这个放到最后再说。因为不一定每一个人都会犯这样的错误。 代码如下：123456789//word字符串String text = extractor.getText();//分割出来String[] textString = text.split(&quot;\\n&quot;);//遍历for (String string : textString) &#123; //去得第一个字符 temp.charAt(0);&#125; 12报错：java.lang.StringIndexOutOfBoundsException: String index out of range: 0 12思考：0也取不到吗？这不可能啊! 换了一种方式：1234567891011String text = extractor.getText();//分割出来String[] textString = text.split(&quot;\\n&quot;);//遍历for (String string : textString) &#123; //去得第一个字符 for(int i = 0 ; i &lt; stirng.length(); i++) &#123; temp.charAt(i); break; &#125;&#125; 12结果：这样就是对的，我真的百思不得其解。然后我就这样写了。 12345678910111213真相：后来我知道是怎么回事了。上海市消防总队2017年后勤岗位练兵理论题库（9-中队装备技师岗位）一、单选题（220题）第三行是空行，取不到charAt(0);我上面的代码，定义了一个i，就是这么来的。因为太多i了，所以就直接添加了个i。","tags":[{"name":"poi","slug":"poi","permalink":"http://yoursite.com/tags/poi/"},{"name":"dom4j","slug":"dom4j","permalink":"http://yoursite.com/tags/dom4j/"},{"name":"word文档题库解析","slug":"word文档题库解析","permalink":"http://yoursite.com/tags/word文档题库解析/"},{"name":"xml文件创建","slug":"xml文件创建","permalink":"http://yoursite.com/tags/xml文件创建/"}]},{"title":"构造队列","date":"2017-07-13T09:09:00.000Z","path":"2017/07/13/queue/","text":"题目链接：网易有道2017内推编程题第二题 12时间限制：1秒空间限制：32768K 小明同学把1到n这n个数字按照一定的顺序放入了一个队列Q中。现在他对队列Q执行了如下程序：1234567891011121314151617while(!Q.empty()) //队列不空，执行循环&#123; int x=Q.front(); //取出当前队头的值x Q.pop(); //弹出当前队头 Q.push(x); //把x放入队尾 x = Q.front(); //取出这时候队头的值 printf(&quot;%d\\n&quot;,x); //输出x Q.pop(); //弹出这时候的队头&#125; 做取出队头的值操作的时候，并不弹出当前队头。小明同学发现，这段程序恰好按顺序输出了1,2,3,…,n。现在小明想让你构造出原始的队列，你能做到吗？[注：原题样例第三行5有错，应该为3，以下已修正] 输入描述: 第一行一个整数T（T ≤ 100）表示数据组数，每组数据输入一个数n（1 ≤ n ≤ 100000），输入的所有n之和不超过200000。 输出描述: 对于每组数据，输出一行，表示原始的队列。数字之间用一个空格隔开，不要在行末输出多余的空格. 输入: 412310 输出： 12 12 1 38 1 6 2 10 3 7 4 9 5 我的思路：本来也想逆推来着，可是不知道怎么推，就按照题目的意思一步一步把原数组推出来。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main(int argc, char *argv[])&#123; int T; cin&gt;&gt;T; vector&lt;vector&lt;int&gt; &gt; b; for (int k = 0; k &lt; T; k++) &#123; int n; cin&gt;&gt;n; vector&lt;int&gt; a(n); b.push_back(vector&lt;int&gt;(n)); for (int i = 0; i &lt; n; i++) a[i] = i; int front = 0, rear = n - 1; for (int i = 1; i &lt;= n; i++) &#123; int x = a[front]; front = (front + 1) % n; rear = (rear + 1) % n; a[rear] = x; x = a[front]; b[k][x] = i; front = (front + 1) % n; &#125; &#125; for (int i = 0; i &lt; T; i++) &#123; for (int j = 0; j &lt; b[i].size(); j++) &#123; if (j == 0) cout&lt;&lt;b[i][j]; else cout&lt;&lt;&apos; &apos;&lt;&lt;b[i][j]; &#125; cout&lt;&lt;endl; &#125; return 0;&#125;","tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"},{"name":"网易有道","slug":"网易有道","permalink":"http://yoursite.com/tags/网易有道/"},{"name":"队列","slug":"队列","permalink":"http://yoursite.com/tags/队列/"}]},{"title":"洗牌","date":"2017-07-13T09:08:00.000Z","path":"2017/07/13/cards/","text":"题目链接：网易有道2017内推编程题第一题 12时间限制：1秒空间限制：32768K 洗牌在生活中十分常见，现在需要写一个程序模拟洗牌的过程。现在需要洗2n张牌，从上到下依次是第1张，第2张，第3张一直到第2n张。首先，我们把这2n张牌分成两堆，左手拿着第1张到第n张（上半堆），右手拿着第n+1张到第2n张（下半堆）。接着就开始洗牌的过程，先放下右手的最后一张牌，再放下左手的最后一张牌，接着放下右手的倒数第二张牌，再放下左手的倒数第二张牌，直到最后放下左手的第一张牌。接着把牌合并起来就可以了。例如有6张牌，最开始牌的序列是1,2,3,4,5,6。首先分成两组，左手拿着1,2,3；右手拿着4,5,6。在洗牌过程中按顺序放下了6,3,5,2,4,1。把这六张牌再次合成一组牌之后，我们按照从上往下的顺序看这组牌，就变成了序列1,4,2,5,3,6。 现在给出一个原始牌组，请输出这副牌洗牌k次之后从上往下的序列。 输入描述: 第一行一个数T(T ≤ 100)，表示数据组数。对于每组数据，第一行两个数n,k(1 ≤ n,k ≤ 100)，接下来一行有2n个数a1,a2,…,a2n(1 ≤ ai ≤ 1000000000)。表示原始牌组从上到下的序列。 输出描述: 对于每组数据，输出一行，最终的序列。数字之间用空格隔开，不要在行末输出多余的空格 输入: 33 11 2 3 4 5 63 21 2 3 4 5 62 21 1 1 1 输出： 1 4 2 5 3 61 5 4 3 2 61 1 1 1 我的思路：我就照着题目的思路写了一下，原本以为会超时，没想到没有超时，而且还通过了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main(int argc, char *argv[])&#123; int T, n; cin&gt;&gt;T; vector&lt; vector&lt;int&gt; &gt; a (T, vector&lt;int&gt;()); vector&lt;int&gt; k(T); for (int i = 0; i &lt; T; i++) &#123; cin&gt;&gt;n&gt;&gt;k[i]; for (int j = 0; j &lt; 2 * n; j++) &#123; int temp; cin&gt;&gt;temp; a[i].push_back(temp); &#125; &#125; for (int i = 0; i &lt; T; i++) &#123; for (int j = 0; j &lt; k[i]; j++) &#123; n = a[i].size() / 2; vector&lt;int&gt; b(n), c(n); for (int j = 0; j &lt; n; j++) &#123; b[j] = a[i][j]; &#125; for (int j = n; j &lt; 2 * n; j++) &#123; c[j - n] = a[i][j]; &#125; int m = 2 * n - 1; for (int j = n - 1; j &gt;= 0; j--) &#123; a[i][m] = c[j]; m--; a[i][m] = b[j]; m--; &#125; &#125; &#125; for (int i = 0; i &lt; T; i++) &#123; for (int j = 0; j &lt; a[i].size(); j++) &#123; if (j == 0) cout&lt;&lt;a[i][j]; else cout&lt;&lt;&apos; &apos;&lt;&lt;a[i][j]; &#125; cout&lt;&lt;endl; &#125; return 0;&#125; 12345678910111213141516171819202122看了评论之后，一个人说： 如果当前数小于等于n（即在左手），则他下次出现的位置是 2*当前位置-1 如果当前位置大于n（即在右手）,则他下次出现的位置是 2*（当前位置 - n）我就又重新思考，他们的位置关系：对于数组：1 2 3 4 5 6第一次后：1 4 2 5 3 6第二次后：1 5 4 3 2 6你便会发现： 前3个位于1、3、5, 对于代码而言：0、2、4 后3个位于2、4、6, 对于代码而言：1、3、5for (int i = 0; i &lt; n; i++) a[2 * i] = b[i];for (int i = 0; i &lt; n; i++) a[2 * i + 1] = b[i + n];发现也可以写到一起：for (int i = 0; i &lt; n; i++) &#123; a[2 * i] = b[i]; a[2 * i + 1] = b[i + n];&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;vector&gt; #include &lt;algorithm&gt;using namespace std;int main(int argc, char *argv[])&#123; vector&lt;int&gt; getSqe(int n, int k); int T; cin&gt;&gt;T; int n, k; vector&lt;vector&lt;int&gt; &gt; result; while(T--) &#123; cin&gt;&gt;n&gt;&gt;k; result.push_back(getSqe(n, k)); &#125; for (int i = 0; i &lt; result.size(); i++) &#123; for (int j = 0; j &lt; result[i].size(); j++) &#123; if (j == 0) &#123; cout&lt;&lt;result[i][j]; &#125; else &#123; cout&lt;&lt;&apos; &apos;&lt;&lt;result[i][j]; &#125; &#125; cout&lt;&lt;endl; &#125; return 0;&#125;vector&lt;int&gt; getSqe(int n, int k) &#123; vector&lt;int&gt; result(2 * n); for (int i = 0; i &lt; 2 * n; i++) &#123; cin&gt;&gt; result[i]; &#125; while (k--) &#123; vector&lt;int&gt; temp(result.begin(), result.end()); for (int i = 0; i &lt; n; i++) &#123; result[2 * i] = temp[i]; result[2 * i + 1] = temp[n + i]; &#125; &#125; return result;&#125;","tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"},{"name":"网易有道","slug":"网易有道","permalink":"http://yoursite.com/tags/网易有道/"},{"name":"找规律","slug":"找规律","permalink":"http://yoursite.com/tags/找规律/"}]},{"title":"分饼干","date":"2017-07-11T08:18:00.000Z","path":"2017/07/11/cookies/","text":"题目链接：网易2017春招笔试真题编程题集合第十二题 12时间限制：1秒空间限制：32768K 易老师购买了一盒饼干，盒子中一共有k块饼干，但是数字k有些数位变得模糊了，看不清楚数字具体是多少了。易老师需要你帮忙把这k块饼干平分给n个小朋友，易老师保证这盒饼干能平分给n个小朋友。现在你需要计算出k有多少种可能的数值 输入描述: 输入包括两行： 第一行为盒子上的数值k，模糊的数位用X表示，长度小于18(可能有多个模糊的数位) 第二行为小朋友的人数n 输出描述: 输出k可能的数值种数，保证至少为1 输入: 9999999999999X3 输出： 4 我的思路：把所有情况找出来，不就得了，就用了回溯法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;using namespace std;#include&lt;vector&gt;string s;int sum = 0;int main(int argc, char *argv[])&#123; long long getIntValue(string s); // 把字符串转化为数字 vector&lt;int&gt; getXVector(string s);// 得到X的位置 void getKinds(vector&lt;int&gt; x, int k, int n);// 获得所有的情况 int n; cin&gt;&gt;s&gt;&gt;n; vector&lt;int&gt; x = getXVector(s); getKinds(x, 0, n); cout&lt;&lt;sum&lt;&lt;endl; return 0;&#125;long long getIntValue(string s) &#123; long long value = 0; for(int i = 0; i &lt; s.size(); i++) &#123; value = value * 10 + (s[i] - &apos;0&apos;); &#125; return value;&#125;vector&lt;int&gt; getXVector(string s) &#123; vector&lt;int&gt; x; for(int i = 0; i &lt; s.size(); i++) &#123; if (s[i] == &apos;X&apos;) x.push_back(i); &#125; return x;&#125;void getKinds(vector&lt;int&gt; x, int k, int n) &#123; if (k == x.size()) &#123; long long num = getIntValue(s); if (num % n == 0) sum++; &#125; else &#123; for (int i = 0; i &lt;= 9; i++) &#123; if (x[k] == 0 &amp;&amp; i == 0) continue; s[x[k]] = &apos;0&apos; + i; getKinds(x, k + 1, n); &#125; &#125;&#125; 1结果：运行超时。 参考： 古典文化的评论 12dp[i][j] 表示从从左往右数，第i位数字，余数为j的个数 dp[0][0] = 1 代表初始情况下模n为0的个数为1 12345678910int newJ = (j * 10 + k) % n; 如上图所示，4774 % 4=2，过程是怎么样来的？ 可以细化为： 第一位数为4：(0 * 10 + 4) % 4 = 0 tip: 0 * 10，所以dp[0][0] = 1 第二位数为7：(0 * 10 + 7) % 4 = 3 第三位数为7：(3 * 10 + 7) % 4 = 1 第四位数为3：(1 * 10 + 4) % 4 = 2 dp[i][newJ] += dp[i - 1][j]; newJ(i)是由j(i-1)得来的，所以满足j(i-1)的情况下会同样满足newJ(i)，所以满足newJ(i)的个数等于本身的个数加上满足j(i-1)的个数。 4772 % 4 这个延续的过程，如下： 0 1 2 3 0 1 0 0 0 1(4) 1 0 0 0 2(7) 0 0 0 1 3(7) 0 1 0 0 4(4) 0 0 1 0 又比如2X % 2 的所有情况，如下： 0 1 0 1 0 1(2) 1 0 2(X) 5 5 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main(int argc, char *argv[])&#123; string s; int n; cin&gt;&gt;s&gt;&gt;n; vector&lt;vector&lt;int&gt; &gt; dp (s.length() + 1, vector&lt;int&gt;(n, 0)); dp[0][0] = 1; for (int i = 1; i &lt;= s.length(); i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (dp[i - 1][j] == 0) continue; if (s[i - 1] == &apos;X&apos;) &#123; for (int k = 0; k &lt; 10; k++) &#123; int temp = (j * 10 + k) % n; dp[i][temp] += dp[i - 1][j]; &#125; &#125; else &#123; int temp = (j * 10 + (s[i - 1] - &apos;0&apos;)) % n; dp[i][temp] += dp[i - 1][j]; &#125; &#125; &#125; cout&lt;&lt;dp[s.length()][0]&lt;&lt;endl; return 0;&#125; 1测试用例通过90%，原因是因为结果太大，int装不下，只要把int改成long long就可以了。 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main(int argc, char *argv[])&#123; string s; int n; cin&gt;&gt;s&gt;&gt;n; // 注意类型 long long vector&lt;vector&lt;long long&gt; &gt; dp (s.length() + 1, vector&lt;long long&gt;(n, 0)); dp[0][0] = 1; for (int i = 1; i &lt;= s.length(); i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (dp[i - 1][j] == 0) continue; if (s[i - 1] == &apos;X&apos;) &#123; for (int k = 0; k &lt; 10; k++) &#123; int temp = (j * 10 + k) % n; dp[i][temp] += dp[i - 1][j]; &#125; &#125; else &#123; int temp = (j * 10 + (s[i - 1] - &apos;0&apos;)) % n; dp[i][temp] += dp[i - 1][j]; &#125; &#125; &#125; cout&lt;&lt;dp[s.length()][0]&lt;&lt;endl; return 0;&#125; 1当然，可以改成二维数组。 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main(int argc, char *argv[])&#123; string s; int n; cin&gt;&gt;s&gt;&gt;n; vector&lt;vector&lt;long long&gt; &gt; dp (2, vector&lt;long long&gt;(n, 0)); dp[0 &amp; 1][0] = 1; for (int i = 1; i &lt;= s.length(); i++) &#123; for (int j = 0; j &lt; n; j++) // 注意的地方，用之前，先置为0 dp[i &amp; 1][j] = 0; for (int j = 0; j &lt; n; j++) &#123; if (dp[(i - 1) &amp; 1][j] == 0) continue; if (s[i - 1] == &apos;X&apos;) &#123; for (int k = 0; k &lt; 10; k++) &#123; int temp = (j * 10 + k) % n; dp[i &amp; 1][temp] += dp[(i - 1) &amp; 1][j]; &#125; &#125; else &#123; int temp = (j * 10 + (s[i - 1] - &apos;0&apos;)) % n; dp[i &amp; 1][temp] += dp[(i - 1) &amp; 1][j]; &#125; &#125; &#125; cout&lt;&lt;dp[s.length() &amp; 1][0]&lt;&lt;endl; return 0;&#125;","tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"},{"name":"网易","slug":"网易","permalink":"http://yoursite.com/tags/网易/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"}]},{"title":"堆砖块","date":"2017-07-10T08:15:00.000Z","path":"2017/07/10/bricks/","text":"题目链接：网易2017春招笔试真题编程题集合第十一题 12时间限制：1秒空间限制：32768K 小易有n块砖块，每一块砖块有一个高度。小易希望利用这些砖块堆砌两座相同高度的塔。为了让问题简单，砖块堆砌就是简单的高度相加，某一块砖只能使用在一座塔中一次。小易现在让能够堆砌出来的两座塔的高度尽量高，小易能否完成呢。 输入描述: 输入包括两行：第一行为整数n(1 ≤ n ≤ 50)，即一共有n块砖块第二行为n个整数，表示每一块砖块的高度height[i] (1 ≤ height[i] ≤ 500000) 输出描述: 如果小易能堆砌出两座高度相同的塔，输出最高能拼凑的高度，如果不能则输出-1.保证答案不大于500000。 输入: 32 3 5 输出： 5 我的思路：这不就是01背包问题吗？我就快马加鞭的写了一通。1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;#define N 50#define MAX 500001int main(int argc, char *argv[])&#123; int a[N],b[MAX]=&#123;0&#125;; int sum = 0; int n; cin&gt;&gt;n; for (int i = 0; i &lt; n; i++) &#123; cin&gt;&gt;a[i]; sum += a[i]; &#125; if (sum % 2 != 0) &#123; cout&lt;&lt;-1&lt;&lt;endl; return 0; &#125; else sum /= 2; for (int i = 0; i &lt; n; i++) &#123; int value = a[i]; for (int j = sum; j &gt;= 1; j--) &#123; int temp = b[j - value] + value; if (j &gt;= value &amp;&amp; temp &gt; b[j]) b[j] = temp; &#125; &#125; if (b[sum] == sum) cout&lt;&lt;sum&lt;&lt;endl; else cout&lt;&lt;-1&lt;&lt;endl; return 0;&#125; 1结果：没有通过所有实例，原来不是所有的砖块都要用到，比如3,3,5那么答案就是3。这就和01背包相差甚远了。 参考1： 双塔问题 大致意思就是这样，dp[i][j] 表示高度分别为i和j是否存在。若存在即为1，若不存在即为0。 dp[0][0] = 1 代表存在高度分别为0和0的情况，比如什么都不放。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main(int argc, char *argv[])&#123; int sum = 0, n; cin&gt;&gt;n; vector&lt;int&gt; a(n); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; sum += a[i]; &#125; sum /= 2; vector&lt; vector&lt;int&gt; &gt; dp(2, vector&lt;int&gt;(sum + 1, 0)); dp[0][0] = 1; for (int i = 0; i &lt; n; i++) &#123; int value = a[i]; for (int j = sum; j &gt;= 0; j--) &#123; for (int k = sum; k &gt;= 0; k--) &#123; if (j &gt;= value) dp[j][k] = dp[j][k] || dp[j - value][k]; if (k &gt;= value) dp[j][k] = dp[j][k] || dp[j][k - value]; &#125; &#125; &#125; for (int i = 1; i &lt;= sum; i++) &#123; if (dp[i][i] == 1) &#123; cout&lt;&lt;i&lt;&lt;endl; return 0; &#125; &#125; cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl; return 0;&#125; 1结果：内存超限 参考2： 古典文化的评论参考1里面把这种方法已经讲的很详细了，我就不多说了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main(int argc, char *argv[])&#123; int n; cin&gt;&gt;n; vector&lt;int&gt; a(n + 1), sum(n + 1); for (int i = 1; i &lt;= n; i++) cin&gt;&gt;a[i]; sum[0] = 0; for (int i = 1; i &lt;= n; i++) &#123; sum[i] = a[i] + sum[i - 1]; &#125; vector&lt; vector&lt;int&gt; &gt; dp(n + 1, vector&lt;int&gt;(sum[n] + 1, -1)); dp[0][0] = 0; for (int i = 1; i &lt;= n; i++) &#123; int value = a[i]; for (int j = sum[i]; j &gt;= 0; j--) &#123; dp[i][j] = dp[i-1][j]; if (j + value &lt;= sum[i] &amp;&amp; dp[i - 1][j + value] != -1) &#123; dp[i][j] = max(dp[i][j], dp[i - 1][j + value]); &#125; if (value &gt;= j &amp;&amp; dp[i - 1][value - j] != -1) &#123; dp[i][j] = max(dp[i][j], dp[i - 1][value - j] + j); &#125; if (j &gt; value &amp;&amp; dp[i - 1][j - value] != -1) &#123; dp[i][j] = max(dp[i][j], dp[i - 1][j - value] + value); &#125; &#125; &#125; if (dp[n][0] == 0) cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl; else cout&lt;&lt;dp[n][0]&lt;&lt;endl; return 0;&#125; 1结果：内存超限。 还记得01背包将多维数组变成一维数组，这个可不可以变成一维数组呢？答案是不可以，只能缩短为二位数组，因为 dp[i][j] = dp[i-1][j]，它始终要用到前面一行的同为j列的结果。 0的时候第一行1的时候第二行(可以用第一行的结果)2的时候第一行(覆盖第一行（0）的数据，可以用第二行（1）的结果)3的时候第二行(覆盖第二行（2）的数据，可以用第一行（2）的结果) 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main(int argc, char *argv[])&#123; int n; cin&gt;&gt;n; vector&lt;int&gt; a(n + 1); vector&lt;int&gt; sum(n+1); sum[0] = 0; for (int i = 1; i &lt;= n; i++) &#123; cin&gt;&gt;a[i]; sum[i] = a[i] + sum[i - 1]; &#125; vector&lt; vector&lt;int&gt; &gt; dp(2, vector&lt;int&gt;(sum[n] + 1, -1)); dp[0][0] = 0; for (int i = 1; i &lt;= n; i++) &#123; int value = a[i]; for (int j = sum[i]; j &gt;= 0; j--) &#123; dp[i &amp; 1][j] = dp[ (i-1) &amp; 1][j]; if (j + value &lt;= sum[i] &amp;&amp; dp[ (i-1) &amp; 1][j + value] != -1) &#123; dp[i &amp; 1][j] = max(dp[i &amp; 1][j], dp[ (i-1) &amp; 1][j + value]); &#125; if (value &gt;= j &amp;&amp; dp[ (i-1) &amp; 1][value - j] != -1) &#123; dp[i &amp; 1][j] = max(dp[i &amp; 1][j], dp[ (i-1) &amp; 1][value - j] + j); &#125; if (j &gt;= value &amp;&amp; dp[ (i-1) &amp; 1][j - value] != -1) &#123; dp[i &amp; 1][j] = max(dp[i &amp; 1][j], dp[ (i-1) &amp; 1][j - value] + value); &#125; &#125; &#125; if (dp[n &amp; 1][0] == 0) cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl; else cout&lt;&lt;dp[n &amp; 1][0]&lt;&lt;endl; return 0;&#125; 1234567891011121314结果：成功。不过我有一点始终不明白，上述有四种情况，分别是：第一种：不放第二种：放到矮的那一堆，但是依旧是矮的（（j + value） &lt;= sum[i]）第三种：放到矮的那一堆，但是变成高的了（value &gt;= j）第四种：放到高的那一堆（j &gt;= value）第二种的时候，j可能大于value，j也有可能小于value，也就是说：满足第二种情况的时候有时候也满足第三种或第四种的条件，但是它不属于第三种或第四种情况，但是它会执行。满足第三种情况的时候有时候也满足第二种条件，但是它不属于第二种情况，但是它会执行。满足第四种情况的时候有时候也满足第二种条件，但是它不属于第二种情况，但是它会执行。但是结果是正确的，我始终想不通。 参考3： minnnng的评论 假设砖块分为A，B两堆，dp[i][j]中的j表示B-A的长度。而dp[i][j]的值则表示当B-A的值为j时，A的最大长度是多少。 因为B-A有可能是负的，所以j整体偏移sum个长度，即2*sum+1。dp[0][0] 代表相差 （-sum），dp[0][sum]代表相差0，dp[0][2$\\ast$sum]代表相差sum。 dp[i][j] = dp[i-1][j] 表示我不用第i块砖dp[i][j] = max(dp[i-1][j+h] + h, dp[i][j]) 表示我把砖放在A堆。dp[i][j] = max(dp[i-1][j-h], dp[i][j]) 表示我把砖放在B堆。 以上语句摘抄与上述评论中的内容，唯一不同的是，我dp[i][j]表示B-A的值为j时，A的最大长度。 我认为这种思路更有说服性，简单明了，不会错失所有情况。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main(int argc, char *argv[])&#123; int n; cin&gt;&gt;n; vector&lt;int&gt; a(n + 1); vector&lt;int&gt; sum(n+1); sum[0] = 0; for (int i = 1; i &lt;= n; i++) &#123; cin&gt;&gt;a[i]; sum[i] = a[i] + sum[i - 1]; &#125; vector&lt; vector&lt;int&gt; &gt; dp(2, vector&lt;int&gt;(2 * sum[n] + 1, -1)); dp[0][sum[n]] = 0; for (int i = 1; i &lt;= n; i++) &#123; int value = a[i]; for (int j = sum[n] + sum[i]; j &gt;= sum[n] - sum[i]; j--) &#123; dp[i &amp; 1][j] = dp[ (i-1) &amp; 1][j]; if ((j + value) &lt;= (sum[n] + sum[i]) &amp;&amp; dp[ (i-1) &amp; 1][j + value] != -1) dp[i &amp; 1][j] = max(dp[i &amp; 1][j], dp[ (i-1) &amp; 1][j + value] + value); if ((j - value) &gt;= (sum[n] - sum[i]) &amp;&amp; dp[ (i-1) &amp; 1][j - value] != -1) dp[i &amp; 1][j] = max(dp[i &amp; 1][j], dp[ (i-1) &amp; 1][j - value]); &#125; &#125; if (dp[n &amp; 1][sum[n]] == 0) cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl; else cout&lt;&lt;dp[n &amp; 1][sum[n]]&lt;&lt;endl; return 0;&#125;","tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"},{"name":"网易","slug":"网易","permalink":"http://yoursite.com/tags/网易/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"}]},{"title":"小易记单词","date":"2017-07-07T09:44:00.000Z","path":"2017/07/07/rememberWord/","text":"题目链接：网易2017春招笔试真题编程题集合第十题 12时间限制：1秒空间限制：32768K 小易参与了一个记单词的小游戏。游戏开始系统提供了m个不同的单词，小易记忆一段时间之后需要在纸上写出他记住的单词。小易一共写出了n个他能记住的单词，如果小易写出的单词是在系统提供的，将获得这个单词长度的平方的分数。注意小易写出的单词可能重复，但是对于每个正确的单词只能计分一次。 输入描述: 输入数据包括三行： 第一行为两个整数n(1 ≤ n ≤ 50)和m(1 ≤ m ≤ 50)。以空格分隔 第二行为n个字符串，表示小易能记住的单词，以空格分隔，每个单词的长度小于等于50。 第三行为m个字符串，系统提供的单词，以空格分隔，每个单词的长度小于等于50。 输出描述: 输出一个整数表示小易能获得的分数 输入: 3 4apple orange strawberrstrawberry orange grapefruit watermelon 输出： 136 我的思路：起初我还想一个字符一个字符进行比较，遇到空格便是一个单词。 然后意识到，字符串也是可以比较的。 又遇到了不能重复，我就用了一个数组来表示答对的单词。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;#define N 50int main(int argc, char *argv[])&#123; string s1[N], s2[N], s3[N]; int sum = 0, score = 0; int m, n; cin&gt;&gt;m&gt;&gt;n; for (int i = 0; i &lt; m; i++) cin&gt;&gt;s1[i]; for (int i = 0; i &lt; n; i++) cin&gt;&gt;s2[i]; for (int i = 0; i &lt; m; i++) &#123; bool flag = false; for (int j = 0; j &lt; n ; j++) &#123; if (s1[i] == s2[j]) &#123; flag = true; break; &#125; &#125; if (flag) &#123; bool isIN = false; for (int k = 0; k &lt; sum; k++) &#123; if (s3[k] == s1[i]) &#123; isIN = true; break; &#125; &#125; if (!isIN) &#123; s3[sum++] = s1[i]; score += pow(s1[i].size(), 2); &#125; &#125; &#125; cout&lt;&lt;score&lt;&lt;endl; return 0;&#125; 结果是对的，我看了一下评论，看到一个人和我做的一样，看到他下面的评论，可以用vis标记系统单词已经被记住的。 我想到了工作安排那一道题，我好想也是这么做的，为什么就记不住呢？ 12345678910111213141516171819202122232425262728293031改进版：#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;#define N 50int main(int argc, char *argv[])&#123; string s1[N], s2[N]; int s[N] = &#123;0&#125;, score = 0; int m, n; cin&gt;&gt;m&gt;&gt;n; for (int i = 0; i &lt; m; i++) cin&gt;&gt;s1[i]; for (int i = 0; i &lt; n; i++) cin&gt;&gt;s2[i]; for (int i = 0; i &lt; m; i++) &#123; int j; for (j = 0; j &lt; n ; j++) &#123; if (s1[i] == s2[j]) &#123; if (!s[j]) &#123; score += pow(s1[i].size(), 2); s[j] = 1; &#125; break; &#125; &#125; &#125; cout&lt;&lt;score&lt;&lt;endl; return 0;&#125;","tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"},{"name":"网易","slug":"网易","permalink":"http://yoursite.com/tags/网易/"},{"name":"标记已用","slug":"标记已用","permalink":"http://yoursite.com/tags/标记已用/"}]},{"title":"涂棋盘","date":"2017-07-07T08:37:00.000Z","path":"2017/07/07/chessboard/","text":"题目链接：网易2017春招笔试真题编程题集合第九题 12时间限制：1秒空间限制：32768K 小易有一块n*n的棋盘，棋盘的每一个格子都为黑色或者白色，小易现在要用他喜欢的红色去涂画棋盘。小易会找出棋盘中某一列中拥有相同颜色的最大的区域去涂画，帮助小易算算他会涂画多少个棋格。 输入描述: 接下来的n行每行一个字符串表示第i行棋盘的颜色，’W’表示白色，’B’表示黑色 输出描述: 输出小易会涂画的区域大小 输入: 3BWWBBBBWB 输出： 3 我的思路：一列一列的找，找出最长连续的即可。一开始，我想一列中的白色最多和黑色最多很开，但是很快就否定了，既然找最大，就不用分的那么细了。直接上代码吧。12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;#define N 50int main(int argc, char *argv[])&#123; string s[N]; int n, max = 0; cin&gt;&gt;n; for (int i = 0; i &lt; n; i++) cin&gt;&gt;s[i]; for (int j = 0; j &lt; n; j++) &#123; int i = 0; char c = s[i][j]; while (i &lt; n) &#123; int k, num; for (k = i; k &lt; n &amp;&amp; s[k][j] == c; k++); num = k - i; if (num &gt; max) max = num; if (k == n)// 不然容易出现堆溢出，因为会调用 c = s[n][j] break; c = s[k][j]; i = k; &#125; &#125; cout&lt;&lt;max&lt;&lt;endl; return 0;&#125; 看了大神的代码之后，才发现我写的虽然对，但是有点绕。123456789101112131415161718192021222324252627改进代码：#include &lt;iostream&gt;using namespace std;#define N 50int main(int argc, char *argv[])&#123; string s[N]; int n, max = 1; cin&gt;&gt;n; for (int i = 0; i &lt; n; i++) cin&gt;&gt;s[i]; for (int j = 0; j &lt; n; j++) &#123; int num = 1; for (int i = 0; i &lt; n - 1; i++) &#123; if (s[i][j] == s[i+1][j]) &#123; num++; if (num &gt; max) max = num; &#125; else &#123; num = 1; &#125; &#125; &#125; cout&lt;&lt;max&lt;&lt;endl; return 0;&#125;","tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"},{"name":"网易","slug":"网易","permalink":"http://yoursite.com/tags/网易/"},{"name":"连续区域长度","slug":"连续区域长度","permalink":"http://yoursite.com/tags/连续区域长度/"}]},{"title":"奇怪的表达式","date":"2017-07-07T07:20:00.000Z","path":"2017/07/07/expression/","text":"题目链接：网易2017春招笔试真题编程题集合第八题 12时间限制：1秒空间限制：32768K 常规的表达式求值，我们都会根据计算的优先级来计算。比如$\\ast$ /的优先级就高于+-。但是小易所生活的世界的表达式规则很简单，从左往右依次计算即可，而且小易所在的世界没有除法，意味着表达式中没有/，只有(+, - 和 $\\ast$)。现在给出一个表达式，需要你帮忙计算出小易所在的世界这个表达式的值为多少 输入描述: 输入为一行字符串，即一个表达式。其中运算符只有-,+,*。参与计算的数字只有0~9.保证表达式都是合法的，排列规则如样例所示。 输出描述: 输出一个数，即表达式的值 输入: 3+5*7 输出： 56 我的思路：首先我想到了栈，想到了运算优先级，想到了中缀表达式是不能直接算出结果的，必须通过转化为后缀表达式，然后通过后缀表达式来进行计算。 既然这道题目不考虑优先级，那就好算了。首先把第一个元素压入栈，然后遇到符号，就把栈里面的一个元素和符号后面的那个元素进行计算，然后出栈，把结果压入栈，依次类推。 我考虑到万一数字不是一位数怎么办？所以就首先写了一个把数字找出来，把符号找出来，然后就好写了。123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;int main(int argc, char *argv[])&#123; string s = &quot;1+10*11&quot;; int temp = 0; for (int i = 0; i &lt; s.size(); i++) &#123; if (s[i] == &apos; &apos;) continue; else if (&apos;0&apos; &lt;= s[i] &amp;&amp; s[i] &lt;= &apos;9&apos;) &#123; int c = s[i] - &apos;0&apos;; temp = temp * 10 + c; &#125; else if (s[i] ==&apos;+&apos; || s[i] ==&apos;-&apos; || s[i] ==&apos;*&apos;) &#123; cout&lt;&lt;temp&lt;&lt;endl; cout&lt;&lt;s[i]&lt;&lt;endl; temp = 0; &#125; &#125; cout&lt;&lt;temp&lt;&lt;endl; return 0;&#125; 数字和符号都找好了，我需要知道第一个数字，和遇到符号之后，我还要知道符号后面的数字，我就把它写成了个函数。1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;int main(int argc, char *argv[])&#123; //得到一个数字，k是从第几个位置开始 int getIntValue(string s, int k); string s; cin&gt;&gt;s; int b = getIntValue(s, 0); for(int i = 0; i &lt; s.size(); i++) &#123; if (s[i] ==&apos;+&apos; || s[i] ==&apos;-&apos; || s[i] ==&apos;*&apos;) &#123; int temp = getIntValue(s, i + 1); if (s[i] ==&apos;+&apos;) &#123; b = b + temp; &#125; else if (s[i] ==&apos;-&apos;) &#123; b = b - temp; &#125; else if (s[i] ==&apos;*&apos;) &#123; b = b * temp; &#125; &#125; &#125; cout&lt;&lt;b&lt;&lt;endl; return 0;&#125;int getIntValue(string s, int k) &#123; int temp = 0; for (int i = k; i &lt; s.size(); i++) &#123; if (s[i] == &apos; &apos;) continue; else if (&apos;0&apos; &lt;= s[i] &amp;&amp; s[i] &lt;= &apos;9&apos;) &#123; int c = s[i] - &apos;0&apos;; temp = temp * 10 + c; &#125; else if (s[i] ==&apos;+&apos; || s[i] ==&apos;-&apos; || s[i] ==&apos;*&apos;) &#123; break; &#125; &#125; return temp;&#125; 后来看了一下评论，发现数字只是0~9，根本不会出现两位以上的数字，那这就更好办了，函数也不需要了。 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;int main(int argc, char *argv[])&#123; string s; cin&gt;&gt;s; int b = s[0] - &apos;0&apos;; for(int i = 0; i &lt; s.size(); i++) &#123; if (s[i] ==&apos;+&apos; || s[i] ==&apos;-&apos; || s[i] ==&apos;*&apos;) &#123; int temp = s[i + 1] - &apos;0&apos;; if (s[i] ==&apos;+&apos;) &#123; b = b + temp; &#125; else if (s[i] ==&apos;-&apos;) &#123; b = b - temp; &#125; else if (s[i] ==&apos;*&apos;) &#123; b = b * temp; &#125; &#125; &#125; cout&lt;&lt;b&lt;&lt;endl; return 0;&#125;","tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"},{"name":"网易","slug":"网易","permalink":"http://yoursite.com/tags/网易/"},{"name":"栈","slug":"栈","permalink":"http://yoursite.com/tags/栈/"}]},{"title":"集合","date":"2017-07-04T04:03:00.000Z","path":"2017/07/04/collection/","text":"题目链接：网易2017春招笔试真题编程题集合第七题 12时间限制：1秒空间限制：32768K 小易最近在数学课上学习到了集合的概念,集合有三个特征：1.确定性 2.互异性 3.无序性.小易的老师给了小易这样一个集合：S = { p/q | w ≤ p ≤ x, y ≤ q ≤ z }需要根据给定的w，x，y，z,求出集合中一共有多少个元素。小易才学习了集合还解决不了这个复杂的问题,需要你来帮助他。 输入描述: 输出集合中元素的个数 输出描述: 输出魔力手环使用k次之后的状态，以空格分隔，行末无空格。 输入: 1 10 1 1 输出： 10 我的思路：如果：$\\frac p q = \\frac m n$， 那么：$p \\times n = q \\times m$总的来说,依旧是去除重复这一核心思路。123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;#define N 10000 int main(int argc, char *argv[])&#123; int a[2][N]; int w, x, y, z; cin&gt;&gt;w&gt;&gt;x&gt;&gt;y&gt;&gt;z; a[0][0] = w; a[1][0] = y; int sum = 1; for (int i = w; i &lt;= x; i++) &#123; for (int j = y; j &lt;= z; j++) &#123; bool flag = true; for (int k = 0; k &lt; sum; k++) &#123; if (a[0][k] * j == a[1][k] * i) &#123; flag = false; break; &#125; &#125; if (flag) &#123; a[0][sum] = i; a[1][sum] = j; sum++; &#125; &#125; &#125; cout&lt;&lt;sum&lt;&lt;endl; return 0;&#125;","tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"},{"name":"网易","slug":"网易","permalink":"http://yoursite.com/tags/网易/"},{"name":"去除重复","slug":"去除重复","permalink":"http://yoursite.com/tags/去除重复/"}]},{"title":"工作安排","date":"2017-07-03T10:49:00.000Z","path":"2017/07/03/workplan/","text":"题目链接：网易2017春招笔试真题编程题集合第六题 12时间限制：1秒空间限制：32768K 现在有n位工程师和6项工作(编号为0至5)，现在给出每个人能够胜任的工作序号表(用一个字符串表示，比如：045，表示某位工程师能够胜任0号，4号，5号工作)。现在需要进行工作安排，每位工程师只能被安排到自己能够胜任的工作当中去，两位工程师不能安排到同一项工作当中去。如果两种工作安排中有一个人被安排在的工作序号不一样就被视为不同的工作安排，现在需要计算出有多少种不同工作安排计划。 输入描述: 输入数据有n+1行：第一行为工程师人数n(1 ≤ n ≤ 6)接下来的n行，每行一个字符串表示第i(1 ≤ i ≤ n)个人能够胜任的工作(字符串不一定等长的) 输出描述: 输出一个整数，表示有多少种不同的工作安排方案 输入例子: 6012345012345012345012345012345012345 输出例子： 720 我的思路：其实，我理解的意思是，所有的工作都要做完，根据上面的例子，所有的情况应该是$6^6$，但是上面的答案是$6!$，我就理解成了，所有的工作都要做完，并且所有的人都要参与进去。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/*这道题目题意有点模糊我理解的意思：所有的工作都要做完，而且所有的成员都要参与进去下面的代码就是实现上述功能 */#include &lt;iostream&gt;using namespace std;#include&lt;string.h&gt;#define N 6int sum = 0;int b[N];int main(int argc, char *argv[])&#123; void fun(string a[], int m, int n, int k); bool judge(int n, int k); string a[6] = &#123; &quot;012345&quot;, &quot;012345&quot;, &quot;012345&quot;, &quot;012345&quot;, &quot;012345&quot;, &quot;012345&quot; &#125;; int n = 6; int k = 6; fun(a, 0, n, k); cout&lt;&lt;sum&lt;&lt;endl; return 0;&#125;//确保所有的人都参与 bool judge(int n, int k) &#123; for (int i = 0; i &lt; k; i++) &#123; int j; for (j = 0; j &lt; n; j++)&#123; if (b[j] == i) break; &#125; if (j == n) return false; &#125; return true;&#125;//回溯求解 void fun(string a[], int m, int n, int k) &#123; if (m == n &amp;&amp; judge(n, k)) sum++; else &#123; for (int i = 0; i &lt; k; i++) &#123; for (int j = 0; j &lt; a[i].size(); j++) &#123; if((int)(a[i][j] - &apos;0&apos;) == m)&#123; b[m] = i; fun(a, m+1, n, k); &#125; &#125; &#125; &#125;&#125; 12345结果：运行错误，没有通过所有实例后来看了一下评论，原来意思理解错了。真正意思：①：每个人做一件事情，且唯一②：不用把所有的工作做完 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/*这道题目题意有点模糊其实意思是：1、所有工程师都必须有事可做，且只能做一件事情。2、不必所有事都要做。 下面的代码就是实现上述功能 */#include &lt;iostream&gt;using namespace std;#include&lt;string.h&gt;#define N 6int sum = 0;char b[N];int main(int argc, char *argv[])&#123; void fun(string a[], int m, int k); bool judge(int n); string a[N]; int k; cin&gt;&gt;k; for(int i = 0; i &lt; k; i++) cin&gt;&gt;a[i]; fun(a, 0, k); cout&lt;&lt;sum&lt;&lt;endl; return 0;&#125;//判断有没有人做相同的工作 bool judge(int n) &#123; for (int i = 0; i &lt; n - 1; i++) &#123; for (int j = i + 1; j &lt; n; j++) &#123; if (b[i] == b[j]) return false; &#125; &#125; return true;&#125;//回溯法求解 void fun(string a[], int m, int k) &#123; if (m == k) &#123; sum++; &#125; else &#123; for (int j = 0; j &lt; a[m].size(); j++) &#123; b[m] = a[m][j]; if (judge(m+1)) fun(a, m + 1, k); &#125; &#125;&#125; 12我是用了个双重循环来进行判断。看到其他的评论里，有人是用一个一维数组来记录这份工作是否被做，这样做，感觉效率更高一些。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*这道题目题意有点模糊其实意思是：1、所有工程师都必须有事可做，且只能做一件事情。2、不必所有事都要做。 下面的代码就是实现上述功能 */#include &lt;iostream&gt;using namespace std;#include&lt;string.h&gt;#define N 6int sum = 0;int b[N] = &#123;0&#125;;int main(int argc, char *argv[])&#123; void fun(string a[], int m, int k); string a[N]; int k; cin&gt;&gt;k; for(int i = 0; i &lt; k; i++) cin&gt;&gt;a[i]; fun(a, 0, k); cout&lt;&lt;sum&lt;&lt;endl; return 0;&#125;//回溯法求解 void fun(string a[], int m, int k) &#123; if (m == k) &#123; sum++; &#125; else &#123; for (int j = 0; j &lt; a[m].size(); j++) &#123; int temp = (int)(a[m][j] - &apos;0&apos;); if (b[temp] == 0) &#123; b[temp] = 1; fun(a, m + 1, k); b[temp] = 0; &#125; &#125; &#125;&#125;","tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"},{"name":"网易","slug":"网易","permalink":"http://yoursite.com/tags/网易/"},{"name":"回溯法","slug":"回溯法","permalink":"http://yoursite.com/tags/回溯法/"}]},{"title":"魔力手环","date":"2017-07-02T04:48:00.000Z","path":"2017/07/02/magicBracelet/","text":"题目链接：网易2017春招笔试真题编程题集合第五题 12时间限制：1秒空间限制：32768K 小易拥有一个拥有魔力的手环上面有n个数字(构成一个环),当这个魔力手环每次使用魔力的时候就会发生一种奇特的变化：每个数字会变成自己跟后面一个数字的和(最后一个数字的后面一个数字是第一个),一旦某个位置的数字大于等于100就马上对100取模(比如某个位置变为103,就会自动变为3).现在给出这个魔力手环的构成，请你计算出使用k次魔力之后魔力手环的状态。 输入描述: 输入数据包括两行：第一行为两个整数n(2 ≤ n ≤ 50)和k(1 ≤ k ≤ 2000000000),以空格分隔第二行为魔力手环初始的n个数，以空格分隔。范围都在0至99. 输出描述: 输出魔力手环使用k次之后的状态，以空格分隔，行末无空格。 输入: 3 21 2 3 输出： 8 9 7 我的思路：当我拿到题目的那一刻，我在想，有这么简单，一定在逗我，我猜我写完之后，一定会超时。试试吧。1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;#define MAX 50int main(int argc, char *argv[])&#123; int k, n; int a[MAX]; cin&gt;&gt;n&gt;&gt;k; for (int i = 0; i &lt; n; i++) cin&gt;&gt;a[i]; for (int i = 0; i &lt; k; i++) &#123; int temp = a[0]; for (int j = 0;j &lt; n - 1; j++) &#123; a[j] += a[j+1]; if (a[j] &gt;= 100) a[j] %= 100; &#125; a[n-1] += temp; if (a[n-1] &gt;= 100) a[n-1] %= 100; &#125; for (int i = 0; i &lt; n; i++) &#123; if (i == 0) cout&lt;&lt;a[i]; else cout&lt;&lt;&apos; &apos;&lt;&lt;a[i]; &#125; cout&lt;&lt;endl; return 0;&#125; 12345结果：果然运行超时。我是自己想呢？还是直接看评论？自己想了一小会，算了，不想了，直接看评论吧。还好我及时看了评论，不然我这辈子都想不出来。 快速幂取余：参考内容：快速幂取余算法矩阵快速幂的应用题 – 魔力手环 核心公式：$a^b$ mod $c$ = $(a^{2^\\frac b2})$ mod $c$，b 是偶数$a^b$ mod $c$ = $(a \\ast a^{2^\\frac b2})$ mod $c$，b 是奇数 例子演示：$a^{10} = a^{2^5} = a^2 \\ast a^{4^2} = a^2 \\ast a^{8^1} = a^2 \\ast a^8 \\ast a^{16^0} = a^2 \\ast a^8$$a^7 = a \\ast a^{2^3} = a \\ast a^2 \\ast a^{4^1} = a \\ast a^2 \\ast a^4 \\ast a^{8^0} = a \\ast a^2 \\ast a^4$ 核心代码一：123456789101112int quickMod(int a, int b, int c) &#123; int ans = 1; while (b) &#123; if (b % 2 == 1) ans = (ans * a) % c; b /= 2; a = (a * a) % c; &#125; return ans; &#125; 例子演示：$a^{10}$ a b ans $a$ 10 1 $a^2$ 5 $1 \\ast a^2$ $a^4$ 2 $1 \\ast a^2$ $a^8$ 1 $1 \\ast a^2 \\ast a^8$ $a^{16}$ 0 结束 $a^7$ a b ans $a$ 7 $1 \\ast a$ $a^2$ 3 $1 \\ast a \\ast a^2$ $a^4$ 1 $1 \\ast a \\ast a^2 \\ast a^4$ $a^8$ 0 结束 10 的二进制为：1010$a^{10} = a^2 \\ast a^8$7 的二进制为：111$a^7 = a \\ast a^2 \\ast a^4$1有没有发现规律？凡是为1的就乘以a^n(n为（1、2、4、8……）)。 核心代码二：123456789101112int quickMod(int a, int b, int n) &#123; int ans = 1; while (b) &#123; if (b &amp; 0x1) //如果二进制位为1 ans = ans * a % n; a = a * a % n; b &gt;&gt;= 1 //b向又移1位 &#125; return ans; &#125; 例子演示： $a^{10}$ a b ans $a$ 1010 1 $a^2$ 0101 $1 \\ast a^2$ $a^4$ 0010 $1 \\ast a^2$ $a^8$ 0001 $1 \\ast a^2 \\ast a^8$ $a^{16}$ 0000 结束 $a^7$ a b ans $a$ 111 $1 \\ast a$ $a^2$ 011 $1 \\ast a \\ast a^2$ $a^4$ 001 $1 \\ast a \\ast a^2 \\ast a^4$ $a^8$ 000 结束 大神思路： 大神说：如输入A = [[1, 2, 3]], k = 2。我们可以构造一个这样的矩阵B[[1, 0, 1], [1, 1, 0], [0, 1, 1]]，使得$A*B^k$相当于A转换k次后的样子。于是原问题就变成求矩阵快速幂。快速幂取余中，$a^k$ % c = $(a \\% c)^k \\% c$。 1实际上，把ans当做矩阵A，a当做矩阵B，当然矩阵B的生成也是有规律的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;using namespace std;#define N 50int ans[1][N]; int a[N][N] = &#123;0&#125;;int main(int argc, char *argv[])&#123; //两个矩阵相乘，a1和a2是两个矩阵，m和n是最终矩阵的行数和列数 //row为第一个数组的列数或者第二个数组的行数 //type为0：代表 a = a*a;type为1：代表ans = ans*a void Core(int a1[N][N], int a2[N][N], int m, int n, int row, int type); void power(int k, int n);//快速幂取余，k代表次数，n代表个数 int n, k; cin&gt;&gt;n&gt;&gt;k; //输入矩阵ans for (int i = 0; i &lt; n; i++) cin&gt;&gt;ans[0][i]; //生成矩阵a for (int i = 0; i &lt; n; i++) &#123; a[i][i] = 1; a[(i+1) % n][i] = 1; &#125; //计算矩阵快速幂 power(k, n); //输出矩阵ans for (int i = 0; i &lt; n; i++) &#123; if (i == 0) cout&lt;&lt;ans[0][i]; else cout&lt;&lt;&apos; &apos;&lt;&lt;ans[0][i]; &#125; cout&lt;&lt;endl; return 0;&#125;void Core(int a1[N][N], int a2[N][N], int m, int n, int row, int type) &#123; int temp[N][N] = &#123;0&#125;; for(int i = 0; i &lt; m; i++) &#123; //两个矩阵相乘，保存到temp中 for (int j = 0; j &lt; n; j++) &#123; for (int k = 0; k &lt; row; k++) &#123; if(a1[i][k] == 0 || a2[k][j] == 0) //剪枝 continue; temp[i][j] += a1[i][k] * a2[k][j]; &#125; if (temp[i][j] &gt;= 100) //100取余运算 temp[i][j] %= 100; &#125; &#125; if (type == 1) &#123; for(int i = 0; i &lt; m; i++) //给ans赋值 for (int j = 0; j &lt; n; j++) ans[i][j] = temp[i][j]; &#125; else if (type == 0) &#123; for(int i = 0; i &lt; m; i++) //给a赋值 for (int j = 0; j &lt; n; j++) a[i][j] = temp[i][j]; &#125;&#125;void power(int k, int n) &#123; while(k) &#123; if (k &amp; 0x1 == 1) Core(ans, a, 1, n, n, 1); Core(a, a, n, n, n, 0); k &gt;&gt;= 1; &#125;&#125;","tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"},{"name":"网易","slug":"网易","permalink":"http://yoursite.com/tags/网易/"},{"name":"快速幂取余","slug":"快速幂取余","permalink":"http://yoursite.com/tags/快速幂取余/"},{"name":"矩阵相乘","slug":"矩阵相乘","permalink":"http://yoursite.com/tags/矩阵相乘/"}]},{"title":"消除重复元素","date":"2017-06-29T14:19:00.000Z","path":"2017/06/29/distinct/","text":"题目链接：网易2017春招笔试真题编程题集合第四题 12时间限制：1秒空间限制：32768K 小易有一个长度为n序列，小易想移除掉里面的重复元素，但是小易想是对于每种元素保留最后出现的那个。小易遇到了困难,希望你来帮助他。 输入描述: 输入包括两行：第一行为序列长度n(1 ≤ n ≤ 50)第二行为n个数sequence[i] (1 ≤ sequence[i] ≤ 1000),以空格分隔 输出描述: 输出消除重复元素之后的序列，以空格分隔，行末无空格 输入例子: 9100 100 100 99 99 99 100 100 100 输出例子： 99 100 我的思路：其实去重复元素的例子以前做过，但是以前做的都是保存重复元素的第一个元素。 用一个二维数组记录重复元素和重复元素的最后一个元素的位置，然后递增排序，就可以得到结果。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;using namespace std;#define MAX 50 int main(int argc, char *argv[])&#123; int a[MAX], b[2][MAX], count = 0;// b数组用来记录除重数组， //第一行是元素，第二行是位置 int n; cin&gt;&gt;n; for(int i = 0; i &lt; n; i++) cin&gt;&gt;a[i]; b[0][0] = a[0]; b[1][0] = 0; count++; int i, j; for (i = 1; i &lt; n; i++) &#123; for (j = 0; j &lt; count; j++) &#123; // 判断是否是重复元素 if(a[i] == b[0][j]) &#123; b[1][j] = i; // 覆盖位置 break; &#125; &#125; if (j == count) &#123;// 不是重复元素 b[0][count] = a[i]; //插入数据 b[1][count] = i; //保存位置 count++; &#125; &#125; //排序得到结果 for (int i = 0; i &lt; count-1; i++) &#123; int temp = i; for (int j = i+1; j &lt; count; j++) &#123; if (b[1][j] &lt; b[1][temp]) temp = j; &#125; if (temp != i) &#123; int c = b[0][i]; b[0][i] = b[0][temp]; b[0][temp] = c; c = b[1][i]; b[1][i] = b[1][temp]; b[1][temp] = c; &#125; &#125; for (int i = 0; i &lt; count; i++) &#123; if(i == 0) cout&lt;&lt;b[0][i]; else cout&lt;&lt;&apos; &apos;&lt;&lt;b[0][i]; &#125; cout&lt;&lt;endl; return 0;&#125; 1结果虽然正确，但是感觉代码量还是有点庞大。 大神的思路： ①：倒着去除重复元素，那么保留的就是正序的最后一个②：然后倒着输出就是结果 也许这样说不容易理解，看了代码，就会立马明白。 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;#define MAX 50 int main(int argc, char *argv[])&#123; int a[MAX], b[MAX], count = 0; int n; cin&gt;&gt;n; for(int i = 0; i &lt; n; i++) cin&gt;&gt;a[i]; b[0] = a[n-1]; count++; int i, j; for (i = n-2; i &gt;= 0; i--) &#123; // 倒着去除重复元素 for (j = 0; j &lt; count; j++) &#123; if(a[i] == b[j]) break; &#125; if (j == count) &#123; b[count++] = a[i]; &#125; &#125; for (int i = count-1; i &gt;= 0; i--) &#123;// 倒着输出 if(i == count-1) cout&lt;&lt;b[i]; else cout&lt;&lt;&apos; &apos;&lt;&lt;b[i]; &#125; cout&lt;&lt;endl; return 0;&#125;","tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"},{"name":"网易","slug":"网易","permalink":"http://yoursite.com/tags/网易/"},{"name":"去除重复","slug":"去除重复","permalink":"http://yoursite.com/tags/去除重复/"}]},{"title":"调整队形","date":"2017-06-28T14:29:00.000Z","path":"2017/06/28/adjustOrder /","text":"题目链接：网易2017春招笔试真题编程题集合第三题 12时间限制：1秒空间限制：32768K 在幼儿园有n个小朋友排列为一个队伍，从左到右一个挨着一个编号为(0~n-1)。其中有一些是男生，有一些是女生，男生用’B’表示，女生用’G’表示。小朋友们都很顽皮，当一个男生挨着的是女生的时候就会发生矛盾。作为幼儿园的老师，你需要让男生挨着女生或者女生挨着男生的情况最少。你只能在原队形上进行调整，每次调整只能让相邻的两个小朋友交换位置，现在需要尽快完成队伍调整，你需要计算出最少需要调整多少次可以让上述情况最少。例如：GGBBG -&gt; GGBGB -&gt; GGGBB这样就使之前的两处男女相邻变为一处相邻，需要调整队形2次 输入描述: 输入数据包括一个长度为n且只包含G和B的字符串.n不超过50. 输出描述: 输出一个整数，表示最少需要的调整队伍的次数 输入例子: GGBBG 输出例子： 2 我的思路：①：如果G的个数大于B的个数，那么移动G；否则移动B②：满足①后，如果左边的个数大于右边的个数，则把G或B移动到左边；否则则把G或B移动到右边 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149我的代码：#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;using namespace std;#define MAX 50 int main(int argc, char *argv[])&#123; char arr[MAX]; void shift(char arr[], int m, int n);// 交换位置 bool judge(char arr[], int n);// 判断是否符合要求（男生和女生分开） cin&gt;&gt;arr; int n = strlen(arr), middle, sum = 0; if (judge(arr, n))&#123; cout&lt;&lt;0&lt;&lt;endl; return 0; &#125; int leftG, leftB, rightG, rightB; leftG = leftB = rightG = rightB = 0; if (n % 2 == 0) // 规定中间点 middle = n / 2 - 1; else middle = n / 2; int i,j; for(i = 0; i &lt;= middle; i++) &#123; // 计算左边的G和B的个数 if (arr[i] == &apos;G&apos;) leftG++; else if (arr[i] == &apos;B&apos;) leftB++; &#125; for(j = middle + 1; j &lt; n; j++) &#123; // 计算左边的G和B的个数 if (arr[j] == &apos;G&apos;) rightG++; else if (arr[j] == &apos;B&apos;) rightB++; &#125; if((leftG + rightG) &gt; (leftB + leftB)) &#123; // 如果G的个数大于B的个数 if(leftG &gt; rightG) &#123; // 如果左边G的个数大于右边G的个数 for (i = 0; i &lt; n; i++) &#123; // 把所有的G移动到左边 // 逐个寻找右边的G，把它移到左边B的位置 if (judge(arr, n))&#123; cout&lt;&lt;sum&lt;&lt;endl; break; &#125; if(arr[i] == &apos;B&apos;) &#123; // 找到B的位置 for (j = i + 1; j &lt; n; j++)&#123;// 找到G的位置 if (arr[j] == &apos;G&apos;) &#123; shift(arr, i, j);// 把G移动到左边 sum += abs(i - j);// 累加交换次数 break; &#125; &#125; &#125; &#125; &#125; else &#123;// 如果左边G的个数小于右边G的个数 for (i = n-1; i &gt;= 0; i--) &#123;// 把所有的G移动到右边 // 逐个寻找左边的G，把它移到右边B的位置 if (judge(arr, n))&#123;// 首先判断是否符合队列要求 cout&lt;&lt;sum&lt;&lt;endl; break; &#125; if(arr[i] == &apos;B&apos;) &#123;// 找到B的位置 for (j = i - 1; j &gt;= 0; j--)&#123; if (arr[j] == &apos;G&apos;) &#123; //找到G的位置 shift(arr, i, j);// 把G移动到右边 sum += abs(i - j);// 累加交换次数 break; &#125; &#125; &#125; &#125; &#125; &#125; else &#123;// 如果B的个数大于G的个数，和上面类似的道理。 if(leftB &gt; rightB) &#123; for (i = 0; i &lt; n; i++) &#123; if (judge(arr, n))&#123; cout&lt;&lt;sum&lt;&lt;endl; break; &#125; if(arr[i] == &apos;G&apos;) &#123; for (j = i + 1; j &lt; n; j++)&#123; if (arr[j] == &apos;B&apos;) &#123; shift(arr, i, j); sum += abs(i - j); break; &#125; &#125; &#125; &#125; &#125; else &#123; for (i = n-1; i &gt;= 0; i--) &#123; if (judge(arr, n))&#123; cout&lt;&lt;sum&lt;&lt;endl; break; &#125; if(arr[i] == &apos;G&apos;) &#123; for (j = i - 1; j &gt;= 0; j--)&#123; if (arr[j] == &apos;B&apos;) &#123; shift(arr, i, j); sum += abs(i - j); break; &#125; &#125; &#125; &#125; &#125; &#125; return 0;&#125;void shift(char arr[], int m, int n) &#123; if (m &lt; n) &#123; char c = arr[n]; for (int i = n; i &gt; m; i--) arr[i] = arr[i-1]; arr[m] = c; &#125; else &#123; char c = arr[n]; for (int i = n; i &lt; m; i++) arr[i] = arr[i+1]; arr[m] = c; &#125; &#125;bool judge(char arr[], int n) &#123; int i, j; for(i = 0; i &lt; n-1 &amp;&amp; arr[i]==arr[i+1]; i++); if(i == n-1) return true; for(j = i+1; j &lt; n-1 &amp;&amp; arr[j]==arr[j+1]; j++); if(j == n-1) return true; else return false;&#125; 1结果虽然对了，但是我内心是崩溃的，有这么麻烦吗？算了，还是看看大神们是怎么做的。 大神操作： 大神说： 最终目标是将男孩移到最左边，或者将女孩移到最左边。 如果有B个男孩，则移到最左边的index分别为：0,1,2…B-1,所以所有index的和为（B-1）*B/2。一次遍历，计算目前男孩所在的index的和为sumB，则sumB减去上面的和就是所求的结果。 因此只要一次遍历，计算男孩所在的男孩的个数和男孩所在的index的和，求之差就行了。女孩同理。 最后求最小值。 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main(int argc, char *argv[])&#123; string s; cin&gt;&gt;s; int n = s.size(); int gNum, bNum, gSum, bSum; gNum = bNum = gSum = bSum = 0; for (int i = 0; i &lt; n; i ++) &#123; if (s[i] == &apos;G&apos;)&#123; gNum++; gSum += i; &#125; else &#123; bNum++; bSum += i; &#125; &#125; int ret1 = bSum - (bNum - 1) * bNum / 2; int ret2 = gSum - (gNum - 1) * gNum / 2; cout&lt;&lt;min(ret1, ret2)&lt;&lt;endl; return 0;&#125;","tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"},{"name":"网易","slug":"网易","permalink":"http://yoursite.com/tags/网易/"}]},{"title":"赶去公司","date":"2017-06-27T11:15:00.000Z","path":"2017/06/27/goToCompany/","text":"题目链接：网易2017春招笔试真题编程题集合第二题 12时间限制：1秒空间限制：32768K 终于到周末啦！小易走在市区的街道上准备找朋友聚会，突然服务器发来警报,小易需要立即回公司修复这个紧急bug。假设市区是一个无限大的区域，每条街道假设坐标是(X，Y)，小易当前在(0，0)街道，办公室在(gx,gy)街道上。小易周围有多个出租车打车点，小易赶去办公室有两种选择，一种就是走路去公司，另外一种就是走到一个出租车打车点，然后从打车点的位置坐出租车去公司。每次移动到相邻的街道(横向或者纵向)走路将会花费walkTime时间，打车将花费taxiTime时间。小易需要尽快赶到公司去，现在小易想知道他最快需要花费多少时间去公司。 输入描述： 输入数据包括五行: 第一行为周围出租车打车点的个数n(1 ≤ n ≤ 50) 第二行为每个出租车打车点的横坐标tX[i] (-10000 ≤ tX[i] ≤ 10000) 第三行为每个出租车打车点的纵坐标tY[i] (-10000 ≤ tY[i] ≤ 10000) 第四行为办公室坐标gx,gy(-10000 ≤ gx,gy ≤ 10000),以空格分隔 第五行为走路时间walkTime(1 ≤ walkTime ≤ 1000)和taxiTime(1 ≤ taxiTime ≤ 1000),以空格分隔 输出描述： 输出一个整数表示，小易最快能赶到办公室的时间 输入例子: 2-2 -20 -2-4 -215 3 输出例子: 42 我的思路:根据输入的例子画了一个坐标。①：起点到终点的距离是一定的，出租车花的时间比走路时间少，找出离起点最近的出租车坐标不就得了。1结论：walkTime有可能小于taxiTime的 ②：既然这样的话，分两种情况呗，walkTime &lt; taxiTime, 找出离起点最远的出租车坐标；walkTime &gt; taxiTime,找出离起点最近的出租车坐标；1结论：我是真蠢，当walkTime &lt; taxiTime时，直接走路就可以了，打的干嘛。 ③：那就这样分情况，walkTime &lt; taxiTime, 直接走路；walkTime &gt; taxiTime,找出离起点最近的出租车坐标；1结论：即使walkTime &gt; taxiTime, 如果出租车离起点很远的话，那也是不合算的。所以说走路到公司这种情况是一定要算的，那出租车那种情况怎么得到呢？ ④：起点和终点会构成一个长方形，出租车可能会在这个长方形，也有可能不在这个长方形中。要不分两种情况，一种是在长方形的出租车，另一种是长方形外的出租车。如果存在长方形内的出租车，那找长方形内最近的出租车一定是花时间最少的；如果不存在，那就找长方形外的出租车的最近点，然后在和走路的比较。123456789结论：卧槽，好麻烦。这样做应该可以做出来，但是也太绕了吧。后来我没有忍住，看了一下别人提交的代码，发现好少，但是具体思路没有看到。我就在想，是不是有别的思路呢？后来又仔细审了一下题目：一种就是走路去公司，另外一种就是走到一个出租车打车点，然后从打车点的位置坐出租车去公司。我想到了，这不就是两种情况吗？第一种是走路，第二种是找出租车然后再到公司。把第二种所有的情况的时间都算出来，不用纠结找最远的出租车还是最近的出租车，把起点到出租车再到公司的总时间算出来即可，然后找出最优解。第二种最优解再和第一种比较，最终得到结果。 反思：其实题目已经告诉了你解决方案，而我一直在纠结去哪里找出离起点最近的出租车坐标，关注的点歪了，而且歪的很离谱。 核心:这道题其实就是找出最小值而已。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354我的代码：#include &lt;iostream&gt;using namespace std;#include&lt;math.h&gt;#include&lt;limits.h&gt;#define taxiNumber 50int minvalue = INT_MAX;int main(int argc, char *argv[])&#123; int n, t[taxiNumber][taxiNumber]; int startPoint[1][2] = &#123;0,0&#125;, endPoint[1][2]; int walkTime, taxiTime; cin&gt;&gt;n; for(int i = 0; i &lt; n; i++) &#123; int tX; cin&gt;&gt;tX; t[0][i] = tX; &#125; for(int i = 0; i &lt; n; i++) &#123; int tY; cin&gt;&gt;tY; t[1][i] = tY; &#125; cin&gt;&gt;endPoint[0][0]&gt;&gt;endPoint[0][1]; cin&gt;&gt;walkTime&gt;&gt;taxiTime; int xDistance = abs(endPoint[0][0] - startPoint[0][0]); int yDistance = abs(endPoint[0][1] - startPoint[0][1]); int pureWalkTime = (xDistance + yDistance) * walkTime; for(int i = 0; i &lt; n; i++) &#123; xDistance = abs(t[0][i] - startPoint[0][0]); yDistance = abs(t[1][i] - startPoint[0][1]); int walk = (xDistance + yDistance) * walkTime; xDistance = abs(endPoint[0][0] - t[0][i]); yDistance = abs(endPoint[0][1] - t[1][i]); int taxi = (xDistance + yDistance) * taxiTime; int time = walk + taxi; if(time &lt; minvalue) minvalue = time; &#125; if(minvalue &lt; pureWalkTime) cout&lt;&lt;minvalue&lt;&lt;endl; else cout&lt;&lt;pureWalkTime&lt;&lt;endl; return 0;&#125; 1234567891011121314151617181920212223优秀代码：#include&lt;iostream&gt;#include&lt;cmath&gt; using namespace std; int n,tx[55],ty[55],gx,gy,walkTime,taxiTime;int main()&#123; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) cin&gt;&gt;tx[i]; for(int i=0;i&lt;n;i++) cin&gt;&gt;ty[i]; cin&gt;&gt;gx&gt;&gt;gy; cin&gt;&gt;walkTime&gt;&gt;taxiTime; int ans=(abs(gx-0)+abs(gy-0))*walkTime; for(int i=0;i&lt;n;i++)&#123; int res=(abs(tx[i]-0)+abs(ty[i]-0))*walkTime; res+=(abs(tx[i]-gx)+abs(ty[i]-gy))*taxiTime; ans=min(ans,res); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;","tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"},{"name":"网易","slug":"网易","permalink":"http://yoursite.com/tags/网易/"},{"name":"最小值","slug":"最小值","permalink":"http://yoursite.com/tags/最小值/"}]},{"title":"双核处理","date":"2017-06-26T07:07:00.000Z","path":"2017/06/26/dualCore/","text":"题目链接：网易2017春招笔试真题编程题集合第一题121. 时间限制：1秒2. 空间限制：32768K 一种双核CPU的两个核能够同时的处理任务，现在有n个已知数据量的任务需要交给CPU处理，假设已知CPU的每个核1秒可以处理1kb，每个核同时只能处理一项任务。n个任务可以按照任意顺序放入CPU进行处理，现在需要设计一个方案让CPU处理完这批任务所需的时间最少，求这个最小的时间。 输入描述: 输入包括两行：第一行为整数n(1 ≤ n ≤ 50)第二行为n个整数length[i] (1024 ≤ length[i] ≤ 4194304)，表示每个任务的长度为length[i]kb，每个数均为1024的倍数。 输出描述: 输出一个整数，表示最少需要处理的时间 输入例子: 5 3072 3072 7168 3072 1024 输出例子: 9216 参考内容： 动态规划解决01背包问题 “詆調壹點”的回答下面的“HelloHello233”的回答 我的思路：把这些任务分成两组，然后选择两组时间差最小的那一次分组，然后再取时间比较大的一组。 怎么才能把所有的分组找出来呢？头脑中就想出了“全排列”的概念。好像只是有点点联系，没有必要的联系。 于是我开始思考所有的分组，假如有5个任务，那么只考虑一组的任务分配，另一组就是剩下的任务数。所以第一组的分配为：1，2，第一组如果分配3和4的话，就重复了，再者说，$ C_5^1=C_5^4，C_5^2=C_5^3 $，所以第二组的分配对应为：4，3。假如一共有6个任务，那么第一组的分配为：1,2,3，第二组的分配为：5,4,3。所以我想到了以前做的概率题，经常用到的一个公式就是：$ C_m^n $。 假如有5个任务，那么所有的分配情况就是：$ C_5^1 和 C_5^2$。假如有6个任务，那么所有的分配情况就是：$ C_6^1、 C_6^2 和 C_6^3 $。所以就发现了规律了，假如有n个任务，那么所有的分组情况就是$C_n^1 C_n^2 C_n^3\\ldots C_n^\\frac n2$。 想了想，好想运算量非常非常大。算了，不管了，先把它搞出来吧。 组合部分：关于$ C_m^n $，我应该怎么把所有的情况找出来呢？我就想起来以前做的8皇后问题，用的回溯法，然后就开始试着写代码了。 假如组合为：$ C_6^3 $，结果是：123 124 125 126 134 135 136 145 146 156234 235 236 245 246 256345 346 356456 第一个数字的范围为：1~m-n+1，第二个数字的范围为：2~m-n+2，$ \\ldots$，第n-1个数字的范围为：n-1~m-1，第n个数字的范围为：n~m。 在排列组合的时候，第n个数字的最小值永远比前一个数字大1 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include&lt;limits.h&gt;using namespace std;#define MAX 51int combinArr[MAX];int main(int argc, char *argv[])&#123; void combine(int n, int m, int num); combinArr[0] = 0; combine(2,5,1); return 0;&#125;void combine(int n, int m, int num)&#123; if(num == n+1) &#123; for(int i = 1; i &lt;= n; i++) cout&lt;&lt;combinArr[i]; cout&lt;&lt;endl; &#125;else &#123; for(int i = combinArr[num-1]+1; i &lt;= (m-n+num); i++) &#123; combinArr[num] = i; combine(n, m, num+1); &#125; &#125;&#125; 双核处理 - 我的思路所有的排列组合都找出来了，找出一次组合之后，比如对于$ C_6^3 $，找出123之后，把123所对应的任务数相加，然后再让总任务数减去组合里面的任务数，然后就可以得出两者的差距，然后找出最小的差距即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include&lt;limits.h&gt;#include&lt;math.h&gt;using namespace std;#define MAX 51int a[MAX], b[MAX];// a用来记录组合的数组; b用来记录输入的任务数 int minvalue = INT_MAX;// 两组任务的差距 int out, sum=0;// out用来记录结果; sum用来记录任务的综合 int main(int argc, char *argv[])&#123; void pai(int n, int m, int num);// 组合部分;m和n分别为组合的上下角码;num为1 void compare(int a[], int n, int b[]);//找出差距最小的那一次组合;a为组合;n为a的个数;b为任务数据 a[0] = 0;//a[0]为1主要为了组合部分的第一个数字 int n ; cin&gt;&gt;n; for(int i = 1; i &lt;= n; i++)&#123; //录入任务数 并求出sum int sc; cin&gt;&gt;sc; b[i] = sc; sum += b[i]; &#125; for(int i =1; i &lt;= n/2; i++) // 根据任务的个数，来进行所需要的组合 pai(i, n, 1); cout&lt;&lt;out&lt;&lt;endl;// 输出结果 return 0;&#125;void pai(int n, int m, int num)&#123; void compare(int a[], int m, int b[]); if(num == n+1) &#123; compare(a,n,b); //每一次的组合就要进行一次比较 &#125;else &#123; for(int i = a[num-1]+1; i &lt;= (m-n+num); i++) &#123; a[num] = i; pai(n, m, num+1); &#125; &#125;&#125;void compare(int a[], int n, int b[])&#123; int i, j, num1=0, num2=0; for(i = 1; i&lt;= n; i++) //找出其中一组的任务数 num1 += b[a[i]]; num2 = sum - num1;//另一组的任务数 if(abs(num1-num2) &lt; minvalue)&#123; //更改最小的差距 minvalue = abs(num1-num2); if(num1 &gt; num2) //找出最终结果 out = num1; else out = num2; &#125; &#125; 1结果为：运行超时 01背包问题由于运行超时，然后看了别人的答案，就开始探索01背包问题。其实之前上课的时候学过这个内，当时可能在睡觉，或者在做别的事情，结果现在只是记住了这个标题。 问题描述： 有n 个物品，它们有各自的重量和价值，现有给定容量的背包，如何让背包里装入的物品具有最大的价值总和？ 核心概述： 设$V[i,j]$为前$i$个物品放到背包容量为$j$的背包中为最优解，设$v_i$为第$i$个物品的价值，$w_j$为第$i$个物品的重量。对于$V[i,j]$。(1) 第$i$个物品放不到背包里，则最优解为$V[i-1,j]$(2) 第$i$个物品可以放进背包里，则最优解为前$i-1$个物品的最优解$V[i-1,j-w_i]$与第$i$个物品价值的和，或者就是前$i-1$个物品的最优解，这里取两个中的最大值，即$V[i,j]=Max \\lbrace V[i-1,j-w_i]+v_i,V[i-1,j] \\rbrace$ 核心公式： $V[i,j] = V[i-1,j], w_i &gt; j$$V[i,j] = Max \\lbrace V[i-1,j-w_i]+v_i,V[i-1,j] \\rbrace , w_i \\leq j$当$j \\geq 0$时,$V[0,j]=0$;当$i \\geq 0$时，$V[i,0]$=0 情景再现： 背包容量：5 物品序号 重量 价值 1 2 12￥ 2 1 10￥ 3 3 20￥ 4 2 15￥ 自己根据公式推导一下，就会得出以下的表格。 $i/j$ 0 1 2 3 4 5 0 0 0 0 0 0 0 1 0 0 12 12 12 12 2 0 10 12 22 22 22 3 0 10 12 22 30 32 4 0 10 15 25 30 37 1234567优化前伪代码：for i=1...number for j=1...weight w[i] &gt; j v[i][j] = v[i-1][j] w[i] &lt;= j v[i][j] = max&#123; v[i-1, j-w[i]] + v[i], v[i-1,j] &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;using namespace std;#define weight 5 //背包容量 #define goodsNum 4 //物品个数 int main(int argc, char *argv[])&#123; int goods[goodsNum][2] = &#123;&#123;2, 12&#125;, &#123;1, 10&#125;, &#123;3, 20&#125;, &#123;2, 15&#125;&#125;;//物品的重量和价值 int a[goodsNum+1][weight+1];//记录V[i,j] for(int i=0;i&lt;=weight;i++) //当i&gt;=0时,V[0,i]=0; a[0][i]=0; for(int i=0;i&lt;=goodsNum;i++) //当i&gt;=0时,V[i,0]=0; a[i][0]=0; for(int i = 1;i &lt;= goodsNum; i++)&#123; for(int j = 1; j &lt;= weight; j++)&#123; int goodWeight = goods[i-1][0]; int goodValue = goods[i-1][1]; if(goodWeight &gt; j) &#123; a[i][j] = a[i-1][j]; &#125; else &#123; int putin = a[i-1][j-goodWeight] + goodValue; if(a[i-1][j] &lt; putin) a[i][j] = putin; else a[i][j] = a[i-1][j]; &#125; &#125; &#125; //输出V[i,j] for(int i =0;i&lt;=goodsNum;i++)&#123; for(int j=0; j&lt;=weight; j++) cout&lt;&lt;a[i][j]&lt;&lt;&apos; &apos;; cout&lt;&lt;endl; &#125; //找到背包里包含的物品 int find = weight; int hang = goodsNum; while(find &gt; 0)&#123; for(int i=hang;i&gt;=1;i--)&#123; if(a[i][find] != a[i-1][find])&#123; cout&lt;&lt;i&lt;&lt;&apos; &apos;; hang = i-1; find = find - goods[i-1][0]; break; &#125; &#125; &#125; cout&lt;&lt;endl;&#125; 背包优化： 其实，计算第$i$行的最优值时，只会用到第$i-1$行的数据，用不到$i-2$行的数据，所以可以把二维数组缩减为以为一维数组。但是这样的话，就找不到背包里所包含的物品。 核心公式： 为了混淆，这里用$B$代表一维数组，$B[j]$ 是容量为$j$的最优值，$w_i$代表第$i$个物品的容量，$v_i$代表第$i$个物品的价值。最优值$B[j]=Max \\lbrace B[j-w_i]+v_i,B[j] \\rbrace$ &nbsp;&nbsp;&nbsp;&nbsp;仅当$w_i &lt;= j$ 12345伪代码：for i=1...number for j=weitht...1 w[i] &lt;= j B[j] = max&#123; B[j-w[i]] + v[i], B[j] &#125; 1234注意：j是递减的，为什么呢？如果j是递增的话，会重复的放入某一件物品。自己写写一位数组的变化就知道了。 一维数组的变化( j递减 )： i B[5] B[4] B[3] B[2] B[1] B[0] i=1 12 12 12 12 0 0 i=2 22 22 22 12 10 0 i=3 32 30 22 12 10 0 i=4 37 30 25 15 10 0 有没有发现这个一维数组的每一行和二维数组的每一行是一样的。 一维数组的变化( j递增 )： i B[0] B[1] B[2] B[3] B[4] B[5] i=1 0 0 12 12 24 24 i=2 0 10 20 30 40 50 i=3 0 10 20 30 40 50 i=4 0 10 20 30 40 50 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;#define weight 5#define goodsNum 4int main(int argc, char *argv[])&#123; int goods[goodsNum][2] = &#123;&#123;2, 12&#125;, &#123;1, 10&#125;, &#123;3, 20&#125;, &#123;2, 15&#125;&#125;; int a[weight+1]; for(int i=0;i&lt;=weight;i++) a[i]=0; for(int i =0;i&lt;goodsNum;i++)&#123; for(int j=weight; j&gt;=1; j--)&#123; int goodWeight = goods[i][0]; int goodValue = goods[i][1]; int input = goodValue+a[j-goodWeight]; if(goodWeight &lt;= j &amp;&amp; input &gt; a[j]) a[j] = input; &#125; for(int i=weight;i&gt;=0;i--) cout&lt;&lt;a[i]&lt;&lt;&apos; &apos;; cout&lt;&lt;endl; &#125;&#125; 双核处理 - 01背包那人说，总任务数除以2就是背包的容量，然后每个任务数就是每个物品的容量。 一开始，我在疑惑：01背包问题是背包的容量大于装入物品的容量，但是这个双核处理问题是计算大于背包容量的最小容量，我一直在纠结这个问题，这个应该怎么转化为背包问题呢？ 后来，我想通了。任务分成两组，背包的容量是总任务除以2，其中一组大于背包容量，另外一组是小于背包容量，也有可能两组相等。我们求的是大于或等于背包容量的那一组。你只需要把其中一组计算出来，然后用总数一减不就得出来了。所以你计算小于背包容量的那一组，这样就可以转化为01背包问题了。 123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;#define MAX 102400#define NUM 50int main(int argc, char *argv[])&#123; int n, task[NUM], sum = 0; cin&gt;&gt;n; for(int i = 0; i &lt; n; i++) &#123; cin&gt;&gt;task[i]; task[i] /= 1024; sum += task[i]; &#125; int packWeight = sum / 2; int arr[MAX] = &#123;0&#125;; for(int i = 0; i &lt; n; i++) &#123; for (int j = packWeight; j &gt;= 1; j--) &#123; int taskWeight = task[i]; int input = taskWeight + arr[j-taskWeight]; if(taskWeight &lt;= j &amp;&amp; input &gt; arr[j]) arr[j] = input; &#125; &#125; int maxTaskTime = (sum - arr[packWeight]) * 1024; cout&lt;&lt;maxTaskTime&lt;&lt;endl; return 0;&#125;","tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"},{"name":"网易","slug":"网易","permalink":"http://yoursite.com/tags/网易/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"01背包","slug":"01背包","permalink":"http://yoursite.com/tags/01背包/"}]},{"title":"周杰伦音乐专辑封面","date":"2016-08-07T05:36:00.000Z","path":"2016/08/07/jay/","text":"周杰伦（Jay Chou），1979年1月18日出生于台湾省新北市，中国台湾流行乐男歌手、音乐人、演员、导演、编剧、监制、商人。 12342000年《Jay》;2001年《范特西》;2002年《八度空间》;2003年《叶惠美》;2004年《七里香》;2005年《十一月的肖邦》;2006年《依然范特西》;2007年《我很忙》;2008年《魔杰座》;2010年《跨时代》;2011年《惊叹号》;2012年《十二新作》;2014年《哎呦，不错哦》;2016年《周杰伦的床边故事》 《Jay》发行日期：2000-11-13 1234567891011专辑曲目： 1.可爱女人 2.完美主义 3.星晴 4.娘子 5.斗牛 6.黑色幽默 7.伊斯坦堡 8.印第安老斑鸠 9.龙卷风 10.反方向的钟 《范特西》，发行日期：2001-09-20 1234567891011专辑曲目： 1.爱在西元前 2.爸我回来了 3.简单爱 4.忍者 5.开不了口 6.上海一九四三 7.对不起 8.威廉古堡 9.双截棍 10.安静 《八度空间》，发行日期：2002-07-18 1234567891011专辑曲目： 1.半兽人 2.半岛铁盒 3.暗号 4.龙拳 5.火车叨位去（台） 6.分裂 7.爷爷泡的茶 8.回家过去 9.米兰的小铁匠 10.最后的战役 《叶惠美》，发行日期：2003-07-31 123456789101112专辑曲目： 1.以父之名 2.懦夫 3.晴天 4.三年二班 5.东风破 6.你听得到 7.同一种调调 8.她的睫毛 9.爱情悬崖 10.梯田 11.双刀 《七里香》，发行日期：2004-08-03 1234567891011专辑曲目： 1.我的地盘 2.七里香 3.借口 4.外婆 5.将军 6.搁浅 7.乱舞春秋 8.困兽之斗 9.园游会 10.止战之殇 《11月的萧邦》，发行日期：2005-11-01 12345678910111213专辑曲目： 1.夜曲 2.蓝色风暴(百事可乐广告歌) 3.发如雪 4.黑色毛衣 5.四面楚歌 6.枫 7.浪漫手机 8.逆鳞 9.麦芽糖 10.珊瑚海 11.漂移 12.一路向北 《依然范特西》，发行日期：2006-09-01 1234567891011专辑曲目： 1.夜的第七章 2.听妈妈的话 3.千里之外 4.本草纲目 5.退后 6.红模仿 7.心雨 8.白色风车 9.迷迭香 10.菊花台 《我很忙》，发行日期：2007-11-02 1234567891011专辑曲目： 1.牛仔很忙 2.彩虹 3.青花瓷 4.阳光宅男 5.蒲公英的约定 6.无双 7.我不配 8.扯 9.甜甜的 10.最长的电影 《魔杰座》，发行日期：2008-10-15 123456789101112专辑曲目： 1.龙战骑士 2.给我一首歌的时间 3.蛇舞 4.花海 5.魔术先生 6.说好的幸福呢 7.兰亭序 8.流浪诗人 9.时光机 10.乔克叔叔 11.稻香 《跨时代》，发行日期：2010-05-18 123456789101112专辑曲目： 1.跨时代 2.说了再见 3.烟花易冷 4.免费教学录影带 5.好久不见 6.雨下一整晚 7.嘻哈空姐 8.我落泪，情绪零碎 9.爱的等飞行日记 10.自导自演 11.超人不会飞 《惊叹号》，发行日期：2011-11-11 123456789101112专辑曲目： 1.惊叹号 2.皮影戏 3.Mine Mine 4.你好吗 5.迷魂曲 6.超跑女神 7.世界未末日 8.水手怕水 9.琴伤 10.公主病 11.疗伤烧肉粽 《12新作》，发行日期：2012-12-28 12345678910111213专辑曲目： 1.四季列车 2.手语 3.公公偏头痛 4.明明就 5.傻笑 6.比较大的大提琴 7.爱你没差 8.红尘客栈 9.梦想启动 10.大笨钟 11.哪里都是你 12.乌克丽丽 《哎呦，不错哦》，发行日期：2014-12-26 12345678910111213专辑曲目： 1.阳明山 2.窃爱 3.算什么男人 4.天涯过客 5.怎么了 6.一口气全念对 7.我要夏天 8.手写的从前 9.鞋子特大号 10.听爸爸的话 11.美人鱼 12.听见下雨的声音 《周杰伦的床边故事》，发行日期：2016-06-24 1234567891011专辑曲目： 1.床边故事2.说走就走3.一点点4.前世情人5.英雄6.不该7.土耳其冰淇淋8.告白气球9.Now You See Me10.爱情废柴","tags":[{"name":"周杰伦","slug":"周杰伦","permalink":"http://yoursite.com/tags/周杰伦/"},{"name":"专辑封面","slug":"专辑封面","permalink":"http://yoursite.com/tags/专辑封面/"}]}]