[{"title":"分饼干","date":"2017-07-11T08:18:00.000Z","path":"2017/07/11/cookies/","text":"题目链接：网易2017春招笔试真题编程题集合第十二题 12时间限制：1秒空间限制：32768K 易老师购买了一盒饼干，盒子中一共有k块饼干，但是数字k有些数位变得模糊了，看不清楚数字具体是多少了。易老师需要你帮忙把这k块饼干平分给n个小朋友，易老师保证这盒饼干能平分给n个小朋友。现在你需要计算出k有多少种可能的数值 输入描述: 输入包括两行： 第一行为盒子上的数值k，模糊的数位用X表示，长度小于18(可能有多个模糊的数位) 第二行为小朋友的人数n 输出描述: 输出k可能的数值种数，保证至少为1 输入: 9999999999999X3 输出： 4 我的思路：把所有情况找出来，不就得了，就用了回溯法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;using namespace std;#include&lt;vector&gt;string s;int sum = 0;int main(int argc, char *argv[])&#123; long long getIntValue(string s); // 把字符串转化为数字 vector&lt;int&gt; getXVector(string s);// 得到X的位置 void getKinds(vector&lt;int&gt; x, int k, int n);// 获得所有的情况 int n; cin&gt;&gt;s&gt;&gt;n; vector&lt;int&gt; x = getXVector(s); getKinds(x, 0, n); cout&lt;&lt;sum&lt;&lt;endl; return 0;&#125;long long getIntValue(string s) &#123; long long value = 0; for(int i = 0; i &lt; s.size(); i++) &#123; value = value * 10 + (s[i] - &apos;0&apos;); &#125; return value;&#125;vector&lt;int&gt; getXVector(string s) &#123; vector&lt;int&gt; x; for(int i = 0; i &lt; s.size(); i++) &#123; if (s[i] == &apos;X&apos;) x.push_back(i); &#125; return x;&#125;void getKinds(vector&lt;int&gt; x, int k, int n) &#123; if (k == x.size()) &#123; long long num = getIntValue(s); if (num % n == 0) sum++; &#125; else &#123; for (int i = 0; i &lt;= 9; i++) &#123; if (x[k] == 0 &amp;&amp; i == 0) continue; s[x[k]] = &apos;0&apos; + i; getKinds(x, k + 1, n); &#125; &#125;&#125; 1结果：运行超时。 参考： 古典文化的评论 12dp[i][j] 表示从从左往右数，第i位数字，余数为j的个数 dp[0][0] = 1 代表初始情况下模n为0的个数为1 12345678910int newJ = (j * 10 + k) % n; 如上图所示，4774 % 4=2，过程是怎么样来的？ 可以细化为： 第一位数为4：(0 * 10 + 4) % 4 = 0 tip: 0 * 10，所以dp[0][0] = 1 第二位数为7：(0 * 10 + 7) % 4 = 3 第三位数为7：(3 * 10 + 7) % 4 = 1 第四位数为3：(1 * 10 + 4) % 4 = 2 dp[i][newJ] += dp[i - 1][j]; newJ(i)是由j(i-1)得来的，所以满足j(i-1)的情况下会同样满足newJ(i)，所以满足newJ(i)的个数等于本身的个数加上满足j(i-1)的个数。 4772 % 4 这个延续的过程，如下： 0 1 2 3 0 1 0 0 0 1(4) 1 0 0 0 2(7) 0 0 0 1 3(7) 0 1 0 0 4(4) 0 0 1 0 又比如2X % 2 的所有情况，如下： 0 1 0 1 0 1(2) 1 0 2(X) 5 5 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main(int argc, char *argv[])&#123; string s; int n; cin&gt;&gt;s&gt;&gt;n; vector&lt;vector&lt;int&gt; &gt; dp (s.length() + 1, vector&lt;int&gt;(n, 0)); dp[0][0] = 1; for (int i = 1; i &lt;= s.length(); i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (dp[i - 1][j] == 0) continue; if (s[i - 1] == &apos;X&apos;) &#123; for (int k = 0; k &lt; 10; k++) &#123; int temp = (j * 10 + k) % n; dp[i][temp] += dp[i - 1][j]; &#125; &#125; else &#123; int temp = (j * 10 + (s[i - 1] - &apos;0&apos;)) % n; dp[i][temp] += dp[i - 1][j]; &#125; &#125; &#125; cout&lt;&lt;dp[s.length()][0]&lt;&lt;endl; return 0;&#125; 1测试用例通过90%，原因是因为结果太大，int装不下，只要把int改成long long就可以了。 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main(int argc, char *argv[])&#123; string s; int n; cin&gt;&gt;s&gt;&gt;n; // 注意类型 long long vector&lt;vector&lt;long long&gt; &gt; dp (s.length() + 1, vector&lt;long long&gt;(n, 0)); dp[0][0] = 1; for (int i = 1; i &lt;= s.length(); i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (dp[i - 1][j] == 0) continue; if (s[i - 1] == &apos;X&apos;) &#123; for (int k = 0; k &lt; 10; k++) &#123; int temp = (j * 10 + k) % n; dp[i][temp] += dp[i - 1][j]; &#125; &#125; else &#123; int temp = (j * 10 + (s[i - 1] - &apos;0&apos;)) % n; dp[i][temp] += dp[i - 1][j]; &#125; &#125; &#125; cout&lt;&lt;dp[s.length()][0]&lt;&lt;endl; return 0;&#125; 1当然，可以改成二维数组。 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main(int argc, char *argv[])&#123; string s; int n; cin&gt;&gt;s&gt;&gt;n; vector&lt;vector&lt;long long&gt; &gt; dp (2, vector&lt;long long&gt;(n, 0)); dp[0 &amp; 1][0] = 1; for (int i = 1; i &lt;= s.length(); i++) &#123; for (int j = 0; j &lt; n; j++) // 注意的地方，用之前，先置为0 dp[i &amp; 1][j] = 0; for (int j = 0; j &lt; n; j++) &#123; if (dp[(i - 1) &amp; 1][j] == 0) continue; if (s[i - 1] == &apos;X&apos;) &#123; for (int k = 0; k &lt; 10; k++) &#123; int temp = (j * 10 + k) % n; dp[i &amp; 1][temp] += dp[(i - 1) &amp; 1][j]; &#125; &#125; else &#123; int temp = (j * 10 + (s[i - 1] - &apos;0&apos;)) % n; dp[i &amp; 1][temp] += dp[(i - 1) &amp; 1][j]; &#125; &#125; &#125; cout&lt;&lt;dp[s.length() &amp; 1][0]&lt;&lt;endl; return 0;&#125;","tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"},{"name":"网易","slug":"网易","permalink":"http://yoursite.com/tags/网易/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"}]},{"title":"堆砖块","date":"2017-07-10T08:15:00.000Z","path":"2017/07/10/bricks/","text":"题目链接：网易2017春招笔试真题编程题集合第十一题 12时间限制：1秒空间限制：32768K 小易有n块砖块，每一块砖块有一个高度。小易希望利用这些砖块堆砌两座相同高度的塔。为了让问题简单，砖块堆砌就是简单的高度相加，某一块砖只能使用在一座塔中一次。小易现在让能够堆砌出来的两座塔的高度尽量高，小易能否完成呢。 输入描述: 输入包括两行：第一行为整数n(1 ≤ n ≤ 50)，即一共有n块砖块第二行为n个整数，表示每一块砖块的高度height[i] (1 ≤ height[i] ≤ 500000) 输出描述: 如果小易能堆砌出两座高度相同的塔，输出最高能拼凑的高度，如果不能则输出-1.保证答案不大于500000。 输入: 32 3 5 输出： 5 我的思路：这不就是01背包问题吗？我就快马加鞭的写了一通。1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;#define N 50#define MAX 500001int main(int argc, char *argv[])&#123; int a[N],b[MAX]=&#123;0&#125;; int sum = 0; int n; cin&gt;&gt;n; for (int i = 0; i &lt; n; i++) &#123; cin&gt;&gt;a[i]; sum += a[i]; &#125; if (sum % 2 != 0) &#123; cout&lt;&lt;-1&lt;&lt;endl; return 0; &#125; else sum /= 2; for (int i = 0; i &lt; n; i++) &#123; int value = a[i]; for (int j = sum; j &gt;= 1; j--) &#123; int temp = b[j - value] + value; if (j &gt;= value &amp;&amp; temp &gt; b[j]) b[j] = temp; &#125; &#125; if (b[sum] == sum) cout&lt;&lt;sum&lt;&lt;endl; else cout&lt;&lt;-1&lt;&lt;endl; return 0;&#125; 1结果：没有通过所有实例，原来不是所有的砖块都要用到，比如3,3,5那么答案就是3。这就和01背包相差甚远了。 参考1： 双塔问题 大致意思就是这样，dp[i][j] 表示高度分别为i和j是否存在。若存在即为1，若不存在即为0。 dp[0][0] = 1 代表存在高度分别为0和0的情况，比如什么都不放。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main(int argc, char *argv[])&#123; int sum = 0, n; cin&gt;&gt;n; vector&lt;int&gt; a(n); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; sum += a[i]; &#125; sum /= 2; vector&lt; vector&lt;int&gt; &gt; dp(2, vector&lt;int&gt;(sum + 1, 0)); dp[0][0] = 1; for (int i = 0; i &lt; n; i++) &#123; int value = a[i]; for (int j = sum; j &gt;= 0; j--) &#123; for (int k = sum; k &gt;= 0; k--) &#123; if (j &gt;= value) dp[j][k] = dp[j][k] || dp[j - value][k]; if (k &gt;= value) dp[j][k] = dp[j][k] || dp[j][k - value]; &#125; &#125; &#125; for (int i = 1; i &lt;= sum; i++) &#123; if (dp[i][i] == 1) &#123; cout&lt;&lt;i&lt;&lt;endl; return 0; &#125; &#125; cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl; return 0;&#125; 1结果：内存超限 参考2： 古典文化的评论参考1里面把这种方法已经讲的很详细了，我就不多说了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main(int argc, char *argv[])&#123; int n; cin&gt;&gt;n; vector&lt;int&gt; a(n + 1), sum(n + 1); for (int i = 1; i &lt;= n; i++) cin&gt;&gt;a[i]; sum[0] = 0; for (int i = 1; i &lt;= n; i++) &#123; sum[i] = a[i] + sum[i - 1]; &#125; vector&lt; vector&lt;int&gt; &gt; dp(n + 1, vector&lt;int&gt;(sum[n] + 1, -1)); dp[0][0] = 0; for (int i = 1; i &lt;= n; i++) &#123; int value = a[i]; for (int j = sum[i]; j &gt;= 0; j--) &#123; dp[i][j] = dp[i-1][j]; if (j + value &lt;= sum[i] &amp;&amp; dp[i - 1][j + value] != -1) &#123; dp[i][j] = max(dp[i][j], dp[i - 1][j + value]); &#125; if (value &gt;= j &amp;&amp; dp[i - 1][value - j] != -1) &#123; dp[i][j] = max(dp[i][j], dp[i - 1][value - j] + j); &#125; if (j &gt; value &amp;&amp; dp[i - 1][j - value] != -1) &#123; dp[i][j] = max(dp[i][j], dp[i - 1][j - value] + value); &#125; &#125; &#125; if (dp[n][0] == 0) cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl; else cout&lt;&lt;dp[n][0]&lt;&lt;endl; return 0;&#125; 1结果：内存超限。 还记得01背包将多维数组变成一维数组，这个可不可以变成一维数组呢？答案是不可以，只能缩短为二位数组，因为 dp[i][j] = dp[i-1][j]，它始终要用到前面一行的同为j列的结果。 0的时候第一行1的时候第二行(可以用第一行的结果)2的时候第一行(覆盖第一行（0）的数据，可以用第二行（1）的结果)3的时候第二行(覆盖第二行（2）的数据，可以用第一行（2）的结果) 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main(int argc, char *argv[])&#123; int n; cin&gt;&gt;n; vector&lt;int&gt; a(n + 1); vector&lt;int&gt; sum(n+1); sum[0] = 0; for (int i = 1; i &lt;= n; i++) &#123; cin&gt;&gt;a[i]; sum[i] = a[i] + sum[i - 1]; &#125; vector&lt; vector&lt;int&gt; &gt; dp(2, vector&lt;int&gt;(sum[n] + 1, -1)); dp[0][0] = 0; for (int i = 1; i &lt;= n; i++) &#123; int value = a[i]; for (int j = sum[i]; j &gt;= 0; j--) &#123; dp[i &amp; 1][j] = dp[ (i-1) &amp; 1][j]; if (j + value &lt;= sum[i] &amp;&amp; dp[ (i-1) &amp; 1][j + value] != -1) &#123; dp[i &amp; 1][j] = max(dp[i &amp; 1][j], dp[ (i-1) &amp; 1][j + value]); &#125; if (value &gt;= j &amp;&amp; dp[ (i-1) &amp; 1][value - j] != -1) &#123; dp[i &amp; 1][j] = max(dp[i &amp; 1][j], dp[ (i-1) &amp; 1][value - j] + j); &#125; if (j &gt;= value &amp;&amp; dp[ (i-1) &amp; 1][j - value] != -1) &#123; dp[i &amp; 1][j] = max(dp[i &amp; 1][j], dp[ (i-1) &amp; 1][j - value] + value); &#125; &#125; &#125; if (dp[n &amp; 1][0] == 0) cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl; else cout&lt;&lt;dp[n &amp; 1][0]&lt;&lt;endl; return 0;&#125; 1234567891011121314结果：成功。不过我有一点始终不明白，上述有四种情况，分别是：第一种：不放第二种：放到矮的那一堆，但是依旧是矮的（（j + value） &lt;= sum[i]）第三种：放到矮的那一堆，但是变成高的了（value &gt;= j）第四种：放到高的那一堆（j &gt;= value）第二种的时候，j可能大于value，j也有可能小于value，也就是说：满足第二种情况的时候有时候也满足第三种或第四种的条件，但是它不属于第三种或第四种情况，但是它会执行。满足第三种情况的时候有时候也满足第二种条件，但是它不属于第二种情况，但是它会执行。满足第四种情况的时候有时候也满足第二种条件，但是它不属于第二种情况，但是它会执行。但是结果是正确的，我始终想不通。 参考3： minnnng的评论 假设砖块分为A，B两堆，dp[i][j]中的j表示B-A的长度。而dp[i][j]的值则表示当B-A的值为j时，A的最大长度是多少。 因为B-A有可能是负的，所以j整体偏移sum个长度，即2*sum+1。dp[0][0] 代表相差 （-sum），dp[0][sum]代表相差0，dp[0][2$\\ast$sum]代表相差sum。 dp[i][j] = dp[i-1][j] 表示我不用第i块砖dp[i][j] = max(dp[i-1][j+h] + h, dp[i][j]) 表示我把砖放在A堆。dp[i][j] = max(dp[i-1][j-h], dp[i][j]) 表示我把砖放在B堆。 以上语句摘抄与上述评论中的内容，唯一不同的是，我dp[i][j]表示B-A的值为j时，A的最大长度。 我认为这种思路更有说服性，简单明了，不会错失所有情况。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main(int argc, char *argv[])&#123; int n; cin&gt;&gt;n; vector&lt;int&gt; a(n + 1); vector&lt;int&gt; sum(n+1); sum[0] = 0; for (int i = 1; i &lt;= n; i++) &#123; cin&gt;&gt;a[i]; sum[i] = a[i] + sum[i - 1]; &#125; vector&lt; vector&lt;int&gt; &gt; dp(2, vector&lt;int&gt;(2 * sum[n] + 1, -1)); dp[0][sum[n]] = 0; for (int i = 1; i &lt;= n; i++) &#123; int value = a[i]; for (int j = sum[n] + sum[i]; j &gt;= sum[n] - sum[i]; j--) &#123; dp[i &amp; 1][j] = dp[ (i-1) &amp; 1][j]; if ((j + value) &lt;= (sum[n] + sum[i]) &amp;&amp; dp[ (i-1) &amp; 1][j + value] != -1) dp[i &amp; 1][j] = max(dp[i &amp; 1][j], dp[ (i-1) &amp; 1][j + value] + value); if ((j - value) &gt;= (sum[n] - sum[i]) &amp;&amp; dp[ (i-1) &amp; 1][j - value] != -1) dp[i &amp; 1][j] = max(dp[i &amp; 1][j], dp[ (i-1) &amp; 1][j - value]); &#125; &#125; if (dp[n &amp; 1][sum[n]] == 0) cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl; else cout&lt;&lt;dp[n &amp; 1][sum[n]]&lt;&lt;endl; return 0;&#125;","tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"},{"name":"网易","slug":"网易","permalink":"http://yoursite.com/tags/网易/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"}]},{"title":"小易记单词","date":"2017-07-07T09:44:00.000Z","path":"2017/07/07/rememberWord/","text":"题目链接：网易2017春招笔试真题编程题集合第十题 12时间限制：1秒空间限制：32768K 小易参与了一个记单词的小游戏。游戏开始系统提供了m个不同的单词，小易记忆一段时间之后需要在纸上写出他记住的单词。小易一共写出了n个他能记住的单词，如果小易写出的单词是在系统提供的，将获得这个单词长度的平方的分数。注意小易写出的单词可能重复，但是对于每个正确的单词只能计分一次。 输入描述: 输入数据包括三行： 第一行为两个整数n(1 ≤ n ≤ 50)和m(1 ≤ m ≤ 50)。以空格分隔 第二行为n个字符串，表示小易能记住的单词，以空格分隔，每个单词的长度小于等于50。 第三行为m个字符串，系统提供的单词，以空格分隔，每个单词的长度小于等于50。 输出描述: 输出一个整数表示小易能获得的分数 输入: 3 4apple orange strawberrstrawberry orange grapefruit watermelon 输出： 136 我的思路：起初我还想一个字符一个字符进行比较，遇到空格便是一个单词。 然后意识到，字符串也是可以比较的。 又遇到了不能重复，我就用了一个数组来表示答对的单词。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;#define N 50int main(int argc, char *argv[])&#123; string s1[N], s2[N], s3[N]; int sum = 0, score = 0; int m, n; cin&gt;&gt;m&gt;&gt;n; for (int i = 0; i &lt; m; i++) cin&gt;&gt;s1[i]; for (int i = 0; i &lt; n; i++) cin&gt;&gt;s2[i]; for (int i = 0; i &lt; m; i++) &#123; bool flag = false; for (int j = 0; j &lt; n ; j++) &#123; if (s1[i] == s2[j]) &#123; flag = true; break; &#125; &#125; if (flag) &#123; bool isIN = false; for (int k = 0; k &lt; sum; k++) &#123; if (s3[k] == s1[i]) &#123; isIN = true; break; &#125; &#125; if (!isIN) &#123; s3[sum++] = s1[i]; score += pow(s1[i].size(), 2); &#125; &#125; &#125; cout&lt;&lt;score&lt;&lt;endl; return 0;&#125; 结果是对的，我看了一下评论，看到一个人和我做的一样，看到他下面的评论，可以用vis标记系统单词已经被记住的。 我想到了工作安排那一道题，我好想也是这么做的，为什么就记不住呢？ 12345678910111213141516171819202122232425262728293031改进版：#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;#define N 50int main(int argc, char *argv[])&#123; string s1[N], s2[N]; int s[N] = &#123;0&#125;, score = 0; int m, n; cin&gt;&gt;m&gt;&gt;n; for (int i = 0; i &lt; m; i++) cin&gt;&gt;s1[i]; for (int i = 0; i &lt; n; i++) cin&gt;&gt;s2[i]; for (int i = 0; i &lt; m; i++) &#123; int j; for (j = 0; j &lt; n ; j++) &#123; if (s1[i] == s2[j]) &#123; if (!s[j]) &#123; score += pow(s1[i].size(), 2); s[j] = 1; &#125; break; &#125; &#125; &#125; cout&lt;&lt;score&lt;&lt;endl; return 0;&#125;","tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"},{"name":"网易","slug":"网易","permalink":"http://yoursite.com/tags/网易/"},{"name":"标记已用","slug":"标记已用","permalink":"http://yoursite.com/tags/标记已用/"}]},{"title":"涂棋盘","date":"2017-07-07T08:37:00.000Z","path":"2017/07/07/chessboard/","text":"题目链接：网易2017春招笔试真题编程题集合第九题 12时间限制：1秒空间限制：32768K 小易有一块n*n的棋盘，棋盘的每一个格子都为黑色或者白色，小易现在要用他喜欢的红色去涂画棋盘。小易会找出棋盘中某一列中拥有相同颜色的最大的区域去涂画，帮助小易算算他会涂画多少个棋格。 输入描述: 接下来的n行每行一个字符串表示第i行棋盘的颜色，’W’表示白色，’B’表示黑色 输出描述: 输出小易会涂画的区域大小 输入: 3BWWBBBBWB 输出： 3 我的思路：一列一列的找，找出最长连续的即可。一开始，我想一列中的白色最多和黑色最多很开，但是很快就否定了，既然找最大，就不用分的那么细了。直接上代码吧。12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;#define N 50int main(int argc, char *argv[])&#123; string s[N]; int n, max = 0; cin&gt;&gt;n; for (int i = 0; i &lt; n; i++) cin&gt;&gt;s[i]; for (int j = 0; j &lt; n; j++) &#123; int i = 0; char c = s[i][j]; while (i &lt; n) &#123; int k, num; for (k = i; k &lt; n &amp;&amp; s[k][j] == c; k++); num = k - i; if (num &gt; max) max = num; if (k == n)// 不然容易出现堆溢出，因为会调用 c = s[n][j] break; c = s[k][j]; i = k; &#125; &#125; cout&lt;&lt;max&lt;&lt;endl; return 0;&#125; 看了大神的代码之后，才发现我写的虽然对，但是有点绕。123456789101112131415161718192021222324252627改进代码：#include &lt;iostream&gt;using namespace std;#define N 50int main(int argc, char *argv[])&#123; string s[N]; int n, max = 1; cin&gt;&gt;n; for (int i = 0; i &lt; n; i++) cin&gt;&gt;s[i]; for (int j = 0; j &lt; n; j++) &#123; int num = 1; for (int i = 0; i &lt; n - 1; i++) &#123; if (s[i][j] == s[i+1][j]) &#123; num++; if (num &gt; max) max = num; &#125; else &#123; num = 1; &#125; &#125; &#125; cout&lt;&lt;max&lt;&lt;endl; return 0;&#125;","tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"},{"name":"网易","slug":"网易","permalink":"http://yoursite.com/tags/网易/"},{"name":"连续区域长度","slug":"连续区域长度","permalink":"http://yoursite.com/tags/连续区域长度/"}]},{"title":"奇怪的表达式","date":"2017-07-07T07:20:00.000Z","path":"2017/07/07/expression/","text":"题目链接：网易2017春招笔试真题编程题集合第八题 12时间限制：1秒空间限制：32768K 常规的表达式求值，我们都会根据计算的优先级来计算。比如$\\ast$ /的优先级就高于+-。但是小易所生活的世界的表达式规则很简单，从左往右依次计算即可，而且小易所在的世界没有除法，意味着表达式中没有/，只有(+, - 和 $\\ast$)。现在给出一个表达式，需要你帮忙计算出小易所在的世界这个表达式的值为多少 输入描述: 输入为一行字符串，即一个表达式。其中运算符只有-,+,*。参与计算的数字只有0~9.保证表达式都是合法的，排列规则如样例所示。 输出描述: 输出一个数，即表达式的值 输入: 3+5*7 输出： 56 我的思路：首先我想到了栈，想到了运算优先级，想到了中缀表达式是不能直接算出结果的，必须通过转化为后缀表达式，然后通过后缀表达式来进行计算。 既然这道题目不考虑优先级，那就好算了。首先把第一个元素压入栈，然后遇到符号，就把栈里面的一个元素和符号后面的那个元素进行计算，然后出栈，把结果压入栈，依次类推。 我考虑到万一数字不是一位数怎么办？所以就首先写了一个把数字找出来，把符号找出来，然后就好写了。123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;int main(int argc, char *argv[])&#123; string s = &quot;1+10*11&quot;; int temp = 0; for (int i = 0; i &lt; s.size(); i++) &#123; if (s[i] == &apos; &apos;) continue; else if (&apos;0&apos; &lt;= s[i] &amp;&amp; s[i] &lt;= &apos;9&apos;) &#123; int c = s[i] - &apos;0&apos;; temp = temp * 10 + c; &#125; else if (s[i] ==&apos;+&apos; || s[i] ==&apos;-&apos; || s[i] ==&apos;*&apos;) &#123; cout&lt;&lt;temp&lt;&lt;endl; cout&lt;&lt;s[i]&lt;&lt;endl; temp = 0; &#125; &#125; cout&lt;&lt;temp&lt;&lt;endl; return 0;&#125; 数字和符号都找好了，我需要知道第一个数字，和遇到符号之后，我还要知道符号后面的数字，我就把它写成了个函数。1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;int main(int argc, char *argv[])&#123; //得到一个数字，k是从第几个位置开始 int getIntValue(string s, int k); string s; cin&gt;&gt;s; int b = getIntValue(s, 0); for(int i = 0; i &lt; s.size(); i++) &#123; if (s[i] ==&apos;+&apos; || s[i] ==&apos;-&apos; || s[i] ==&apos;*&apos;) &#123; int temp = getIntValue(s, i + 1); if (s[i] ==&apos;+&apos;) &#123; b = b + temp; &#125; else if (s[i] ==&apos;-&apos;) &#123; b = b - temp; &#125; else if (s[i] ==&apos;*&apos;) &#123; b = b * temp; &#125; &#125; &#125; cout&lt;&lt;b&lt;&lt;endl; return 0;&#125;int getIntValue(string s, int k) &#123; int temp = 0; for (int i = k; i &lt; s.size(); i++) &#123; if (s[i] == &apos; &apos;) continue; else if (&apos;0&apos; &lt;= s[i] &amp;&amp; s[i] &lt;= &apos;9&apos;) &#123; int c = s[i] - &apos;0&apos;; temp = temp * 10 + c; &#125; else if (s[i] ==&apos;+&apos; || s[i] ==&apos;-&apos; || s[i] ==&apos;*&apos;) &#123; break; &#125; &#125; return temp;&#125; 后来看了一下评论，发现数字只是0~9，根本不会出现两位以上的数字，那这就更好办了，函数也不需要了。 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;int main(int argc, char *argv[])&#123; string s; cin&gt;&gt;s; int b = s[0] - &apos;0&apos;; for(int i = 0; i &lt; s.size(); i++) &#123; if (s[i] ==&apos;+&apos; || s[i] ==&apos;-&apos; || s[i] ==&apos;*&apos;) &#123; int temp = s[i + 1] - &apos;0&apos;; if (s[i] ==&apos;+&apos;) &#123; b = b + temp; &#125; else if (s[i] ==&apos;-&apos;) &#123; b = b - temp; &#125; else if (s[i] ==&apos;*&apos;) &#123; b = b * temp; &#125; &#125; &#125; cout&lt;&lt;b&lt;&lt;endl; return 0;&#125;","tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"},{"name":"网易","slug":"网易","permalink":"http://yoursite.com/tags/网易/"},{"name":"栈","slug":"栈","permalink":"http://yoursite.com/tags/栈/"}]},{"title":"集合","date":"2017-07-04T04:03:00.000Z","path":"2017/07/04/collection/","text":"题目链接：网易2017春招笔试真题编程题集合第七题 12时间限制：1秒空间限制：32768K 小易最近在数学课上学习到了集合的概念,集合有三个特征：1.确定性 2.互异性 3.无序性.小易的老师给了小易这样一个集合：S = { p/q | w ≤ p ≤ x, y ≤ q ≤ z }需要根据给定的w，x，y，z,求出集合中一共有多少个元素。小易才学习了集合还解决不了这个复杂的问题,需要你来帮助他。 输入描述: 输出集合中元素的个数 输出描述: 输出魔力手环使用k次之后的状态，以空格分隔，行末无空格。 输入: 1 10 1 1 输出： 10 我的思路：如果：$\\frac p q = \\frac m n$， 那么：$p \\times n = q \\times m$总的来说,依旧是去除重复这一核心思路。123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;#define N 10000 int main(int argc, char *argv[])&#123; int a[2][N]; int w, x, y, z; cin&gt;&gt;w&gt;&gt;x&gt;&gt;y&gt;&gt;z; a[0][0] = w; a[1][0] = y; int sum = 1; for (int i = w; i &lt;= x; i++) &#123; for (int j = y; j &lt;= z; j++) &#123; bool flag = true; for (int k = 0; k &lt; sum; k++) &#123; if (a[0][k] * j == a[1][k] * i) &#123; flag = false; break; &#125; &#125; if (flag) &#123; a[0][sum] = i; a[1][sum] = j; sum++; &#125; &#125; &#125; cout&lt;&lt;sum&lt;&lt;endl; return 0;&#125;","tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"},{"name":"网易","slug":"网易","permalink":"http://yoursite.com/tags/网易/"},{"name":"去除重复","slug":"去除重复","permalink":"http://yoursite.com/tags/去除重复/"}]},{"title":"工作安排","date":"2017-07-03T10:49:00.000Z","path":"2017/07/03/workplan/","text":"题目链接：网易2017春招笔试真题编程题集合第六题 12时间限制：1秒空间限制：32768K 现在有n位工程师和6项工作(编号为0至5)，现在给出每个人能够胜任的工作序号表(用一个字符串表示，比如：045，表示某位工程师能够胜任0号，4号，5号工作)。现在需要进行工作安排，每位工程师只能被安排到自己能够胜任的工作当中去，两位工程师不能安排到同一项工作当中去。如果两种工作安排中有一个人被安排在的工作序号不一样就被视为不同的工作安排，现在需要计算出有多少种不同工作安排计划。 输入描述: 输入数据有n+1行：第一行为工程师人数n(1 ≤ n ≤ 6)接下来的n行，每行一个字符串表示第i(1 ≤ i ≤ n)个人能够胜任的工作(字符串不一定等长的) 输出描述: 输出一个整数，表示有多少种不同的工作安排方案 输入例子: 6012345012345012345012345012345012345 输出例子： 720 我的思路：其实，我理解的意思是，所有的工作都要做完，根据上面的例子，所有的情况应该是$6^6$，但是上面的答案是$6!$，我就理解成了，所有的工作都要做完，并且所有的人都要参与进去。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/*这道题目题意有点模糊我理解的意思：所有的工作都要做完，而且所有的成员都要参与进去下面的代码就是实现上述功能 */#include &lt;iostream&gt;using namespace std;#include&lt;string.h&gt;#define N 6int sum = 0;int b[N];int main(int argc, char *argv[])&#123; void fun(string a[], int m, int n, int k); bool judge(int n, int k); string a[6] = &#123; &quot;012345&quot;, &quot;012345&quot;, &quot;012345&quot;, &quot;012345&quot;, &quot;012345&quot;, &quot;012345&quot; &#125;; int n = 6; int k = 6; fun(a, 0, n, k); cout&lt;&lt;sum&lt;&lt;endl; return 0;&#125;//确保所有的人都参与 bool judge(int n, int k) &#123; for (int i = 0; i &lt; k; i++) &#123; int j; for (j = 0; j &lt; n; j++)&#123; if (b[j] == i) break; &#125; if (j == n) return false; &#125; return true;&#125;//回溯求解 void fun(string a[], int m, int n, int k) &#123; if (m == n &amp;&amp; judge(n, k)) sum++; else &#123; for (int i = 0; i &lt; k; i++) &#123; for (int j = 0; j &lt; a[i].size(); j++) &#123; if((int)(a[i][j] - &apos;0&apos;) == m)&#123; b[m] = i; fun(a, m+1, n, k); &#125; &#125; &#125; &#125;&#125; 12345结果：运行错误，没有通过所有实例后来看了一下评论，原来意思理解错了。真正意思：①：每个人做一件事情，且唯一②：不用把所有的工作做完 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/*这道题目题意有点模糊其实意思是：1、所有工程师都必须有事可做，且只能做一件事情。2、不必所有事都要做。 下面的代码就是实现上述功能 */#include &lt;iostream&gt;using namespace std;#include&lt;string.h&gt;#define N 6int sum = 0;char b[N];int main(int argc, char *argv[])&#123; void fun(string a[], int m, int k); bool judge(int n); string a[N]; int k; cin&gt;&gt;k; for(int i = 0; i &lt; k; i++) cin&gt;&gt;a[i]; fun(a, 0, k); cout&lt;&lt;sum&lt;&lt;endl; return 0;&#125;//判断有没有人做相同的工作 bool judge(int n) &#123; for (int i = 0; i &lt; n - 1; i++) &#123; for (int j = i + 1; j &lt; n; j++) &#123; if (b[i] == b[j]) return false; &#125; &#125; return true;&#125;//回溯法求解 void fun(string a[], int m, int k) &#123; if (m == k) &#123; sum++; &#125; else &#123; for (int j = 0; j &lt; a[m].size(); j++) &#123; b[m] = a[m][j]; if (judge(m+1)) fun(a, m + 1, k); &#125; &#125;&#125; 12我是用了个双重循环来进行判断。看到其他的评论里，有人是用一个一维数组来记录这份工作是否被做，这样做，感觉效率更高一些。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*这道题目题意有点模糊其实意思是：1、所有工程师都必须有事可做，且只能做一件事情。2、不必所有事都要做。 下面的代码就是实现上述功能 */#include &lt;iostream&gt;using namespace std;#include&lt;string.h&gt;#define N 6int sum = 0;int b[N] = &#123;0&#125;;int main(int argc, char *argv[])&#123; void fun(string a[], int m, int k); string a[N]; int k; cin&gt;&gt;k; for(int i = 0; i &lt; k; i++) cin&gt;&gt;a[i]; fun(a, 0, k); cout&lt;&lt;sum&lt;&lt;endl; return 0;&#125;//回溯法求解 void fun(string a[], int m, int k) &#123; if (m == k) &#123; sum++; &#125; else &#123; for (int j = 0; j &lt; a[m].size(); j++) &#123; int temp = (int)(a[m][j] - &apos;0&apos;); if (b[temp] == 0) &#123; b[temp] = 1; fun(a, m + 1, k); b[temp] = 0; &#125; &#125; &#125;&#125;","tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"},{"name":"网易","slug":"网易","permalink":"http://yoursite.com/tags/网易/"},{"name":"回溯法","slug":"回溯法","permalink":"http://yoursite.com/tags/回溯法/"}]},{"title":"魔力手环","date":"2017-07-02T04:48:00.000Z","path":"2017/07/02/magicBracelet/","text":"题目链接：网易2017春招笔试真题编程题集合第五题 12时间限制：1秒空间限制：32768K 小易拥有一个拥有魔力的手环上面有n个数字(构成一个环),当这个魔力手环每次使用魔力的时候就会发生一种奇特的变化：每个数字会变成自己跟后面一个数字的和(最后一个数字的后面一个数字是第一个),一旦某个位置的数字大于等于100就马上对100取模(比如某个位置变为103,就会自动变为3).现在给出这个魔力手环的构成，请你计算出使用k次魔力之后魔力手环的状态。 输入描述: 输入数据包括两行：第一行为两个整数n(2 ≤ n ≤ 50)和k(1 ≤ k ≤ 2000000000),以空格分隔第二行为魔力手环初始的n个数，以空格分隔。范围都在0至99. 输出描述: 输出魔力手环使用k次之后的状态，以空格分隔，行末无空格。 输入: 3 21 2 3 输出： 8 9 7 我的思路：当我拿到题目的那一刻，我在想，有这么简单，一定在逗我，我猜我写完之后，一定会超时。试试吧。1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;#define MAX 50int main(int argc, char *argv[])&#123; int k, n; int a[MAX]; cin&gt;&gt;n&gt;&gt;k; for (int i = 0; i &lt; n; i++) cin&gt;&gt;a[i]; for (int i = 0; i &lt; k; i++) &#123; int temp = a[0]; for (int j = 0;j &lt; n - 1; j++) &#123; a[j] += a[j+1]; if (a[j] &gt;= 100) a[j] %= 100; &#125; a[n-1] += temp; if (a[n-1] &gt;= 100) a[n-1] %= 100; &#125; for (int i = 0; i &lt; n; i++) &#123; if (i == 0) cout&lt;&lt;a[i]; else cout&lt;&lt;&apos; &apos;&lt;&lt;a[i]; &#125; cout&lt;&lt;endl; return 0;&#125; 12345结果：果然运行超时。我是自己想呢？还是直接看评论？自己想了一小会，算了，不想了，直接看评论吧。还好我及时看了评论，不然我这辈子都想不出来。 快速幂取余：参考内容：快速幂取余算法矩阵快速幂的应用题 – 魔力手环 核心公式：$a^b$ mod $c$ = $(a^{2^\\frac b2})$ mod $c$，b 是偶数$a^b$ mod $c$ = $(a \\ast a^{2^\\frac b2})$ mod $c$，b 是奇数 例子演示：$a^{10} = a^{2^5} = a^2 \\ast a^{4^2} = a^2 \\ast a^{8^1} = a^2 \\ast a^8 \\ast a^{16^0} = a^2 \\ast a^8$$a^7 = a \\ast a^{2^3} = a \\ast a^2 \\ast a^{4^1} = a \\ast a^2 \\ast a^4 \\ast a^{8^0} = a \\ast a^2 \\ast a^4$ 核心代码一：123456789101112int quickMod(int a, int b, int c) &#123; int ans = 1; while (b) &#123; if (b % 2 == 1) ans = (ans * a) % c; b /= 2; a = (a * a) % c; &#125; return ans; &#125; 例子演示：$a^{10}$ a b ans $a$ 10 1 $a^2$ 5 $1 \\ast a^2$ $a^4$ 2 $1 \\ast a^2$ $a^8$ 1 $1 \\ast a^2 \\ast a^8$ $a^{16}$ 0 结束 $a^7$ a b ans $a$ 7 $1 \\ast a$ $a^2$ 3 $1 \\ast a \\ast a^2$ $a^4$ 1 $1 \\ast a \\ast a^2 \\ast a^4$ $a^8$ 0 结束 10 的二进制为：1010$a^{10} = a^2 \\ast a^8$7 的二进制为：111$a^7 = a \\ast a^2 \\ast a^4$1有没有发现规律？凡是为1的就乘以a^n(n为（1、2、4、8……）)。 核心代码二：123456789101112int quickMod(int a, int b, int n) &#123; int ans = 1; while (b) &#123; if (b &amp; 0x1) //如果二进制位为1 ans = ans * a % n; a = a * a % n; b &gt;&gt;= 1 //b向又移1位 &#125; return ans; &#125; 例子演示： $a^{10}$ a b ans $a$ 1010 1 $a^2$ 0101 $1 \\ast a^2$ $a^4$ 0010 $1 \\ast a^2$ $a^8$ 0001 $1 \\ast a^2 \\ast a^8$ $a^{16}$ 0000 结束 $a^7$ a b ans $a$ 111 $1 \\ast a$ $a^2$ 011 $1 \\ast a \\ast a^2$ $a^4$ 001 $1 \\ast a \\ast a^2 \\ast a^4$ $a^8$ 000 结束 大神思路： 大神说：如输入A = [[1, 2, 3]], k = 2。我们可以构造一个这样的矩阵B[[1, 0, 1], [1, 1, 0], [0, 1, 1]]，使得$A*B^k$相当于A转换k次后的样子。于是原问题就变成求矩阵快速幂。快速幂取余中，$a^k$ % c = $(a \\% c)^k \\% c$。 1实际上，把ans当做矩阵A，a当做矩阵B，当然矩阵B的生成也是有规律的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;using namespace std;#define N 50int ans[1][N]; int a[N][N] = &#123;0&#125;;int main(int argc, char *argv[])&#123; //两个矩阵相乘，a1和a2是两个矩阵，m和n是最终矩阵的行数和列数 //row为第一个数组的列数或者第二个数组的行数 //type为0：代表 a = a*a;type为1：代表ans = ans*a void Core(int a1[N][N], int a2[N][N], int m, int n, int row, int type); void power(int k, int n);//快速幂取余，k代表次数，n代表个数 int n, k; cin&gt;&gt;n&gt;&gt;k; //输入矩阵ans for (int i = 0; i &lt; n; i++) cin&gt;&gt;ans[0][i]; //生成矩阵a for (int i = 0; i &lt; n; i++) &#123; a[i][i] = 1; a[(i+1) % n][i] = 1; &#125; //计算矩阵快速幂 power(k, n); //输出矩阵ans for (int i = 0; i &lt; n; i++) &#123; if (i == 0) cout&lt;&lt;ans[0][i]; else cout&lt;&lt;&apos; &apos;&lt;&lt;ans[0][i]; &#125; cout&lt;&lt;endl; return 0;&#125;void Core(int a1[N][N], int a2[N][N], int m, int n, int row, int type) &#123; int temp[N][N] = &#123;0&#125;; for(int i = 0; i &lt; m; i++) &#123; //两个矩阵相乘，保存到temp中 for (int j = 0; j &lt; n; j++) &#123; for (int k = 0; k &lt; row; k++) &#123; if(a1[i][k] == 0 || a2[k][j] == 0) //剪枝 continue; temp[i][j] += a1[i][k] * a2[k][j]; &#125; if (temp[i][j] &gt;= 100) //100取余运算 temp[i][j] %= 100; &#125; &#125; if (type == 1) &#123; for(int i = 0; i &lt; m; i++) //给ans赋值 for (int j = 0; j &lt; n; j++) ans[i][j] = temp[i][j]; &#125; else if (type == 0) &#123; for(int i = 0; i &lt; m; i++) //给a赋值 for (int j = 0; j &lt; n; j++) a[i][j] = temp[i][j]; &#125;&#125;void power(int k, int n) &#123; while(k) &#123; if (k &amp; 0x1 == 1) Core(ans, a, 1, n, n, 1); Core(a, a, n, n, n, 0); k &gt;&gt;= 1; &#125;&#125;","tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"},{"name":"网易","slug":"网易","permalink":"http://yoursite.com/tags/网易/"},{"name":"快速幂取余","slug":"快速幂取余","permalink":"http://yoursite.com/tags/快速幂取余/"},{"name":"矩阵相乘","slug":"矩阵相乘","permalink":"http://yoursite.com/tags/矩阵相乘/"}]},{"title":"消除重复元素","date":"2017-06-29T14:19:00.000Z","path":"2017/06/29/distinct/","text":"题目链接：网易2017春招笔试真题编程题集合第四题 12时间限制：1秒空间限制：32768K 小易有一个长度为n序列，小易想移除掉里面的重复元素，但是小易想是对于每种元素保留最后出现的那个。小易遇到了困难,希望你来帮助他。 输入描述: 输入包括两行：第一行为序列长度n(1 ≤ n ≤ 50)第二行为n个数sequence[i] (1 ≤ sequence[i] ≤ 1000),以空格分隔 输出描述: 输出消除重复元素之后的序列，以空格分隔，行末无空格 输入例子: 9100 100 100 99 99 99 100 100 100 输出例子： 99 100 我的思路：其实去重复元素的例子以前做过，但是以前做的都是保存重复元素的第一个元素。 用一个二维数组记录重复元素和重复元素的最后一个元素的位置，然后递增排序，就可以得到结果。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;using namespace std;#define MAX 50 int main(int argc, char *argv[])&#123; int a[MAX], b[2][MAX], count = 0;// b数组用来记录除重数组， //第一行是元素，第二行是位置 int n; cin&gt;&gt;n; for(int i = 0; i &lt; n; i++) cin&gt;&gt;a[i]; b[0][0] = a[0]; b[1][0] = 0; count++; int i, j; for (i = 1; i &lt; n; i++) &#123; for (j = 0; j &lt; count; j++) &#123; // 判断是否是重复元素 if(a[i] == b[0][j]) &#123; b[1][j] = i; // 覆盖位置 break; &#125; &#125; if (j == count) &#123;// 不是重复元素 b[0][count] = a[i]; //插入数据 b[1][count] = i; //保存位置 count++; &#125; &#125; //排序得到结果 for (int i = 0; i &lt; count-1; i++) &#123; int temp = i; for (int j = i+1; j &lt; count; j++) &#123; if (b[1][j] &lt; b[1][temp]) temp = j; &#125; if (temp != i) &#123; int c = b[0][i]; b[0][i] = b[0][temp]; b[0][temp] = c; c = b[1][i]; b[1][i] = b[1][temp]; b[1][temp] = c; &#125; &#125; for (int i = 0; i &lt; count; i++) &#123; if(i == 0) cout&lt;&lt;b[0][i]; else cout&lt;&lt;&apos; &apos;&lt;&lt;b[0][i]; &#125; cout&lt;&lt;endl; return 0;&#125; 1结果虽然正确，但是感觉代码量还是有点庞大。 大神的思路： ①：倒着去除重复元素，那么保留的就是正序的最后一个②：然后倒着输出就是结果 也许这样说不容易理解，看了代码，就会立马明白。 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;#define MAX 50 int main(int argc, char *argv[])&#123; int a[MAX], b[MAX], count = 0; int n; cin&gt;&gt;n; for(int i = 0; i &lt; n; i++) cin&gt;&gt;a[i]; b[0] = a[n-1]; count++; int i, j; for (i = n-2; i &gt;= 0; i--) &#123; // 倒着去除重复元素 for (j = 0; j &lt; count; j++) &#123; if(a[i] == b[j]) break; &#125; if (j == count) &#123; b[count++] = a[i]; &#125; &#125; for (int i = count-1; i &gt;= 0; i--) &#123;// 倒着输出 if(i == count-1) cout&lt;&lt;b[i]; else cout&lt;&lt;&apos; &apos;&lt;&lt;b[i]; &#125; cout&lt;&lt;endl; return 0;&#125;","tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"},{"name":"网易","slug":"网易","permalink":"http://yoursite.com/tags/网易/"},{"name":"去除重复","slug":"去除重复","permalink":"http://yoursite.com/tags/去除重复/"}]},{"title":"调整队形","date":"2017-06-28T14:29:00.000Z","path":"2017/06/28/adjustOrder /","text":"题目链接：网易2017春招笔试真题编程题集合第三题 12时间限制：1秒空间限制：32768K 在幼儿园有n个小朋友排列为一个队伍，从左到右一个挨着一个编号为(0~n-1)。其中有一些是男生，有一些是女生，男生用’B’表示，女生用’G’表示。小朋友们都很顽皮，当一个男生挨着的是女生的时候就会发生矛盾。作为幼儿园的老师，你需要让男生挨着女生或者女生挨着男生的情况最少。你只能在原队形上进行调整，每次调整只能让相邻的两个小朋友交换位置，现在需要尽快完成队伍调整，你需要计算出最少需要调整多少次可以让上述情况最少。例如：GGBBG -&gt; GGBGB -&gt; GGGBB这样就使之前的两处男女相邻变为一处相邻，需要调整队形2次 输入描述: 输入数据包括一个长度为n且只包含G和B的字符串.n不超过50. 输出描述: 输出一个整数，表示最少需要的调整队伍的次数 输入例子: GGBBG 输出例子： 2 我的思路：①：如果G的个数大于B的个数，那么移动G；否则移动B②：满足①后，如果左边的个数大于右边的个数，则把G或B移动到左边；否则则把G或B移动到右边 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149我的代码：#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;using namespace std;#define MAX 50 int main(int argc, char *argv[])&#123; char arr[MAX]; void shift(char arr[], int m, int n);// 交换位置 bool judge(char arr[], int n);// 判断是否符合要求（男生和女生分开） cin&gt;&gt;arr; int n = strlen(arr), middle, sum = 0; if (judge(arr, n))&#123; cout&lt;&lt;0&lt;&lt;endl; return 0; &#125; int leftG, leftB, rightG, rightB; leftG = leftB = rightG = rightB = 0; if (n % 2 == 0) // 规定中间点 middle = n / 2 - 1; else middle = n / 2; int i,j; for(i = 0; i &lt;= middle; i++) &#123; // 计算左边的G和B的个数 if (arr[i] == &apos;G&apos;) leftG++; else if (arr[i] == &apos;B&apos;) leftB++; &#125; for(j = middle + 1; j &lt; n; j++) &#123; // 计算左边的G和B的个数 if (arr[j] == &apos;G&apos;) rightG++; else if (arr[j] == &apos;B&apos;) rightB++; &#125; if((leftG + rightG) &gt; (leftB + leftB)) &#123; // 如果G的个数大于B的个数 if(leftG &gt; rightG) &#123; // 如果左边G的个数大于右边G的个数 for (i = 0; i &lt; n; i++) &#123; // 把所有的G移动到左边 // 逐个寻找右边的G，把它移到左边B的位置 if (judge(arr, n))&#123; cout&lt;&lt;sum&lt;&lt;endl; break; &#125; if(arr[i] == &apos;B&apos;) &#123; // 找到B的位置 for (j = i + 1; j &lt; n; j++)&#123;// 找到G的位置 if (arr[j] == &apos;G&apos;) &#123; shift(arr, i, j);// 把G移动到左边 sum += abs(i - j);// 累加交换次数 break; &#125; &#125; &#125; &#125; &#125; else &#123;// 如果左边G的个数小于右边G的个数 for (i = n-1; i &gt;= 0; i--) &#123;// 把所有的G移动到右边 // 逐个寻找左边的G，把它移到右边B的位置 if (judge(arr, n))&#123;// 首先判断是否符合队列要求 cout&lt;&lt;sum&lt;&lt;endl; break; &#125; if(arr[i] == &apos;B&apos;) &#123;// 找到B的位置 for (j = i - 1; j &gt;= 0; j--)&#123; if (arr[j] == &apos;G&apos;) &#123; //找到G的位置 shift(arr, i, j);// 把G移动到右边 sum += abs(i - j);// 累加交换次数 break; &#125; &#125; &#125; &#125; &#125; &#125; else &#123;// 如果B的个数大于G的个数，和上面类似的道理。 if(leftB &gt; rightB) &#123; for (i = 0; i &lt; n; i++) &#123; if (judge(arr, n))&#123; cout&lt;&lt;sum&lt;&lt;endl; break; &#125; if(arr[i] == &apos;G&apos;) &#123; for (j = i + 1; j &lt; n; j++)&#123; if (arr[j] == &apos;B&apos;) &#123; shift(arr, i, j); sum += abs(i - j); break; &#125; &#125; &#125; &#125; &#125; else &#123; for (i = n-1; i &gt;= 0; i--) &#123; if (judge(arr, n))&#123; cout&lt;&lt;sum&lt;&lt;endl; break; &#125; if(arr[i] == &apos;G&apos;) &#123; for (j = i - 1; j &gt;= 0; j--)&#123; if (arr[j] == &apos;B&apos;) &#123; shift(arr, i, j); sum += abs(i - j); break; &#125; &#125; &#125; &#125; &#125; &#125; return 0;&#125;void shift(char arr[], int m, int n) &#123; if (m &lt; n) &#123; char c = arr[n]; for (int i = n; i &gt; m; i--) arr[i] = arr[i-1]; arr[m] = c; &#125; else &#123; char c = arr[n]; for (int i = n; i &lt; m; i++) arr[i] = arr[i+1]; arr[m] = c; &#125; &#125;bool judge(char arr[], int n) &#123; int i, j; for(i = 0; i &lt; n-1 &amp;&amp; arr[i]==arr[i+1]; i++); if(i == n-1) return true; for(j = i+1; j &lt; n-1 &amp;&amp; arr[j]==arr[j+1]; j++); if(j == n-1) return true; else return false;&#125; 1结果虽然对了，但是我内心是崩溃的，有这么麻烦吗？算了，还是看看大神们是怎么做的。 大神操作： 大神说： 最终目标是将男孩移到最左边，或者将女孩移到最左边。 如果有B个男孩，则移到最左边的index分别为：0,1,2…B-1,所以所有index的和为（B-1）*B/2。一次遍历，计算目前男孩所在的index的和为sumB，则sumB减去上面的和就是所求的结果。 因此只要一次遍历，计算男孩所在的男孩的个数和男孩所在的index的和，求之差就行了。女孩同理。 最后求最小值。 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main(int argc, char *argv[])&#123; string s; cin&gt;&gt;s; int n = s.size(); int gNum, bNum, gSum, bSum; gNum = bNum = gSum = bSum = 0; for (int i = 0; i &lt; n; i ++) &#123; if (s[i] == &apos;G&apos;)&#123; gNum++; gSum += i; &#125; else &#123; bNum++; bSum += i; &#125; &#125; int ret1 = bSum - (bNum - 1) * bNum / 2; int ret2 = gSum - (gNum - 1) * gNum / 2; cout&lt;&lt;min(ret1, ret2)&lt;&lt;endl; return 0;&#125;","tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"},{"name":"网易","slug":"网易","permalink":"http://yoursite.com/tags/网易/"}]},{"title":"赶去公司","date":"2017-06-27T11:15:00.000Z","path":"2017/06/27/goToCompany/","text":"题目链接：网易2017春招笔试真题编程题集合第二题 12时间限制：1秒空间限制：32768K 终于到周末啦！小易走在市区的街道上准备找朋友聚会，突然服务器发来警报,小易需要立即回公司修复这个紧急bug。假设市区是一个无限大的区域，每条街道假设坐标是(X，Y)，小易当前在(0，0)街道，办公室在(gx,gy)街道上。小易周围有多个出租车打车点，小易赶去办公室有两种选择，一种就是走路去公司，另外一种就是走到一个出租车打车点，然后从打车点的位置坐出租车去公司。每次移动到相邻的街道(横向或者纵向)走路将会花费walkTime时间，打车将花费taxiTime时间。小易需要尽快赶到公司去，现在小易想知道他最快需要花费多少时间去公司。 输入描述： 输入数据包括五行: 第一行为周围出租车打车点的个数n(1 ≤ n ≤ 50) 第二行为每个出租车打车点的横坐标tX[i] (-10000 ≤ tX[i] ≤ 10000) 第三行为每个出租车打车点的纵坐标tY[i] (-10000 ≤ tY[i] ≤ 10000) 第四行为办公室坐标gx,gy(-10000 ≤ gx,gy ≤ 10000),以空格分隔 第五行为走路时间walkTime(1 ≤ walkTime ≤ 1000)和taxiTime(1 ≤ taxiTime ≤ 1000),以空格分隔 输出描述： 输出一个整数表示，小易最快能赶到办公室的时间 输入例子: 2-2 -20 -2-4 -215 3 输出例子: 42 我的思路:根据输入的例子画了一个坐标。①：起点到终点的距离是一定的，出租车花的时间比走路时间少，找出离起点最近的出租车坐标不就得了。1结论：walkTime有可能小于taxiTime的 ②：既然这样的话，分两种情况呗，walkTime &lt; taxiTime, 找出离起点最远的出租车坐标；walkTime &gt; taxiTime,找出离起点最近的出租车坐标；1结论：我是真蠢，当walkTime &lt; taxiTime时，直接走路就可以了，打的干嘛。 ③：那就这样分情况，walkTime &lt; taxiTime, 直接走路；walkTime &gt; taxiTime,找出离起点最近的出租车坐标；1结论：即使walkTime &gt; taxiTime, 如果出租车离起点很远的话，那也是不合算的。所以说走路到公司这种情况是一定要算的，那出租车那种情况怎么得到呢？ ④：起点和终点会构成一个长方形，出租车可能会在这个长方形，也有可能不在这个长方形中。要不分两种情况，一种是在长方形的出租车，另一种是长方形外的出租车。如果存在长方形内的出租车，那找长方形内最近的出租车一定是花时间最少的；如果不存在，那就找长方形外的出租车的最近点，然后在和走路的比较。123456789结论：卧槽，好麻烦。这样做应该可以做出来，但是也太绕了吧。后来我没有忍住，看了一下别人提交的代码，发现好少，但是具体思路没有看到。我就在想，是不是有别的思路呢？后来又仔细审了一下题目：一种就是走路去公司，另外一种就是走到一个出租车打车点，然后从打车点的位置坐出租车去公司。我想到了，这不就是两种情况吗？第一种是走路，第二种是找出租车然后再到公司。把第二种所有的情况的时间都算出来，不用纠结找最远的出租车还是最近的出租车，把起点到出租车再到公司的总时间算出来即可，然后找出最优解。第二种最优解再和第一种比较，最终得到结果。 反思：其实题目已经告诉了你解决方案，而我一直在纠结去哪里找出离起点最近的出租车坐标，关注的点歪了，而且歪的很离谱。 核心:这道题其实就是找出最小值而已。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354我的代码：#include &lt;iostream&gt;using namespace std;#include&lt;math.h&gt;#include&lt;limits.h&gt;#define taxiNumber 50int minvalue = INT_MAX;int main(int argc, char *argv[])&#123; int n, t[taxiNumber][taxiNumber]; int startPoint[1][2] = &#123;0,0&#125;, endPoint[1][2]; int walkTime, taxiTime; cin&gt;&gt;n; for(int i = 0; i &lt; n; i++) &#123; int tX; cin&gt;&gt;tX; t[0][i] = tX; &#125; for(int i = 0; i &lt; n; i++) &#123; int tY; cin&gt;&gt;tY; t[1][i] = tY; &#125; cin&gt;&gt;endPoint[0][0]&gt;&gt;endPoint[0][1]; cin&gt;&gt;walkTime&gt;&gt;taxiTime; int xDistance = abs(endPoint[0][0] - startPoint[0][0]); int yDistance = abs(endPoint[0][1] - startPoint[0][1]); int pureWalkTime = (xDistance + yDistance) * walkTime; for(int i = 0; i &lt; n; i++) &#123; xDistance = abs(t[0][i] - startPoint[0][0]); yDistance = abs(t[1][i] - startPoint[0][1]); int walk = (xDistance + yDistance) * walkTime; xDistance = abs(endPoint[0][0] - t[0][i]); yDistance = abs(endPoint[0][1] - t[1][i]); int taxi = (xDistance + yDistance) * taxiTime; int time = walk + taxi; if(time &lt; minvalue) minvalue = time; &#125; if(minvalue &lt; pureWalkTime) cout&lt;&lt;minvalue&lt;&lt;endl; else cout&lt;&lt;pureWalkTime&lt;&lt;endl; return 0;&#125; 1234567891011121314151617181920212223优秀代码：#include&lt;iostream&gt;#include&lt;cmath&gt; using namespace std; int n,tx[55],ty[55],gx,gy,walkTime,taxiTime;int main()&#123; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) cin&gt;&gt;tx[i]; for(int i=0;i&lt;n;i++) cin&gt;&gt;ty[i]; cin&gt;&gt;gx&gt;&gt;gy; cin&gt;&gt;walkTime&gt;&gt;taxiTime; int ans=(abs(gx-0)+abs(gy-0))*walkTime; for(int i=0;i&lt;n;i++)&#123; int res=(abs(tx[i]-0)+abs(ty[i]-0))*walkTime; res+=(abs(tx[i]-gx)+abs(ty[i]-gy))*taxiTime; ans=min(ans,res); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;","tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"},{"name":"网易","slug":"网易","permalink":"http://yoursite.com/tags/网易/"},{"name":"最小值","slug":"最小值","permalink":"http://yoursite.com/tags/最小值/"}]},{"title":"双核处理","date":"2017-06-26T07:07:00.000Z","path":"2017/06/26/dualCore/","text":"题目链接：网易2017春招笔试真题编程题集合第一题121. 时间限制：1秒2. 空间限制：32768K 一种双核CPU的两个核能够同时的处理任务，现在有n个已知数据量的任务需要交给CPU处理，假设已知CPU的每个核1秒可以处理1kb，每个核同时只能处理一项任务。n个任务可以按照任意顺序放入CPU进行处理，现在需要设计一个方案让CPU处理完这批任务所需的时间最少，求这个最小的时间。 输入描述: 输入包括两行：第一行为整数n(1 ≤ n ≤ 50)第二行为n个整数length[i] (1024 ≤ length[i] ≤ 4194304)，表示每个任务的长度为length[i]kb，每个数均为1024的倍数。 输出描述: 输出一个整数，表示最少需要处理的时间 输入例子: 5 3072 3072 7168 3072 1024 输出例子: 9216 参考内容： 动态规划解决01背包问题 “詆調壹點”的回答下面的“HelloHello233”的回答 我的思路：把这些任务分成两组，然后选择两组时间差最小的那一次分组，然后再取时间比较大的一组。 怎么才能把所有的分组找出来呢？头脑中就想出了“全排列”的概念。好像只是有点点联系，没有必要的联系。 于是我开始思考所有的分组，假如有5个任务，那么只考虑一组的任务分配，另一组就是剩下的任务数。所以第一组的分配为：1，2，第一组如果分配3和4的话，就重复了，再者说，$ C_5^1=C_5^4，C_5^2=C_5^3 $，所以第二组的分配对应为：4，3。假如一共有6个任务，那么第一组的分配为：1,2,3，第二组的分配为：5,4,3。所以我想到了以前做的概率题，经常用到的一个公式就是：$ C_m^n $。 假如有5个任务，那么所有的分配情况就是：$ C_5^1 和 C_5^2$。假如有6个任务，那么所有的分配情况就是：$ C_6^1、 C_6^2 和 C_6^3 $。所以就发现了规律了，假如有n个任务，那么所有的分组情况就是$C_n^1 C_n^2 C_n^3\\ldots C_n^\\frac n2$。 想了想，好想运算量非常非常大。算了，不管了，先把它搞出来吧。 组合部分：关于$ C_m^n $，我应该怎么把所有的情况找出来呢？我就想起来以前做的8皇后问题，用的回溯法，然后就开始试着写代码了。 假如组合为：$ C_6^3 $，结果是：123 124 125 126 134 135 136 145 146 156234 235 236 245 246 256345 346 356456 第一个数字的范围为：1~m-n+1，第二个数字的范围为：2~m-n+2，$ \\ldots$，第n-1个数字的范围为：n-1~m-1，第n个数字的范围为：n~m。 在排列组合的时候，第n个数字的最小值永远比前一个数字大1 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include&lt;limits.h&gt;using namespace std;#define MAX 51int combinArr[MAX];int main(int argc, char *argv[])&#123; void combine(int n, int m, int num); combinArr[0] = 0; combine(2,5,1); return 0;&#125;void combine(int n, int m, int num)&#123; if(num == n+1) &#123; for(int i = 1; i &lt;= n; i++) cout&lt;&lt;combinArr[i]; cout&lt;&lt;endl; &#125;else &#123; for(int i = combinArr[num-1]+1; i &lt;= (m-n+num); i++) &#123; combinArr[num] = i; combine(n, m, num+1); &#125; &#125;&#125; 双核处理 - 我的思路所有的排列组合都找出来了，找出一次组合之后，比如对于$ C_6^3 $，找出123之后，把123所对应的任务数相加，然后再让总任务数减去组合里面的任务数，然后就可以得出两者的差距，然后找出最小的差距即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include&lt;limits.h&gt;#include&lt;math.h&gt;using namespace std;#define MAX 51int a[MAX], b[MAX];// a用来记录组合的数组; b用来记录输入的任务数 int minvalue = INT_MAX;// 两组任务的差距 int out, sum=0;// out用来记录结果; sum用来记录任务的综合 int main(int argc, char *argv[])&#123; void pai(int n, int m, int num);// 组合部分;m和n分别为组合的上下角码;num为1 void compare(int a[], int n, int b[]);//找出差距最小的那一次组合;a为组合;n为a的个数;b为任务数据 a[0] = 0;//a[0]为1主要为了组合部分的第一个数字 int n ; cin&gt;&gt;n; for(int i = 1; i &lt;= n; i++)&#123; //录入任务数 并求出sum int sc; cin&gt;&gt;sc; b[i] = sc; sum += b[i]; &#125; for(int i =1; i &lt;= n/2; i++) // 根据任务的个数，来进行所需要的组合 pai(i, n, 1); cout&lt;&lt;out&lt;&lt;endl;// 输出结果 return 0;&#125;void pai(int n, int m, int num)&#123; void compare(int a[], int m, int b[]); if(num == n+1) &#123; compare(a,n,b); //每一次的组合就要进行一次比较 &#125;else &#123; for(int i = a[num-1]+1; i &lt;= (m-n+num); i++) &#123; a[num] = i; pai(n, m, num+1); &#125; &#125;&#125;void compare(int a[], int n, int b[])&#123; int i, j, num1=0, num2=0; for(i = 1; i&lt;= n; i++) //找出其中一组的任务数 num1 += b[a[i]]; num2 = sum - num1;//另一组的任务数 if(abs(num1-num2) &lt; minvalue)&#123; //更改最小的差距 minvalue = abs(num1-num2); if(num1 &gt; num2) //找出最终结果 out = num1; else out = num2; &#125; &#125; 1结果为：运行超时 01背包问题由于运行超时，然后看了别人的答案，就开始探索01背包问题。其实之前上课的时候学过这个内，当时可能在睡觉，或者在做别的事情，结果现在只是记住了这个标题。 问题描述： 有n 个物品，它们有各自的重量和价值，现有给定容量的背包，如何让背包里装入的物品具有最大的价值总和？ 核心概述： 设$V[i,j]$为前$i$个物品放到背包容量为$j$的背包中为最优解，设$v_i$为第$i$个物品的价值，$w_j$为第$i$个物品的重量。对于$V[i,j]$。(1) 第$i$个物品放不到背包里，则最优解为$V[i-1,j]$(2) 第$i$个物品可以放进背包里，则最优解为前$i-1$个物品的最优解$V[i-1,j-w_i]$与第$i$个物品价值的和，或者就是前$i-1$个物品的最优解，这里取两个中的最大值，即$V[i,j]=Max \\lbrace V[i-1,j-w_i]+v_i,V[i-1,j] \\rbrace$ 核心公式： $V[i,j] = V[i-1,j], w_i &gt; j$$V[i,j] = Max \\lbrace V[i-1,j-w_i]+v_i,V[i-1,j] \\rbrace , w_i \\leq j$当$j \\geq 0$时,$V[0,j]=0$;当$i \\geq 0$时，$V[i,0]$=0 情景再现： 背包容量：5 物品序号 重量 价值 1 2 12￥ 2 1 10￥ 3 3 20￥ 4 2 15￥ 自己根据公式推导一下，就会得出以下的表格。 $i/j$ 0 1 2 3 4 5 0 0 0 0 0 0 0 1 0 0 12 12 12 12 2 0 10 12 22 22 22 3 0 10 12 22 30 32 4 0 10 15 25 30 37 1234567优化前伪代码：for i=1...number for j=1...weight w[i] &gt; j v[i][j] = v[i-1][j] w[i] &lt;= j v[i][j] = max&#123; v[i-1, j-w[i]] + v[i], v[i-1,j] &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;using namespace std;#define weight 5 //背包容量 #define goodsNum 4 //物品个数 int main(int argc, char *argv[])&#123; int goods[goodsNum][2] = &#123;&#123;2, 12&#125;, &#123;1, 10&#125;, &#123;3, 20&#125;, &#123;2, 15&#125;&#125;;//物品的重量和价值 int a[goodsNum+1][weight+1];//记录V[i,j] for(int i=0;i&lt;=weight;i++) //当i&gt;=0时,V[0,i]=0; a[0][i]=0; for(int i=0;i&lt;=goodsNum;i++) //当i&gt;=0时,V[i,0]=0; a[i][0]=0; for(int i = 1;i &lt;= goodsNum; i++)&#123; for(int j = 1; j &lt;= weight; j++)&#123; int goodWeight = goods[i-1][0]; int goodValue = goods[i-1][1]; if(goodWeight &gt; j) &#123; a[i][j] = a[i-1][j]; &#125; else &#123; int putin = a[i-1][j-goodWeight] + goodValue; if(a[i-1][j] &lt; putin) a[i][j] = putin; else a[i][j] = a[i-1][j]; &#125; &#125; &#125; //输出V[i,j] for(int i =0;i&lt;=goodsNum;i++)&#123; for(int j=0; j&lt;=weight; j++) cout&lt;&lt;a[i][j]&lt;&lt;&apos; &apos;; cout&lt;&lt;endl; &#125; //找到背包里包含的物品 int find = weight; int hang = goodsNum; while(find &gt; 0)&#123; for(int i=hang;i&gt;=1;i--)&#123; if(a[i][find] != a[i-1][find])&#123; cout&lt;&lt;i&lt;&lt;&apos; &apos;; hang = i-1; find = find - goods[i-1][0]; break; &#125; &#125; &#125; cout&lt;&lt;endl;&#125; 背包优化： 其实，计算第$i$行的最优值时，只会用到第$i-1$行的数据，用不到$i-2$行的数据，所以可以把二维数组缩减为以为一维数组。但是这样的话，就找不到背包里所包含的物品。 核心公式： 为了混淆，这里用$B$代表一维数组，$B[j]$ 是容量为$j$的最优值，$w_i$代表第$i$个物品的容量，$v_i$代表第$i$个物品的价值。最优值$B[j]=Max \\lbrace B[j-w_i]+v_i,B[j] \\rbrace$ &nbsp;&nbsp;&nbsp;&nbsp;仅当$w_i &lt;= j$ 12345伪代码：for i=1...number for j=weitht...1 w[i] &lt;= j B[j] = max&#123; B[j-w[i]] + v[i], B[j] &#125; 1234注意：j是递减的，为什么呢？如果j是递增的话，会重复的放入某一件物品。自己写写一位数组的变化就知道了。 一维数组的变化( j递减 )： i B[5] B[4] B[3] B[2] B[1] B[0] i=1 12 12 12 12 0 0 i=2 22 22 22 12 10 0 i=3 32 30 22 12 10 0 i=4 37 30 25 15 10 0 有没有发现这个一维数组的每一行和二维数组的每一行是一样的。 一维数组的变化( j递增 )： i B[0] B[1] B[2] B[3] B[4] B[5] i=1 0 0 12 12 24 24 i=2 0 10 20 30 40 50 i=3 0 10 20 30 40 50 i=4 0 10 20 30 40 50 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;#define weight 5#define goodsNum 4int main(int argc, char *argv[])&#123; int goods[goodsNum][2] = &#123;&#123;2, 12&#125;, &#123;1, 10&#125;, &#123;3, 20&#125;, &#123;2, 15&#125;&#125;; int a[weight+1]; for(int i=0;i&lt;=weight;i++) a[i]=0; for(int i =0;i&lt;goodsNum;i++)&#123; for(int j=weight; j&gt;=1; j--)&#123; int goodWeight = goods[i][0]; int goodValue = goods[i][1]; int input = goodValue+a[j-goodWeight]; if(goodWeight &lt;= j &amp;&amp; input &gt; a[j]) a[j] = input; &#125; for(int i=weight;i&gt;=0;i--) cout&lt;&lt;a[i]&lt;&lt;&apos; &apos;; cout&lt;&lt;endl; &#125;&#125; 双核处理 - 01背包那人说，总任务数除以2就是背包的容量，然后每个任务数就是每个物品的容量。 一开始，我在疑惑：01背包问题是背包的容量大于装入物品的容量，但是这个双核处理问题是计算大于背包容量的最小容量，我一直在纠结这个问题，这个应该怎么转化为背包问题呢？ 后来，我想通了。任务分成两组，背包的容量是总任务除以2，其中一组大于背包容量，另外一组是小于背包容量，也有可能两组相等。我们求的是大于或等于背包容量的那一组。你只需要把其中一组计算出来，然后用总数一减不就得出来了。所以你计算小于背包容量的那一组，这样就可以转化为01背包问题了。 123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;#define MAX 102400#define NUM 50int main(int argc, char *argv[])&#123; int n, task[NUM], sum = 0; cin&gt;&gt;n; for(int i = 0; i &lt; n; i++) &#123; cin&gt;&gt;task[i]; task[i] /= 1024; sum += task[i]; &#125; int packWeight = sum / 2; int arr[MAX] = &#123;0&#125;; for(int i = 0; i &lt; n; i++) &#123; for (int j = packWeight; j &gt;= 1; j--) &#123; int taskWeight = task[i]; int input = taskWeight + arr[j-taskWeight]; if(taskWeight &lt;= j &amp;&amp; input &gt; arr[j]) arr[j] = input; &#125; &#125; int maxTaskTime = (sum - arr[packWeight]) * 1024; cout&lt;&lt;maxTaskTime&lt;&lt;endl; return 0;&#125;","tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"},{"name":"网易","slug":"网易","permalink":"http://yoursite.com/tags/网易/"},{"name":"01背包","slug":"01背包","permalink":"http://yoursite.com/tags/01背包/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"}]},{"title":"周杰伦音乐专辑封面","date":"2016-08-07T05:36:00.000Z","path":"2016/08/07/jay/","text":"周杰伦（Jay Chou），1979年1月18日出生于台湾省新北市，中国台湾流行乐男歌手、音乐人、演员、导演、编剧、监制、商人。 12342000年《Jay》;2001年《范特西》;2002年《八度空间》;2003年《叶惠美》;2004年《七里香》;2005年《十一月的肖邦》;2006年《依然范特西》;2007年《我很忙》;2008年《魔杰座》;2010年《跨时代》;2011年《惊叹号》;2012年《十二新作》;2014年《哎呦，不错哦》;2016年《周杰伦的床边故事》 《Jay》发行日期：2000-11-13 1234567891011专辑曲目： 1.可爱女人 2.完美主义 3.星晴 4.娘子 5.斗牛 6.黑色幽默 7.伊斯坦堡 8.印第安老斑鸠 9.龙卷风 10.反方向的钟 《范特西》，发行日期：2001-09-20 1234567891011专辑曲目： 1.爱在西元前 2.爸我回来了 3.简单爱 4.忍者 5.开不了口 6.上海一九四三 7.对不起 8.威廉古堡 9.双截棍 10.安静 《八度空间》，发行日期：2002-07-18 1234567891011专辑曲目： 1.半兽人 2.半岛铁盒 3.暗号 4.龙拳 5.火车叨位去（台） 6.分裂 7.爷爷泡的茶 8.回家过去 9.米兰的小铁匠 10.最后的战役 《叶惠美》，发行日期：2003-07-31 123456789101112专辑曲目： 1.以父之名 2.懦夫 3.晴天 4.三年二班 5.东风破 6.你听得到 7.同一种调调 8.她的睫毛 9.爱情悬崖 10.梯田 11.双刀 《七里香》，发行日期：2004-08-03 1234567891011专辑曲目： 1.我的地盘 2.七里香 3.借口 4.外婆 5.将军 6.搁浅 7.乱舞春秋 8.困兽之斗 9.园游会 10.止战之殇 《11月的萧邦》，发行日期：2005-11-01 12345678910111213专辑曲目： 1.夜曲 2.蓝色风暴(百事可乐广告歌) 3.发如雪 4.黑色毛衣 5.四面楚歌 6.枫 7.浪漫手机 8.逆鳞 9.麦芽糖 10.珊瑚海 11.漂移 12.一路向北 《依然范特西》，发行日期：2006-09-01 1234567891011专辑曲目： 1.夜的第七章 2.听妈妈的话 3.千里之外 4.本草纲目 5.退后 6.红模仿 7.心雨 8.白色风车 9.迷迭香 10.菊花台 《我很忙》，发行日期：2007-11-02 1234567891011专辑曲目： 1.牛仔很忙 2.彩虹 3.青花瓷 4.阳光宅男 5.蒲公英的约定 6.无双 7.我不配 8.扯 9.甜甜的 10.最长的电影 《魔杰座》，发行日期：2008-10-15 123456789101112专辑曲目： 1.龙战骑士 2.给我一首歌的时间 3.蛇舞 4.花海 5.魔术先生 6.说好的幸福呢 7.兰亭序 8.流浪诗人 9.时光机 10.乔克叔叔 11.稻香 《跨时代》，发行日期：2010-05-18 123456789101112专辑曲目： 1.跨时代 2.说了再见 3.烟花易冷 4.免费教学录影带 5.好久不见 6.雨下一整晚 7.嘻哈空姐 8.我落泪，情绪零碎 9.爱的等飞行日记 10.自导自演 11.超人不会飞 《惊叹号》，发行日期：2011-11-11 123456789101112专辑曲目： 1.惊叹号 2.皮影戏 3.Mine Mine 4.你好吗 5.迷魂曲 6.超跑女神 7.世界未末日 8.水手怕水 9.琴伤 10.公主病 11.疗伤烧肉粽 《12新作》，发行日期：2012-12-28 12345678910111213专辑曲目： 1.四季列车 2.手语 3.公公偏头痛 4.明明就 5.傻笑 6.比较大的大提琴 7.爱你没差 8.红尘客栈 9.梦想启动 10.大笨钟 11.哪里都是你 12.乌克丽丽 《哎呦，不错哦》，发行日期：2014-12-26 12345678910111213专辑曲目： 1.阳明山 2.窃爱 3.算什么男人 4.天涯过客 5.怎么了 6.一口气全念对 7.我要夏天 8.手写的从前 9.鞋子特大号 10.听爸爸的话 11.美人鱼 12.听见下雨的声音 《周杰伦的床边故事》，发行日期：2016-06-24 1234567891011专辑曲目： 1.床边故事2.说走就走3.一点点4.前世情人5.英雄6.不该7.土耳其冰淇淋8.告白气球9.Now You See Me10.爱情废柴","tags":[{"name":"周杰伦","slug":"周杰伦","permalink":"http://yoursite.com/tags/周杰伦/"},{"name":"专辑封面","slug":"专辑封面","permalink":"http://yoursite.com/tags/专辑封面/"}]}]