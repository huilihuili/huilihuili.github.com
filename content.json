[{"title":"双核处理","date":"2017-06-26T07:07:00.000Z","path":"2017/06/26/dualCore/","text":"题目链接：网易2017春招笔试真题编程题集合第一题121. 时间限制：1秒2. 空间限制：32768K 一种双核CPU的两个核能够同时的处理任务，现在有n个已知数据量的任务需要交给CPU处理，假设已知CPU的每个核1秒可以处理1kb，每个核同时只能处理一项任务。n个任务可以按照任意顺序放入CPU进行处理，现在需要设计一个方案让CPU处理完这批任务所需的时间最少，求这个最小的时间。 输入描述: 输入包括两行：第一行为整数n(1 ≤ n ≤ 50)第二行为n个整数lengthi，表示每个任务的长度为length[i]kb，每个数均为1024的倍数。 输出描述: 输出一个整数，表示最少需要处理的时间 输入例子: 5 3072 3072 7168 3072 1024 输出例子: 9216 参考内容： 动态规划解决01背包问题 “詆調壹點”的回答下面的“HelloHello233”的回答 我的思路：把这些任务分成两组，然后选择两组时间差最小的那一次分组，然后再取时间比较大的一组。 怎么才能把所有的分组找出来呢？头脑中就想出了“全排列”的概念。好像只是有点点联系，没有必要的联系。 于是我开始思考所有的分组，假如有5个任务，那么只考虑一组的任务分配，另一组就是剩下的任务数。所以第一组的分配为：1，2，第一组如果分配3和4的话，就重复了，再者说，$ C_5^1=C_5^4，C_5^2=C_5^3 $，所以第二组的分配对应为：4，3。假如一共有6个任务，那么第一组的分配为：1,2,3，第二组的分配为：5,4,3。所以我想到了以前做的概率题，经常用到的一个公式就是：$ C_m^n $。 假如有5个任务，那么所有的分配情况就是：$ C_5^1 和 C_5^2$。假如有6个任务，那么所有的分配情况就是：$ C_6^1、 C_6^2 和 C_6^3 $。所以就发现了规律了，假如有n个任务，那么所有的分组情况就是$C_n^1 C_n^2 C_n^3\\ldots C_n^\\frac n2$。 想了想，好想运算量非常非常大。算了，不管了，先把它搞出来吧。 组合部分：关于$ C_m^n $，我应该怎么把所有的情况找出来呢？我就想起来以前做的8皇后问题，用的回溯法，然后就开始试着写代码了。 假如组合为：$ C_6^3 $，结果是：123 124 125 126 134 135 136 145 146 156234 235 236 245 246 256345 346 356456 第一个数字的范围为：1~m-n+1，第二个数字的范围为：2~m-n+2，$ \\ldots$，第n-1个数字的范围为：n-1~m-1，第n个数字的范围为：n~m。 在排列组合的时候，第n个数字的最小值永远比前一个数字大1 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include&lt;limits.h&gt;using namespace std;#define MAX 51int combinArr[MAX];int main(int argc, char *argv[])&#123; void combine(int n, int m, int num); combinArr[0] = 0; combine(2,5,1); return 0;&#125;void combine(int n, int m, int num)&#123; if(num == n+1) &#123; for(int i = 1; i &lt;= n; i++) cout&lt;&lt;combinArr[i]; cout&lt;&lt;endl; &#125;else &#123; for(int i = combinArr[num-1]+1; i &lt;= (m-n+num); i++) &#123; combinArr[num] = i; combine(n, m, num+1); &#125; &#125;&#125; 双核处理 - 我的思路所有的排列组合都找出来了，找出一次组合之后，比如对于$ C_6^3 $，找出123之后，把123所对应的任务数相加，然后再让总任务数减去组合里面的任务数，然后就可以得出两者的差距，然后找出最小的差距即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include&lt;limits.h&gt;#include&lt;math.h&gt;using namespace std;#define MAX 51int a[MAX], b[MAX];// a用来记录组合的数组; b用来记录输入的任务数 int minvalue = INT_MAX;// 两组任务的差距 int out, sum=0;// out用来记录结果; sum用来记录任务的综合 int main(int argc, char *argv[])&#123; void pai(int n, int m, int num);// 组合部分;m和n分别为组合的上下角码;num为1 void compare(int a[], int n, int b[]);//找出差距最小的那一次组合;a为组合;n为a的个数;b为任务数据 a[0] = 0;//a[0]为1主要为了组合部分的第一个数字 int n ; cin&gt;&gt;n; for(int i = 1; i &lt;= n; i++)&#123; //录入任务数 并求出sum int sc; cin&gt;&gt;sc; b[i] = sc; sum += b[i]; &#125; for(int i =1; i &lt;= n/2; i++) // 根据任务的个数，来进行所需要的组合 pai(i, n, 1); cout&lt;&lt;out&lt;&lt;endl;// 输出结果 return 0;&#125;void pai(int n, int m, int num)&#123; void compare(int a[], int m, int b[]); if(num == n+1) &#123; compare(a,n,b); //每一次的组合就要进行一次比较 &#125;else &#123; for(int i = a[num-1]+1; i &lt;= (m-n+num); i++) &#123; a[num] = i; pai(n, m, num+1); &#125; &#125;&#125;void compare(int a[], int n, int b[])&#123; int i, j, num1=0, num2=0; for(i = 1; i&lt;= n; i++) //找出其中一组的任务数 num1 += b[a[i]]; num2 = sum - num1;//另一组的任务数 if(abs(num1-num2) &lt; minvalue)&#123; //更改最小的差距 minvalue = abs(num1-num2); if(num1 &gt; num2) //找出最终结果 out = num1; else out = num2; &#125; &#125; 1结果为：运行超时 01背包问题由于运行超时，然后看了别人的答案，就开始探索01背包问题。其实之前上课的时候学过这个内，当时可能在睡觉，或者在做别的事情，结果现在只是记住了这个标题。 问题描述： 有n 个物品，它们有各自的重量和价值，现有给定容量的背包，如何让背包里装入的物品具有最大的价值总和？ 核心概述： 设$V[i,j]$为前$i$个物品放到背包容量为$j$的背包中为最优解，设$v_i$为第$i$个物品的价值，$w_j$为第$i$个物品的重量。对于$V[i,j]$。(1) 第$i$个物品放不到背包里，则最优解为$V[i-1,j]$(2) 第$i$个物品可以放进背包里，则最优解为前$i-1$个物品的最优解$V[i-1,j-w_i]$与第$i$个物品价值的和，或者就是前$i-1$个物品的最优解，这里取两个中的最大值，即$V[i,j]=Max{V[i-1,j-w_i]+v_i,V[i-1,j]}$ 核心公式： $V[i,j] = V[i-1,j], w_i &gt; j $$V[i,j] = Max(V[i-1,j-w_i]+v_i,V[i-1,j]), w_i &lt;= j$当$j&gt;=0$时,$V[0,j]=0$;当$i&gt;=0$时，$V[i,0]$=0 情景再现： 背包容量：5 物品序号 重量 价值 1 2 12￥ 2 1 10￥ 3 3 20￥ 4 2 15￥ 自己根据公式推导一下，就会得出以下的表格。 $i/j$ 0 1 2 3 4 5 0 0 0 0 0 0 0 1 0 0 12 12 12 12 2 0 10 12 22 22 22 3 0 10 12 22 30 32 4 0 10 15 25 30 37 1234567优化前伪代码：for i=1...number for j=1...weight w[i] &gt; j v[i][j] = v[i-1][j] w[i] &lt;= j v[i][j] = max&#123; v[i-1, j-w[i]] + v[i], v[i-1,j] &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;using namespace std;#define weight 5 //背包容量 #define goodsNum 4 //物品个数 int main(int argc, char *argv[])&#123; int goods[goodsNum][2] = &#123;&#123;2, 12&#125;, &#123;1, 10&#125;, &#123;3, 20&#125;, &#123;2, 15&#125;&#125;;//物品的重量和价值 int a[goodsNum+1][weight+1];//记录V[i,j] for(int i=0;i&lt;=weight;i++) //当i&gt;=0时,V[0,i]=0; a[0][i]=0; for(int i=0;i&lt;=goodsNum;i++) //当i&gt;=0时,V[i,0]=0; a[i][0]=0; for(int i = 1;i &lt;= goodsNum; i++)&#123; for(int j = 1; j &lt;= weight; j++)&#123; int goodWeight = goods[i-1][0]; int goodValue = goods[i-1][1]; if(goodWeight &gt; j) &#123; a[i][j] = a[i-1][j]; &#125; else &#123; int putin = a[i-1][j-goodWeight] + goodValue; if(a[i-1][j] &lt; putin) a[i][j] = putin; else a[i][j] = a[i-1][j]; &#125; &#125; &#125; //输出V[i,j] for(int i =0;i&lt;=goodsNum;i++)&#123; for(int j=0; j&lt;=weight; j++) cout&lt;&lt;a[i][j]&lt;&lt;&apos; &apos;; cout&lt;&lt;endl; &#125; //找到背包里包含的物品 int find = weight; int hang = goodsNum; while(find &gt; 0)&#123; for(int i=hang;i&gt;=1;i--)&#123; if(a[i][find] != a[i-1][find])&#123; cout&lt;&lt;i&lt;&lt;&apos; &apos;; hang = i-1; find = find - goods[i-1][0]; break; &#125; &#125; &#125; cout&lt;&lt;endl;&#125; 背包优化： 其实，计算第$i$行的最优值时，只会用到第$i-1$行的数据，用不到$i-2$行的数据，所以可以把二维数组缩减为以为一维数组。但是这样的话，就找不到背包里所包含的物品。 核心公式： 为了混淆，这里用$B$代表一维数组，$B[j]$ 是容量为$j$的最优值，$w_i$代表第$i$个物品的容量，$v_i$代表第$i$个物品的价值。最优值$B[j]=Max(B[j-w_i]+v_i,B[j])$ &nbsp;&nbsp;&nbsp;&nbsp;仅当$w_i &lt;= j$ 12345伪代码：for i=1...number for j=weitht...1 w[i] &lt;= j B[j] = max&#123; B[j-w[i]] + v[i], B[j] &#125; 1234注意：j是递减的，为什么呢？如果j是递增的话，会重复的放入某一件物品。自己写写一位数组的变化就知道了。 一维数组的变化( j递减 )： i B[5] B[4] B[3] B[2] B[1] B[0] i=1 12 12 12 12 0 0 i=2 22 22 22 12 10 0 i=3 32 30 22 12 10 0 i=4 37 30 25 15 10 0 有没有发现这个一维数组的每一行和二维数组的每一行是一样的。 一维数组的变化( j递增 )： i B[0] B[1] B[2] B[3] B[4] B[5] i=1 0 0 12 12 24 24 i=2 0 10 20 30 40 50 i=3 0 10 20 30 40 50 i=4 0 10 20 30 40 50 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;#define weight 5#define goodsNum 4int main(int argc, char *argv[])&#123; int goods[goodsNum][2] = &#123;&#123;2, 12&#125;, &#123;1, 10&#125;, &#123;3, 20&#125;, &#123;2, 15&#125;&#125;; int a[weight+1]; for(int i=0;i&lt;=weight;i++) a[i]=0; for(int i =0;i&lt;goodsNum;i++)&#123; for(int j=weight; j&gt;=1; j--)&#123; int goodWeight = goods[i][0]; int goodValue = goods[i][1]; int input = goodValue+a[j-goodWeight]; if(goodWeight &lt;= j &amp;&amp; input &gt; a[j]) a[j] = input; &#125; for(int i=weight;i&gt;=0;i--) cout&lt;&lt;a[i]&lt;&lt;&apos; &apos;; cout&lt;&lt;endl; &#125;&#125; 双核处理 - 01背包那人说，总任务数除以2就是背包的容量，然后每个任务数就是每个物品的容量。 一开始，我在疑惑：01背包问题是背包的容量大于装入物品的容量，但是这个双核处理问题是计算大于背包容量的最小容量，我一直在纠结这个问题，这个应该怎么转化为背包问题呢？ 后来，我想通了。任务分成两组，背包的容量是总任务除以2，其中一组大于背包容量，另外一组是小于背包容量，也有可能两组相等。我们求的是大于或等于背包容量的那一组。你只需要把其中一组计算出来，然后用总数一减不就得出来了。所以你计算小于背包容量的那一组，这样就可以转化为01背包问题了。 123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;#define MAX 102400#define NUM 50int main(int argc, char *argv[])&#123; int n, task[NUM], sum = 0; cin&gt;&gt;n; for(int i = 0; i &lt; n; i++) &#123; cin&gt;&gt;task[i]; task[i] /= 1024; sum += task[i]; &#125; int packWeight = sum / 2; int arr[MAX] = &#123;0&#125;; for(int i = 0; i &lt; n; i++) &#123; for (int j = packWeight; j &gt;= 1; j--) &#123; int taskWeight = task[i]; int input = taskWeight + arr[j-taskWeight]; if(taskWeight &lt;= j &amp;&amp; input &gt; arr[j]) arr[j] = input; &#125; &#125; int maxTaskTime = (sum - arr[packWeight]) * 1024; cout&lt;&lt;maxTaskTime&lt;&lt;endl; return 0;&#125;","tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"},{"name":"网易","slug":"网易","permalink":"http://yoursite.com/tags/网易/"},{"name":"01背包","slug":"01背包","permalink":"http://yoursite.com/tags/01背包/"}]},{"title":"周杰伦音乐专辑封面","date":"2016-08-07T05:36:00.000Z","path":"2016/08/07/jay/","text":"周杰伦（Jay Chou），1979年1月18日出生于台湾省新北市，中国台湾流行乐男歌手、音乐人、演员、导演、编剧、监制、商人。 12342000年《Jay》;2001年《范特西》;2002年《八度空间》;2003年《叶惠美》;2004年《七里香》;2005年《十一月的肖邦》;2006年《依然范特西》;2007年《我很忙》;2008年《魔杰座》;2010年《跨时代》;2011年《惊叹号》;2012年《十二新作》;2014年《哎呦，不错哦》;2016年《周杰伦的床边故事》 《Jay》发行日期：2000-11-13 1234567891011专辑曲目： 1.可爱女人 2.完美主义 3.星晴 4.娘子 5.斗牛 6.黑色幽默 7.伊斯坦堡 8.印第安老斑鸠 9.龙卷风 10.反方向的钟 《范特西》，发行日期：2001-09-20 1234567891011专辑曲目： 1.爱在西元前 2.爸我回来了 3.简单爱 4.忍者 5.开不了口 6.上海一九四三 7.对不起 8.威廉古堡 9.双截棍 10.安静 《八度空间》，发行日期：2002-07-18 1234567891011专辑曲目： 1.半兽人 2.半岛铁盒 3.暗号 4.龙拳 5.火车叨位去（台） 6.分裂 7.爷爷泡的茶 8.回家过去 9.米兰的小铁匠 10.最后的战役 《叶惠美》，发行日期：2003-07-31 123456789101112专辑曲目： 1.以父之名 2.懦夫 3.晴天 4.三年二班 5.东风破 6.你听得到 7.同一种调调 8.她的睫毛 9.爱情悬崖 10.梯田 11.双刀 《七里香》，发行日期：2004-08-03 1234567891011专辑曲目： 1.我的地盘 2.七里香 3.借口 4.外婆 5.将军 6.搁浅 7.乱舞春秋 8.困兽之斗 9.园游会 10.止战之殇 《11月的萧邦》，发行日期：2005-11-01 12345678910111213专辑曲目： 1.夜曲 2.蓝色风暴(百事可乐广告歌) 3.发如雪 4.黑色毛衣 5.四面楚歌 6.枫 7.浪漫手机 8.逆鳞 9.麦芽糖 10.珊瑚海 11.漂移 12.一路向北 《依然范特西》，发行日期：2006-09-01 1234567891011专辑曲目： 1.夜的第七章 2.听妈妈的话 3.千里之外 4.本草纲目 5.退后 6.红模仿 7.心雨 8.白色风车 9.迷迭香 10.菊花台 《我很忙》，发行日期：2007-11-02 1234567891011专辑曲目： 1.牛仔很忙 2.彩虹 3.青花瓷 4.阳光宅男 5.蒲公英的约定 6.无双 7.我不配 8.扯 9.甜甜的 10.最长的电影 《魔杰座》，发行日期：2008-10-15 123456789101112专辑曲目： 1.龙战骑士 2.给我一首歌的时间 3.蛇舞 4.花海 5.魔术先生 6.说好的幸福呢 7.兰亭序 8.流浪诗人 9.时光机 10.乔克叔叔 11.稻香 《跨时代》，发行日期：2010-05-18 123456789101112专辑曲目： 1.跨时代 2.说了再见 3.烟花易冷 4.免费教学录影带 5.好久不见 6.雨下一整晚 7.嘻哈空姐 8.我落泪，情绪零碎 9.爱的等飞行日记 10.自导自演 11.超人不会飞 《惊叹号》，发行日期：2011-11-11 123456789101112专辑曲目： 1.惊叹号 2.皮影戏 3.Mine Mine 4.你好吗 5.迷魂曲 6.超跑女神 7.世界未末日 8.水手怕水 9.琴伤 10.公主病 11.疗伤烧肉粽 《12新作》，发行日期：2012-12-28 12345678910111213专辑曲目： 1.四季列车 2.手语 3.公公偏头痛 4.明明就 5.傻笑 6.比较大的大提琴 7.爱你没差 8.红尘客栈 9.梦想启动 10.大笨钟 11.哪里都是你 12.乌克丽丽 《哎呦，不错哦》，发行日期：2014-12-26 12345678910111213专辑曲目： 1.阳明山 2.窃爱 3.算什么男人 4.天涯过客 5.怎么了 6.一口气全念对 7.我要夏天 8.手写的从前 9.鞋子特大号 10.听爸爸的话 11.美人鱼 12.听见下雨的声音 《周杰伦的床边故事》，发行日期：2016-06-24 1234567891011专辑曲目： 1.床边故事2.说走就走3.一点点4.前世情人5.英雄6.不该7.土耳其冰淇淋8.告白气球9.Now You See Me10.爱情废柴","tags":[{"name":"周杰伦","slug":"周杰伦","permalink":"http://yoursite.com/tags/周杰伦/"},{"name":"专辑封面","slug":"专辑封面","permalink":"http://yoursite.com/tags/专辑封面/"}]}]