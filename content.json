[{"title":"1 自制操作系统第一天","date":"2017-11-20T16:00:00.000Z","path":"2017/11/21/omake_1/","text":"项目地址 二进制文件有一种工具软件名为“二进制编辑器”（binary editor），是一种能够直接对二进制数进行编辑的软件。这里是下载地址，中间有一个Download标识的。我试过notepad++，但是里面不可以复制粘贴。 使用bz软件，退出去之后，再次打开某个文件，不可编辑，这是因为它是只读模式，在软件菜单里选择“编辑”（edit），然后把“只读”（read only）去掉对号，就可以再次编辑了。 建立一个二进制文件，这里是源文件地址。你可以直接用，但是我建议你把这些数字自己手动写一下。简单介绍一下这个文件怎么输入，首先000090以前的数字自己手打进去，然后从000090开始到168000这个地址，中间都输入00，你可以大量的复制粘贴。因为一共168000行，而168000是16进制，换成10进制是1474560，所以文件大小是1474560（1440*1024字节）字节，复制的时候可以看文件大小适当的停下。还没结束，中间有几行不全是0，在0000 01f0这一行、0000 0200这一行和0000 1400这一行，可以对照源文件进行修改。然后保存这个文件，建议后缀是img。 下载项目的地址中tolset，这里面有很多工具可以用。 12345下面是run.bat命令copy helloos.img ..\\..\\tolset\\z_tools\\qemu\\fdimage0.bin..\\..\\tolset\\z_tools\\make.exe -C ../../tolset/z_tools/qemu注意：根据自己的二进制文件名称和路径进行修改命令 我也不知道这个run命令是什么意思，应该是打开一个叫做QEMU的PC模拟器，然后把你的镜像文件（你创建的二进制文件），放到里面运行。 运行run命令之后，你的操作系统就制作好了。 汇编程序刚才那个二进制文件简直写的太麻烦，现在利用汇编程序把它缩短一些，汇编语言编译器在tolset里面，名为“nask”，其中的很多语法都模仿了自由软件里享有盛名的汇编器“NASM”，不过在“NASM”的基础上提高了自动优化的能力。 这个是汇编程序文件，我还是建议自己手动输出写一遍。12345678910111213141516171819202122DB 0xeb, 0x4e, 0x90, 0x48, 0x45, 0x4c, 0x4c, 0x4fDB 0x49, 0x50, 0x4c, 0x00, 0x02, 0x01, 0x01, 0x00DB 0x02, 0xe0, 0x00, 0x40, 0x0b, 0xf0, 0x09, 0x00DB 0x12, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00DB 0x40, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x29, 0xffDB 0xff, 0xff, 0xff, 0x48, 0x45, 0x4c, 0x4c, 0x4fDB 0x2d, 0x4f, 0x53, 0x20, 0x20, 0x20, 0x46, 0x41DB 0x54, 0x31, 0x32, 0x20, 0x20, 0x20, 0x00, 0x00RESB 16DB 0xb8, 0x00, 0x00, 0x8e, 0xd0, 0xbc, 0x00, 0x7cDB 0x8e, 0xdb, 0x8e, 0xc0, 0xbe, 0x74, 0x7c, 0x8aDB 0x04, 0x83, 0xc6, 0x01, 0x3c, 0x00, 0x74, 0x09DB 0xb4, 0x0e, 0xbb, 0x0f, 0x00, 0xcd, 0x10, 0xebDB 0xee, 0xf4, 0xeb, 0xfd, 0x0a, 0x0a, 0x68, 0x65DB 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x77, 0x6f, 0x72DB 0x6c, 0x64, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00RESB 368DB 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xaaDB 0xf0, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00RESB 4600DB 0xf0, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00RESB 1469432 1234汇编编译命令 asm.bat..\\..\\tolset\\z_tools\\nask.exe helloos.nas helloos.img注意：根据自己汇编程序文件名称和路径进行修改命令 编译之后，就会得到一个img文件，然后调用run命令就好了。 DB指令是“define byten”的缩写，也就是往文件里面直接写入1个文件的指令。 RESB指令是“reserve byte”的略写，如果想要从现在的地址开始空出10个字节来，就可以写成RESB 10。而且nask不仅仅是把指定的地址空出来，它还会在空出来的地址上自动填写0x00，所以我们这次用这个指令就可以输出很多0x00。 改进后的汇编程序这里是改进后的汇编程序文件，建议你自己手动打一遍。12345678910111213141516171819202122232425262728293031323334353637383940414243444546; hello-os; TAB = 4; 以下这段是标准FAT12格式软盘专用的代码 DB 0xeb, 0x4e, 0x90 DB &quot;HELLOIPL&quot; ; 启动区的名称可以时任意的字符串(8字节) DW 512 ; 每个扇区(sector)的大小(必须是512字节) DB 1 ; 簇(cluster）的大小（必须是一个扇区) DW 1 ; FAT的起始位置(一般从第一个扇区开始) DB 2 ; FAT的个数(必须是2) DW 224 ; 根目录的大小(一般设成224项) DW 2880 ; 该磁盘的大小(必须是2880扇区) DB 0xf0 ; 磁盘的种类(必须是0xf0) DW 9 ; FAT的长度(必须是9扇区) DW 18 ; 1个磁道(track)有几个扇区(必须是18) DW 2 ; 磁头数(必须是2) DD 0 ; 不使用分区，必须是0 DD 2880 ; 重写一次磁盘大小 DB 0,0,0x29 ; 意义不明，固定 DD 0xffffffff ; (可能是)卷标号码 DB &quot;HELLO-OS &quot; ; 磁盘的名称(11字节) DB &quot;FAT12 &quot; ; 磁盘格式名称(8字节) RESB 18 ; 先空出18字节; 程序主体 DB 0xb8, 0x00, 0x00, 0x8e, 0xd0, 0xbc, 0x00, 0x7c DB 0x8e, 0xdb, 0x8e, 0xc0, 0xbe, 0x74, 0x7c, 0x8a DB 0x04, 0x83, 0xc6, 0x01, 0x3c, 0x00, 0x74, 0x09 DB 0xb4, 0x0e, 0xbb, 0x0f, 0x00, 0xcd, 0x10, 0xeb DB 0xee, 0xf4, 0xeb, 0xfd; 信息显示部分 DB 0x0a, 0x0a ; 两个换行 DB &quot;hello, world&quot; DB 0x0a ; 换行 DB 0 RESB 0x1fe-$ ; 填写0x00，直到0x001fe DB 0x55, 0xaa; 以下是启动区以外部分的输出 DB 0xf0, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00 RESB 4600 DB 0xf0, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00 RESB 1469432 “;”命令就是注释命令 DW是“define word”的缩写，2个字节 DD是“define double-word”的缩写，4个字节 RESB 0x1fe-$，在这个程序里，我们已经在前面输出了132字节，所以这里的$就是132.因此nask先用0x1fe减去132，得出378这一结果，然后连续输出378个字节的0x00。为什么非要用$呢？这是因为如果将系那是信息从”hello, world”换成“this is a pen.”的话，中间要输出0x00的数量也会随之变化。换句话说，我们必须保证软盘的第510字节（即第0x1fe）开始的地方必须是0x55和0xaa。 专业术语 启动区（boot sector）软盘的第一个的扇区称为启动区。计算机读写软盘的时候，并不是一个字节一个字节第读写的，而是以512字节为一个单位进行读写。因此，软盘的512字节就是一个扇区。一张软盘的空间共有1440KB，也就时1474560字节，除以512得2880，也就是说一张软盘共有2880个扇区。那位神秘第一个扇区称为启动区呢？那是因为计算机首先从最初一个扇区开始读软盘，然后去检查这个扇区最后2个字节的内容。如果最后两个字节不是0x55AA，计算机会认为这张盘上没有所需的启动程序，就会报一个不能启动的错误。（也许有人会问为什么一定是0x55AA呢？那是当初的设计者随便定的）。如果计算机确定第一个扇区的最后两个字节正好是0x55AA，那它认为这个扇区的开头是启动程序，并开始执行和这个程序。 IPL(initial program loader)是启动程序加载器。启动区只有512字节，实际的操作系统不想hello-os这么小，根本装不进去。所以几乎所有的操作系统，都是把加载操作系统本身的程序放在启动区里的。有鉴于此，有时也将启动区成为IPL。但hello-os没有加载程序的功能，所以HELLOIPL这个名字不太顺理成章。 启动（boot）。boot这个词是bootstrap的缩写，原指靴子上附带的便于拿取的靴带。但自从有了《吹牛大王历险记》（德国）这个故事以后，bootstrap这个词就有了“自力更生完成任务”的意思。而且，磁盘上明明有操作系统，还要说读入操作系统的程序（即IPl）也放在磁盘里，这就像打开宝物箱的钥匙和宝物都在宝物箱里一样，是一种矛盾的说法。这种矛盾的操作系统自动启动机制，被称为bootstrap方式。boot这个说法就来源于此。","tags":[{"name":"30天自制操作系统","slug":"30天自制操作系统","permalink":"http://yoursite.com/tags/30天自制操作系统/"},{"name":"hello,world","slug":"hello-world","permalink":"http://yoursite.com/tags/hello-world/"}]},{"title":"25 图形化革命","date":"2017-11-18T04:00:00.000Z","path":"2017/11/18/code_25/","text":"矢量图形（vector graphics）在一些算法的帮助下，利用直线、曲线及填充区域生成图形。矢量图形在工程和体系结设计中有着十分重要的作用。矢量图形一般转化为图元文件（metafile）格式以存放到文件中。图元文件是由生成矢量图形的一系列绘制命令的集合组成的，这些命令通常已经被编码为二进制形式。 光栅图形（也称作位图）。位图（bitmap）将图形以矩阵阵列的形式进行编码，阵列中的一个单位对应着输出设备上的一个像素点。 要把现实世界的图像输入到计算机中，可以借助一些不同的硬件，这类设备统称为电荷耦合器（charge-coupled device， CCD），它是一种在光照下会起电的半导体器件。每个像素都需要一个CCD单元来采集。这些设备中最原始的可以算是扫描仪（scanner）了，其原理和影印机类似，都是利用一行CCD扫过需要复印的图像的表面，比如照片。由于光感度不同，不同区域CCD累积的电荷数不同。扫描仪的配套软件把图像转换成位图放在文件中。 位图的文件可能很大，催生了数据压缩这一领域。 如果画面的是一片天空、一栋房子和一块草坪。因此，图片中可能有大片的蓝色和绿色。如果有一种方法可以表示蓝色和绿色连续重复了多少次，这种方法就会让文件变得很小。这样的压缩方法称为游程长度编码（Run-Length Encoding），即RLE。属于无损（lossless）压缩技术。 JPEG（Joint Photography Experts Group）中，人们使用了一些列位图有损压缩技术。 CD（compact disc）声音信息采用的编码技术被称为脉冲编码调制技术（Pulse Code Modulation），简称PCM。振动是声音之源。声波可以被模拟，电流产生模拟（analog）声波。为了达到这个目的，使用模拟数字转换器（Analog To Digital Converter，ADC），将模拟电压转换成二进制数。 以电压形式表示的声波以恒定的频率被转换成数值。这些数值将以小孔的形式刻在光盘上，通过这种方式，电压就以数值的形式被存储在CD上。要读取这些信息时，可以通过分析从CD表面反射的激光读取到所存储的数值。在播放声音的时候，这些数值又被转换成电流，这个过程用到了数字模拟转换器（Digital-To-Analog converter， 即DAC），DAC还可以用在彩色图形板上，将像素值转换成模拟信号并传输到显示器。 计算机中的电影文件一般都是由一系列附带声音的位图组合而成。如果不经过压缩处理，一部电影文件的数据量将会很大。假如电影中每一帧包含的像素大小是640*480，每个像素为24位真彩色，那么每一帧的大小九尾921600字节。如果播放的速度是30帧/秒，则每秒需要的存储空间是27648000字节。照这样下午，每分钟需要的空间大小为1658880000字节，一部两小时的电影大约需要100GB。 就像JEPG压缩技术可以用来减少静态图像所占的数据空间一样，MPEG压缩技术用于处理动态电影文件。全称是Moving Pictures Expert Group。动态图像压缩技术基于的是一种客观事实，即每一帧继承了前一帧的大部分消息，也就是存在冗余消息。","tags":[{"name":"编码(隐匿在计算机软硬件背后的语言)","slug":"编码-隐匿在计算机软硬件背后的语言","permalink":"http://yoursite.com/tags/编码-隐匿在计算机软硬件背后的语言/"},{"name":"图像的存储","slug":"图像的存储","permalink":"http://yoursite.com/tags/图像的存储/"},{"name":"音乐的存储","slug":"音乐的存储","permalink":"http://yoursite.com/tags/音乐的存储/"},{"name":"图像压缩","slug":"图像压缩","permalink":"http://yoursite.com/tags/图像压缩/"}]},{"title":"24 高级语言与低级语言","date":"2017-11-18T04:00:00.000Z","path":"2017/11/18/code_24/","text":"使用机器码编码写程序就如同用牙签吃东西，伸出手臂使出较大的力气刺向食物，但每次只获取到小小的一块，这个过程是辛苦且漫长的。同样的，每个机器码字节所能完成的工作，是你能想象到的最微小且最简单的工作。 使用汇编语言编写程序要比使用机器语言简单的多，但微处理器并不能解释汇编语言，当你确实准确在微处理器上运行汇编程序，才会手工对其汇编，这样就可以将汇编语言程序的语句转换成了机器语言代码，并把它们输入内存。 当然我们希望计算机能独自完成语言转换的工作。CM/P系统中，有一个工具可以对其进行汇编。首先，建立一个文本文件，例如PROGRAM1.ASM。下一步要做的就是对其进行汇编，即将其转换成机器语言代码，可以利用CP/M中一个叫做ASM.COM的模块来完成这想工作。可以在CP/M的命令行中使用下面的语句：ASM PROGRAM1.ASM。产生一个名为PROGRAM1.COM的新文件，PROGRAM1.ASM包含了与我们编写的汇编程序相对应的机器码。现在就可以利用CP/M的命令行来运行PROGRAM1.COM文件。 想ASM.COM这样的汇编器（assembler）程序所做的工作是：读取一个汇编语言文件（source-code，通常称作源文件代码），将其转换得到一个包含机器码的文件——可执行文件（executable file）。从宏观角度来看，汇编器是非常简单的，因为构成汇编语言的助记符和机器码之间是一一对应的。汇编器拥有一张包含所有可能助记符机器参数的表，它逐行读取汇编语言程序，把每一行都分解成为助记符和参数，然后把这些短小的单词和字符与表中的内容匹配。通过这种匹配的过程，每一个语句都会找到与其对应的机器码指令。 第一个编写汇编器的人需要手工对程序汇编。如果要为机器写一个新的汇编器（或者对其修改），则可以用汇编语言编写改程序，然后使用原有的汇编器对其汇编。一旦新的汇编器通过了汇编，则它也就可以对其自身进行汇编。 汇编器也有两个主要问题。第一个问题，使用汇编语言非常乏味，因为这是在微处理器芯片级的编程，因此不得不考虑每一个微小的细节。第二个问题是不可“移植”。如果你位Intel 8080写了一个汇编语言程序，则该程序不能再Motorola 6800上运行，你必须在6800上重写一个相同功能的汇编语言程序。 汇编语言称作低级语言（low-level programming language），除了汇编语言以外的其他程序设计语言都可以称作高级程序设计语言（high-level programming langua） 运行时错误（run-time error）——程序被执行时才出现的错误。 123456789101112131415161718下面的ALGOL程序用来筛选2~10,000之间的所有素数。begin Boolean array a[2:10000]; integer i, j; for i := 2 step i until 10000 do a[i] := true; for i := 2 step 1 until 100 do if a[i] then for j := 2 step 1 unitl 10000 ÷ i do a[i × j] := false; for i := 2 step 1 until 10000 do if a[i] then print (i);end 程序设计是一门科学还是一门艺术？在程序设计中有一种现象：如果让100个人来编写输出素数的程序，你可能会得到100个不同的解决方案。就算所有的程序员都使用“爱拉托逊斯筛法”来解决这个问题，其最后所写的程序也不一定与本文所写程序完全相同。 编译性（compiler）读取源文件并生成一个可执行文件；解释性（interpreter）却采取边读边执行的方式，不会产生新的文件。 集成开发环境（integrated development environment），程序的文本编辑器和编译器在一起，这样就方便了程序的调试和运行，大大加快了程序开发速度。","tags":[{"name":"编码(隐匿在计算机软硬件背后的语言)","slug":"编码-隐匿在计算机软硬件背后的语言","permalink":"http://yoursite.com/tags/编码-隐匿在计算机软硬件背后的语言/"},{"name":"程序的艺术","slug":"程序的艺术","permalink":"http://yoursite.com/tags/程序的艺术/"}]},{"title":"23 定点数和浮点数","date":"2017-11-15T16:00:00.000Z","path":"2017/11/16/code_23/","text":"数字分类自然数，即计算机的整数，包括正整数和负整数，利用2的补数可以让正整数和负整数变得非常简单。 数的位数 正整数的范围 整数的2的补数的范围 8 0 ~ 255 -128 ~ 127 16 0 ~ 65,535 -32,768 ~ 32,767 32 0 ~ 4,294,967,295 -2,147,483,648 ~ 2,147,483,647 有理数（rational number）和无理数（irrational number）统称为实数（real number）。实数和虚数（imaginary numbers）构成了复数（complex number）。虚数存在于现实世界，它在解决电子学的某些高级问题中有着重要应用。 定点数在计算机中的表示小数表示成二进制最简单的办法就是利用BCD码。BCD编码在程序处理用美元和美分表示的钱款、账户时特别有用，许多数字只需要两个小数位。 通常把两个BCD数字存放在一个字节，这种方法成为压缩BCD（packed BCD），压缩BCD需要增加1位用来标识数的正负。 -4,325,120.25可以表示为下面5个字节：00010100 00110010 01010001 00200000 00100101最左边的半个字节构成的1用来指明该数是负数，如果半个字节是0，这说明该数是个正数。 如果表示的数的范围扩大到-99,999,999.99~99,999,999.99，则我们需要6个字节来实现，其中5个字节用来表示10个数字，另一个字节整个用来做符号位。 这种存储和标记方式被称作定点格式（fixed-point format），指小数点的位置总是在数的某个特定位置。小数点的计数信息并没有与整个数字一起存储。所以，使用定点小数的程序必须知道小数点的位置。 单精度浮点数和双精度浮点数科学家和工程师们喜欢使用一种称为“科学计数法”（scientific notation）的方法来记录较大或较小的数。科学计数法分为两部分，第一部分就是指数（exponent），第二部分是有效数（significand)。 除了定点格式外还有另外一种选择，他被称作浮点格式（floating-point notation），浮点格式是基于科学技术法的。 对于十进制来说，有效数的取值范围是大于或等于1而小于10；类似的，在二进制的科学计数法中，规范化的有效数应该大于或等于1而且小于10（即十进制的2）。这个规则暗示了这样一个有趣的现象：在规范化二进制浮点数中，小数点的左边通常只有一个1，除此之外没有其他数字。 IEEE（Institute of Electrical and Electronics Engineers，美国电气和电子工程协会）浮点数标准定义了两种基本的格式：以4个字节表示的单精度格式和以8个字节表示的双精度格式。 单精度格式的4个字节可以分为三个部分：1位的符号位（0代表正数，1代表负数），8位用作指数，最后的23位用作有效数。 左 中 右 s = 1位符号 e = 8位指数 f = 23位有效数 有效数的小数点左边只有一个1，因此在IEEE浮点数标准中，这一位没有分配存储空间。在该标准中，存储有效数的23位小数部分，尽管存储的只有23位，但仍然称其精度为24位。 8位指数部分的取值范围是0 ~ 255，成为便宜（biased）指数，对于有符号指数，为了确定其实际所代表的值必须从指数中减去一个值——称做偏移量（bias）。对于单精度浮点数，偏移量为127。 指数0和255用于特殊目的，如果指数的取值范围为1~254，那么对于一个特定的数，用s（符号位），e（指数）以及f（有效数）来描述它： $(-1)^s\\times1.f\\times2^{e-127}$ 如果s是0，则该数是正的；如果s=1，则该数是负的。 如果e=0且f=0，则该数为0。在这种情况下，通常把32位都设置为0以表示该数是0。但是符号位可以设置为1，这种数可以解释为负0。负0用来表示非常小的数，这些数极小以至于不能再单精度格式下用数字和指数表示，但它们仍然小于0。 如果e=0且f≠0，则该数是合法的，但不是规范化的。这类书可以表示为： $(-1)^s\\times0.f\\times2^{-127}$ 注意，在有效数中，小数点的左边是0。 如果e=255且f=0，则该小数被解释为无穷大或无穷小，这取决于符号位s的值。 如果e=255且f≠0，则该值被解释为“不是一个数”，通常被缩写为NaN（not a number）。NaN用来表示未知的数或非法操作的结果。 单精度浮点格式下，可以表示的规范化的最小正、负二进数是： $1.00000000000000000000000_2\\times2^{-126}$ 小数点后面跟着23个二进制0。单精度浮点数格式下，可以表示的规格化的最大正、负二进制数是： $1.11111111111111111111111_2\\times2^{127}$ 这个两个数的近似地表示$1.175494351\\times10^{-38}$和$3.402823466\\times10^{38}$ 10位二进制数可以近似地用3位十进制数来表示。这意味着：单精度浮点数格式存放的24位进制数大体上与7位的十进制数相等。因此，可以说单精度浮点格式提供的24位的二进制精度或者7位的十进制精度。这样说更合适：单精度浮点数的精度为$\\frac{1}{2^{24}}$,或1/16777216，或百万分之六，但其真正的含义是什么呢? 在单精度浮点格式下，16,777,216和16,777,216将表示一个数。 32位单精度浮点数：4B800000h。将该数按符号位、指数位和有效数位划分，可以表示为：0 10010111 00000000000000000000000也就是$1.00000000000000000000000_2\\times2^{24}$，也就是16,777,216下一个二进制浮点数可表示的最大有效数是$1.00000000000000000000001_2\\times2^{24}$，也就是16,777,218。 你的程序进行了一系列计算，应该得到的结果是3.50的，但由于使用浮点数，你得到的结果可能是3.499999999999。这种问题在浮点数运算中经常发生。 如果想在程序中使用浮点格式数，但使用单精度格式又会出现各种问题，这时可以考虑使用双精度浮点数（double-precision floating-point format） 左 中 右 s = 1位符号 e = 11位指数 f = 52位有效数 双精度浮点数的指数偏移量是1023，因此该格式存储的数字可以表示为：$(-1)^s\\times1.f\\times2^{e-1023}$ 上面提到的关于单精度浮点格式下的0，无穷大，无穷小和NaN的判断规则同样适用于双精度格式。 双精度浮点格式下，可以表示的规范化的最小正、负二进数是： $1.0000000000000000000000000000000000000000000000000000_2\\times2^{-126}$小数点后面跟着52个二进制0。单精度浮点数格式下，可以表示的规格化的最大正、负二进制数是： $1.1111111111111111111111111111111111111111111111111111_2\\times2^{127}$ 这个两个数的近似地表示$2.2250738585072014\\times10^{-308}$和$1.7976931348623158\\times10^{308}$ 双精度浮点格式的有效数是53位，大致相当于十进制的16位。不能避免两个不同的书存储同一个结果的情况。例如，140,737,488,355,328.00和140,737,488,355,328.01在内存中存放时，会被当做同一个数来处理。","tags":[{"name":"编码(隐匿在计算机软硬件背后的语言)","slug":"编码-隐匿在计算机软硬件背后的语言","permalink":"http://yoursite.com/tags/编码-隐匿在计算机软硬件背后的语言/"},{"name":"定点数","slug":"定点数","permalink":"http://yoursite.com/tags/定点数/"},{"name":"浮点数","slug":"浮点数","permalink":"http://yoursite.com/tags/浮点数/"}]},{"title":"22 操作系统","date":"2017-11-14T16:00:00.000Z","path":"2017/11/15/code_22/","text":"为了让一切能正常工作，微处理器在复位的时候需要执行一些代码，称为初始化代码（initialization code）。堆栈指针在运行初始化代码的时候会被设置，以保证堆栈处于内存的有效区域内。位了不让屏幕显示随机字符，初始化代码还把视频显示器内存中的每个字节设置成十六进制数20h，在ASCII码中这是一个空格符。此外，初始化代码还要把光标位在第一行第一列的位置——OUT（Output）指令可以完成这一操作：光标在视频显示器上是以画线的形式出现的——它可以显示出下一个要输入字符的位置。下一条命令是EI，它能开启中断，以便微处理器能够响应键盘中断。EI指令后面是HLT指令，它能是微处理器停止工作。 键盘处理程序对每个按键进行相应的处理，然后执行RET（Return）指令以返回HLT语句，等待另一个键盘中断。 在键盘处理程序内含有一个命令处理程序（command processor），它可以解释为三条命令：W命令、D命令和R命令。 W 1020 35 4F 78 23 9B AC 67运行这条命令，命令处理器会从内存地址1020h处开始，把35、4F等十六进制表示的字节写入内存中。要完成这项工作，键盘处理程序需要把ASCII码转换成字节。 D 1030命令处理程序会把地址1030h开始的11个字节的内容显示出来（之所以说是11字节，是因为每行可以容纳40个字符的显示器上，出去显示命令与地址标识，后面能显示的也只有这么多了）。 R 1000执行此命令意味着“处理器会运行从地址1000h开始的一段程序”。首先命令处理程序把1000h存储在寄存器对HL中，接着执行指令PCHL，把HL所存储的值加载到程序计数器中，然后跳转到程序计数器指向的地址并运行程序。 键盘处理程序及命令处理程序简化了许多工作，可以说是计算机发展的一个里程碑。 仅仅有上面的命令还是不够的，还需要向命令处理程序添加新命令。 S 2080 2 15 3运行这条命令后，在磁盘的第2面、第15道、第3扇区中将存放起始地址为2080h的内存块数据。类似的，还可以通过加载（Load）命令，把磁盘上相应扇区的内容写回到内存中，如下所示：L 2080 2 15 3 所有的东西存储在磁盘的什么位置，都需要你手工记录下来，这个工作挺多，也挺麻烦。处于这个原因，文件系统（file system）应运而生。 CP/M(Control Program for Micros)是最重要的8位微处理器操作系统。CM/P操作系统是放在磁盘上的。单面、8英寸的磁盘是早期的CP/M最常用的存储介质，他有77个磁道，每个磁道有26个扇区，每个扇区的大小是128个字节。CP/M系统存放在磁盘最开始的两个磁道。在启动计算机时，需要把CP/M从磁盘调入到计算机的内存中。 剩下的75个磁道中的扇区来存放文件，这些扇区按分配快（allocation blocks）进行分组。每个分配块中有8个扇区，总计1024个字节。可以计算，在磁盘上共有243个分配块，编号为0~242。 目录（directory）区占用最开始的两个分配块（编号为0和1）中。目录区是磁盘中的一个非常重要的区域，磁盘文件中每个文件的名字和其他的一些重要信息都存在该区域，根据目录就能够很方便、高效地查找文件。存放目录也需要占用空间，磁盘上每个文件对应的目录项（directory entry）大小均为32字节，由于目录大小为2048字节，所以这个磁盘上最多可以存放64个文件。 每一个32字节的目录项包含以下信息 字节 含义 0 通常设为0 1~8 文件名 9~11 文件类型 12 文件扩展 13~14 保留（设置为0） 15 最后一块扇区数 16~31 磁盘存储表 第一个字节用来设置文件的共享属性，只有文件系统被两个或更多人同时共享时才设置此字节为1。在CP/M中，这个字节跟地13、14字节一样，通常设置为0。 CP/M中每个文件的文件名有两部分构成，第一部分称为文件名（filename），文件名最多由8个字符构成，目录项的第1~8字节用来存储文件名。第二部分称为文件类型（file type），最多由3个字符表示，这些字符存储在目录项的第9~11字节中。txt表示文本文件，此文件只包含ASCII码，COM表示这个文件存放的是8080机器码指令，或者说是一段程序。当命名一个问及那时，通常一个点来隔开两部分，如下所示： myletter.txt calc.com 目录项中的第16~31字节是磁盘存储表，它能够标明文件所存放的分配块。假设磁盘存储表前4项分别为14h、15h、07h、23h，其余项全为0，这表明文件占 用了4个分配块的空间，大小为4KB，而实际上文件可能并没有用完4KB空间，因为最后一个分配块往往只有部分扇区被使用。目录项的15字节标明最后一个分配块到底用了多少个128字节的扇区。 磁盘存储表的长度为16字节，最多可以容纳16384字节的文件，如果文件的长度超过16KB，就需要多个目录项来表示，这种方法称为扩展。如果一个大文件使用目录项扩展来，则将第一个目录项的第12字节设置为0，第二个目录项的第12字节则设置为1，以此类推。 文本文件，通常称之为ASCII文件（ASCII file）、纯文本文件（text-onlu file）或纯ASCII文件（pure-ASCII file）。其余的文件称为二进制问及那（binary file），在CM/P中，COM文件存放的是二进制的8080机器码，它是二进制文件。 假设一个小文件中包含三个16位数，如：5A48h、78BFh和F510h。如果此文件的是二进制文件，只要6字节就可以了。48 5A BF 78 10 F5这是采用Intel格式来存储的，放在前面的是低位，放在后面的高位。 假如上面的三个16位数用ASCII文本文件来存放，则文件中保存的数据如下所示：35 41 34 38 68 0D 0A 37 38 42 46 68 0D 0A 46 35 31 30 68 0D 0A显示如下：5A48h78BFhF510h 也可以用如下的形式来表示包含的这三个数的ASCII文本文件：32 33 31 31 32 0D 0A 33 30 39 31 31 0D 0A 36 32 37 33 36 0D 0A这是用十进制数的ASCII码形式来表示上述三个数，这两种表示形式是等价的，如下所示：231123091162736 显然文本文件更易于人们阅读，同样，与十六进制相比，十进制更符合人们的习惯，没理由使用十六进制而拒绝十进制。 操作系统的引导过程完成后，随机存储器（RAM）的最高地址区域用来存放CP/M，加载完CP/M后，整个内存空间的组织结构如下所示。 地址 区域 0000h 系统参数 0100h 临时程序区域（TPA） 。 控制台命令处理程序（CCP） 。 基本磁盘操作系统（BDOS） 最高地址： 基本输入/输出系统（BIOS） 控制台命令处理程序（Console Command Processor，CCP）、基本磁盘操作系统（Basic Disk Operating System，BDOS）和基本输入/输出系统（Basic Input/Output System，BIOS）是CP/M的三个组成部分，这三个部分只占用了6KB大小的内存空间。在拥有64KB内存空间的计算机中，大约58KB被临时程序区（Transient Program Area，TPA）占用，但是这58KB一开始是空的。 操作系统一个重要功能就是让程序能够方便地访问计算机的硬件，操作系统提供的这种访问操作称为API（Application Programming Interface），即应用程序接口。 16位操作系统QDOS（Quick and Dirty Operating System）的开发在很多方面都借鉴了CP/M的思想。QDOS系统被微软公司注册后更名为86-DOS，后来将其更名为MS-DOS（Microsoft Disk Operating System）。这就是著名的MS-DOS系统。由于MS-DOS的影响力更大，其很快称为了标准。 CP/M的文件系统在MS-DOS没有被继续使用，在MS-DOS中，文件系统是以文件分配表（FAT，File Allocation Table）的形式来组织的。将磁盘空间分成簇（cluster），簇的大小由磁盘空间的大小来决定的——从512字节到16K字节不等。每个文件占用若干簇。文件的目录项只记录文件起始簇的位置，而磁盘上没一簇的下一簇的位置由FAT来记录。 每个目录项在MS-DOS磁盘上占用32字节，其命名形式跟CP/M上的8.3（名称8个字节，类型3个字节）一样，只是术语有点区别，最后的三个字符称作文件扩展名，而非CP/M中的文件类型。MS-DOS目录项中没有包含分配块列表，他主要包括如下所示的有用信息：文件的最后修改日期、时间、和文件的大小等。 硬盘容量越大存储的文件也就越多，存储的文件越多，查找某个指定的文件或组织文件也就越困难。 为了解决这个问题，MS-DOS 2.0引入了层次文件系统（hierarchical file system），他只是在原有的文件系统上做了一些小的改动。在层析文件系统中，有些文件本身可能就是目录，也就说这些文件包含其他文件，其中的一些可能还是目录。再次盘中，常规的目录称为根目录（root directory），子目录（subdirectories）是包含在其他目录里的目录。有了目录（有时称作文件夹，folder），就可以很方便地对相关文件进行分组，所以目录在磁盘文件的管理中骑着非常重要的作用。 MS-DOS的层析文件系统和其他一些功能都是从UNIX操作系统借鉴来的。UNIX不针对具体的计算机硬件平台，具有很好的可移植性（portable），也就意味着它在各种机器上都可以运行。 使用UNIX系统的计算机通过时分复用（time sharing）技术——这种技术允许多个用户同时与计算机进行交互——来达到这个目的。计算机连接多个配备了显示器和键盘的终端（terminals），每个用户通过这些终端访问计算机。通过在终端间的快速切换，使用户感觉在这台计算机似乎只为自己工作，而其实计算机同时在为多个用户服务。 如果在一个操作系统上同时运行多个程序，则成此系统为多任务（multitasking）操作系统。虚拟内存是指，在磁盘上划出部分空间用做保存临时文件，程序需要把暂时不需要的内存块放到临时文件里，带需要时再把它调入内存。 近年来，非常流行系统有开源系统Linux系统、苹果公司的Macintosh和微软的Windows系统。","tags":[{"name":"编码(隐匿在计算机软硬件背后的语言)","slug":"编码-隐匿在计算机软硬件背后的语言","permalink":"http://yoursite.com/tags/编码-隐匿在计算机软硬件背后的语言/"},{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/tags/操作系统/"},{"name":"键盘处理程序","slug":"键盘处理程序","permalink":"http://yoursite.com/tags/键盘处理程序/"},{"name":"命令处理程序","slug":"命令处理程序","permalink":"http://yoursite.com/tags/命令处理程序/"}]},{"title":"21 总线","date":"2017-11-13T16:00:00.000Z","path":"2017/11/14/code_21/","text":"地址总线。这些信号由微处理器产生，通常对RAM进行寻址操作，当然也可以用来对连接到计算机其他设备进行寻址从、操作。 数据输出信号。这些信号也是由微处理器产生的，用来吧数据写入到RAM或其他设备。 数据输入信号。这些信号由计算机的其他部分提供的，并由微处理器读取。通常情况下，数据输入信号由RAM输出，这就解释了微处理器是怎样从内存中读取内容的。 控制信号。这些信号是多种多样的，通常与计算机内所用的特定的微处理器相对应。控制信号可以产生于微处理器，也可以由与微处理器通信的其他设备产生。 总线还可以为计算机不同电路板供电。 如果设计出来的总线不适合高速传输的话，就会出现射频干扰，这会使附近的收音机和电视机产生静电或其他噪声。 片选信号置1时，芯片不被选中，意思就是说，不会响应读写信号。 2102是一款存储器芯片，存储容量可以达到1024位，这个数值可以根据地址信号（A0~A9）控制。若让你为8位的微处理器组织存储器的话，你会怎么做呢？ 把8个这样的芯片连在一起组成1024*8 RAM，即1KB的RAM。一块s-100板就能容纳64个。这样一来，就提供了8KB的存储空间。一般我们不这样做，更合适的方法是，用32个芯片组成一个4KB的存储器。位了存储完整的字节，而连在一起的芯片的集合，称为存储体。例如，一个4KB大小的存储器就由4个存储体组成，而每个存储体又包含8个芯片。 像8080、6800，由16位地址，可用来寻址64KB的存储空间。如果你制作了一个包含4个存储体、大小为4KB的存储器板，则存储器板上的16位地址信号就有如下所示的功能。 A15 A14 A13 A12 A11 A10 A9 A8 A7 A6 A5 A4 A3 A2 A1 A0 A0~A9 直接与RAM芯片相连接；A10和A11用来选择4个存储体中要被寻址的哪一个；A12~A15确定哪些地址申请用这块存储器板，换言之，就是这块存储器板响应哪些地址。微处理器整个存储空间的大小是64KB，被分为16个不同的区域，每个区域的大小是4KB，我们设计的4KB存储器板占用了其中一个区域。这个16个区域划分情况如下。 0000h~0FFFh1000h~1FFFh2000h~2FFFh…………F000h~FFFFh 如果4KB存储器板使用了A000h~AFFFh地址区域。这就意味着，第一个存储体占用了地址A000~A3FFh，第二个占用了地址A400h~A7FFh，第三个占用了地址A800h~ABFFh，剩下的AC00h~AFFFh地址空间分给了第四个存储体。 你可能会认为我们需要8个4-1选择器，用来从4个存储体中选择正确的数据输出信号。但我们并没有这么做，下面讨论下原因。 一个集成电路的输出为1，另一个集成电路为0，若把这两个输出连接在一起，结果又是什么呢？恐怕谁也无法回答。就是由于这种不确定性，一把你不会把集成电路的输出信号连接在一起。 2102芯片的数据输出信号是三态的，也就是说，除了逻辑0和逻辑1之外，数据输出信号还有第三种状态。我们必须清楚地认识这种状态——它其实是一种“真空”状态，就像芯片的引脚上什么也没连一样。当片选信号为1时，2102芯片的数据输出信号就会进入这种状态。这样一来，我们可以把四个存储体响应的数据输出信号连接在一起，并且把8个输出复用作为总线的8个数据输入信号。 之所以强调三态输出的概念，是因为它对总线的操作是至关重要的。几乎所有连接在总线上的器件都使用由总线传递而来的数据输入信号。但不管何时，连接在总线上的电路板中只有一个能确定总线数据输入信号的类型，其他电路板处于三种状态中的无效状态。 2102是一款静态随机访问存储器芯片（static random access memory，SRAM），它与动态访问存储器（Dynamic Random Access Memory，DRAM）是不同的。通常对于每1位存储空间，SRAM需要用4个晶体管，但DRAM只需要1个晶体管，但DRAM需要较复杂的外围支持电路，这正是它的缺点。 DRAM芯片在使用时需要定期访问其他存储器中的内容，尽管有时并不需要这些内容。这一过程称之为更新周期，每秒钟都必须进行几百次。这种做法就好像位不让某人入睡而每隔一段时间就用手肘轻推他一样。 尽管业界在使用DRAM上有些争论，但近年来，DRAM芯片的容量日益增加，使得DRAM最终成为标准。 电子射线管（cathode-ray tube， CRT），他从外观上看就像电视机一样。连接到计算机上的CRT为视频显示器（video display）或监视器（monito）。而称可以为视频显示器提供信号的电子元件为视频适配器（video display adapter）。通常在计算机中，视频适配器是独立存在的，它们拥有自己的电路板，也就是我们常说的显卡（video board）。 表面看来，视频显示器或电视机的二位图像很复杂，但实际上它是由一束连续的光束涉嫌迅速扫描屏幕而形成的。射线从屏幕左上角开始，从左到右进行扫描，到达屏幕边缘后又折回向左，进行第二行扫描。当完成了对最后一行的扫描时，射线不会停下来，它会从屏幕的右下角返回到屏幕的左上角（垂直），并重复上一过程。就拿美国的信号来说，每秒钟要进行60次这样的扫描。由于扫描的速度很快，所以不会看到图像出现闪烁的现象。 电视采用的隔行扫描技术。帧是一个完整的静态视频图像，两个场才能形成一个单独的帧。整个镇的扫描线分由两个场来完成——偶数扫描线属于第一个场，奇数扫描线属于第二个场。水平扫描频率，就是扫描每个水平行的速率，例如15750Hz。把这个数除以60Hz，结果是262.5行，这正是每个场所包含的扫描线的数目，这个帧的扫描线的数目是场的两倍，也即525行。 不管隔行扫描技术是怎么实现的，组成视频的图像的连续射线都是由一个连续的信号所控制。虽然一套电视节目的声音和图像部分是一起播出的，但若想把它们从广播出去或者通过有线电视系统传送出去，就不得不分开进行。 黑白电视机的视频信号十分简单。每秒钟扫描60次，扫描信号包含一个垂直同步脉冲（vertical sync pulse），用来指示一个场的开始。这个脉冲位0V，宽度约为400ms。相比较而言，水平同步脉冲（horizontal sync pulse）则用来指示每个扫描行的开始：视频信号为0V,宽度为5ms，每秒钟出现15750次。在两个水平同步脉冲之间，信号的电压是在0.5~2.0V范围变化的，其中0.5V表示黑色，2.0V表示是白色，处于两者之间的电压则表示一定的灰度。 电视能响应的信号变化频率是有上限的我们成这一上限位电视机带宽。带宽限制了视频信号从黑到白又回到黑这一变化的速率。 从计算机的角度来说，我们可以把视频图像想象成有离散点组成的矩形网格，这些离散点称为像素（picture element）。 如果电视机的带宽为4.2Mhz，它就允许2个像素每秒420万次的变化，或者——用2*42000000除以水平扫描速率15750——每个水平扫描行有533个像素。但并不是所有的像素都可用，约1/3的像素被隐藏了起来，这样算来，水平扫描行上可用的像素约为320个。 与水平方向类似，垂直方向上525个像素也不是都可用，垂直方向上有着合理的像素数目200。 因此我们可以说，早期普通电视机的视频适配器的分辨率是320×200，即水平方向上有320个像素、垂直方向上有200个像素。 每个字符用8*8的网格（64个像素）来表示。每个字符都被定义位一个7位的ASCII码，但每个字符也与64位比特（位）相关，这64比特决定了字符会显示为什么样子。 字符生成器也是视频适配器板上的一部分，包含了所有ASCII码字符的像素图。通常，它是只读存储器（read-only memory），即ROM。它是一种集成电路，在生产时里面已经填入了数据，固定的地址输出的数据是不变的。ROM中并没有数据输入信号，这点与RAM不同。 上述的显示适配器需要多大的RAM呢？视频显示器的没屏幕能显示25行、每行40个字符，总共1000个字符，每个字符有7位的ASCII码。1000*7bit，大约1024字节，即1KB。 你可以把ROM看做可以进行代码转换的电路。每片ROM都有7个地址信号（用来表示ASCII码）以及64个数据输出信号，里面存储了128个ASCII码字符的8*8像素图。因此，ROM可以实现7位ASCII码到64位码（定义了字符现实的外观）的转换。但是64个数据输出信号会使芯片变得很大。更合适的做法是，用10个地址信号和8个输出信号。其中7个地址信号是用来确定ASCII码字符的（这个7个地址位来自视频板上RAM的数据输出）。其他三个地址信号则用来表示行。举个例子来说，最高行用000表示，最低行用111表示。8个输出就是每行的8个元素。 ASCII码为41h，大写字母A。总共有8行，每行8位。下表给了字母A的10位地址和数据输出信号。 地址 数据输出 1000001 000 00110000 1000001 001 01111000 1000001 010 11001100 1000001 011 11001100 1000001 100 11111100 1000001 101 11001100 1000001 110 11001100 1000001 111 00000000 0 1 2 3 4 5 6 7 8 1 * * 2 * * * * 3 * * * * 4 * * * * 5 * * * * * * 6 * * * * 7 * * * * 8 像不像一个大写的A！！！ 有的显示适配器不仅仅只显示文本，还可以显示其他数据，我们称这样的显示适配器位图形适配器（图形显卡）。通过向图像显卡的RAM写入数据，微处理器就可以画出图形了。320*200的图形显卡有64000个像素，如果每个像素需要1位RAM，那么这样的图形显卡就需要64000位的ram，即8000字节。然而，这只是最低的要求。1位是和1个像素相对应的，只能用来表示两种颜色——例如黑色和白色。 电视机不仅仅显示黑色和白色，还可能显示不同灰度的色彩。为了让图像显卡拥有这种功能，通常每个像素对应的RAM中的一整个字节，其中00h表示黑色，FFh表示的是白色，介于两者之间的数值对应不同的灰度。一个320*20的视频版若能显示256中灰度，就需要64000字节的RAM。 如果想要显示出丰富多彩的颜色，每个像素需要至少3个字节，因为每种颜色都是由红、绿、蓝三原色的不同组合而形成的。这么算来，就需要192000字节的RAM。 颜色数量 = 2的每个像素赋予的比特数次方 电影图像的宽比高多出1/3.图像的宽和高之比，称为屏幕长宽比。通常，我们把爱迪生和迪克生所确定的这个表示为1.33：1，或者不想使用小数点的话，就表示位4：3。 其实键盘上的每个按键就是一个简单的开关。按键按下，开关就会闭合。现在个人计算机的键盘有100多个按键，但类似打字机的键盘可能只有48个按键。 键盘硬件提供的代码为扫描码（scan code）。当按下键盘的某个按键时，一小段计算机程序就会计算出这个按键对应的ASCII。 如果键盘上有64个键，就需要6位的扫描码，也就需要一个6位的几乎器，因为2^6=64。用一个3-8译码器和一个8-1选择器就可以把这些按键组成一个8×8的阵列。如果键盘上的数目为65~128个，就需要7位的扫描码。你就可以用一个4-16译码器和一个8-1的选择器（或一个3-8译码器和一个16-1选择器）把这些按键组成一个8×16的阵列。 介绍一下能够长期存储信息的外围设备。前面曾提到，无论是用继电器、电子管，还是用晶体管作为介质构成随机访问存储器，一旦掉电，他存储的内容就会丢失。长期以来，人们通过在纸上或卡片上打孔来保存永久信息。 打孔卡带和纸带的使用存在一些问题：不可重用性，效率很低。 磁介质存储器（magnetic storage）逐渐发展成目前最为流行的长期存储器。录音电话机，声音通过电磁特和可变长度的金属丝来记录，它根据声音的高低来磁化金属丝。当磁化的金属丝切割电磁线圈运动的时候，产生的电流强度与其磁化程度有关。不论使用何种磁化介质，记录和读取信息都是利用电磁铁的磁头（head）来完成的。 将铁粒子覆盖在很长度纸带上，不久以后，纸带被强度更高的醋酸盐纤维取代，而一种更耐久、更知名的记录介质从此诞生——卷轴式磁带。 想要快速移动到磁带的任一位置是不可能的，它只能顺序访问，频繁地快进和倒带会话费很多时间。 从几何学角度来看，磁盘是能够实现快速访问的介质。磁盘围绕其中心旋转，连到臂上的一个或多个磁头从磁盘外沿向中间移动，通过磁头可以快速访问磁盘上的任何区域。 磁盘分为软盘（floppy disk）和硬盘（hard disk， 或fixed disk）。软盘是由单面覆盖磁性物质的塑料片组成，外面是由厚纸板包装，起到保护作用。使用软盘时候，必须将其插入到软盘驱动器。 硬盘是由多个金属磁盘构成的，他永久驻留在驱动器里。相对于软盘来说，它的存取速度更快、存储量更大，唯一的缺点就时硬盘本身是固定的，不能移动。 磁盘的表面被划分为许多同心圆，称为磁道（tracks），每个磁道又被划分为像圆饼切片形状的扇区（sectors），每个扇区可以存放一定数量的字节，统称为512字节。 为了能和微处理器交互数据，这些电气接口与微处理器之间还需要有额外的接口与之相连。这些接口都利用DMA（direct memory access）技术来使用总线，DMA可以不经过微处理器，实现数据在随机访问存储器和硬盘之间直接传送。这样的传送是以块位单位进行的，每次传输的块大小是磁盘扇区自己的倍数，通常是512字节。 memory（内存）仅仅表示半导体随机访问存储器；storage（存储器）用来指任何的存储设备，通常包括软盘、硬盘和磁带。 当微处理器发出一个地址信号，通常是寻址随机访问存储器，而非磁介质存储器。微处理器不能直接从磁盘读取数据，需要将所需的数据从磁盘调入内存（随机访问存储器），然后才能对其访问，当然这需要额外的步骤。微处理器需要执行一段小程序，这段小程序会访问磁盘，并将数据从磁盘调入内存。 关于随机访问存储器和磁介质存储器之间的差别，有个形象的比喻可以帮助我们加深理解：随机访问存储器就想办公桌的桌面，上面的任何东西都可以拿来直接使用；而磁介质存储器就行一个文件柜，里面的东西不能直接使用，如果想要使用放在文件柜里的某件东西，你需要站起来，走到文件柜面前，查找需要的文件，然后带回桌面。如果桌面太拥挤，没有空间放置需要的文件，还需要把桌面上暂时不用的东西线放回到文件柜中。","tags":[{"name":"编码(隐匿在计算机软硬件背后的语言)","slug":"编码-隐匿在计算机软硬件背后的语言","permalink":"http://yoursite.com/tags/编码-隐匿在计算机软硬件背后的语言/"},{"name":"微处理器和RAM之间的调用","slug":"微处理器和RAM之间的调用","permalink":"http://yoursite.com/tags/微处理器和RAM之间的调用/"},{"name":"图像的形成","slug":"图像的形成","permalink":"http://yoursite.com/tags/图像的形成/"},{"name":"磁盘","slug":"磁盘","permalink":"http://yoursite.com/tags/磁盘/"}]},{"title":"20 ASCII码和字符转换","date":"2017-11-12T16:00:00.000Z","path":"2017/11/13/code_20/","text":"数字计算机中断存储器唯一可以存储的是比特，因此如果要想在计算机上处理信息，就必须把它们按位存储。 1874年由法国电报服务公司职员埃米尔·波多发明了可以打印的电报机，划时代的波多电传码也应运而生。。即使在今天看来，这种编码十分“经济划算”，每一个文本字符都采用5位编码。 十六进制 Baudot字符 十六进制 Baudot 字符 00 10 E 01 T 11 Z 02 回车 12 D 03 O 13 B 04 空格 14 S 05 H 15 Y 06 N 16 F 07 M 17 X 08 换行 18 A 09 L 19 W 0A R 1A J 0B G 1B 数字转义符号 0C I 1C U 0D P 1D Q 0E C 1E K 0F V 1F 字符转义符号 是打印机的滑架回到起始位置，这样打印下一行可以从纸的最左边开始，这就是回车。将打印机的滑架移至正在使用中的位置的下一行，这就是换行。这两个操作构成了键盘上的enter键。 数字转义编码后的所有的编码都会被解释位数字或标点符号。 十六进制 Baudot字符 十六进制 Baudot 字符 00 10 3 01 5 11 + 02 回车 12 身份不明 03 9 13 ? 04 空格 14 ‘ 05 # 15 6 06 , 16 $ 07 . 17 / 08 换行 18 - 09 ) 19 2 0A 4 1A 响铃 0B &amp; 1B 数字转义符号 0C 8 1C 7 0D 0 1D 1 0E : 1E ( 0F = 1F 字符转义符号 使用转义码会出现很多麻烦。 所有的大小写字母加起来共需52个编码，0~9数字需要10个编码，加起来共62个，如果算上一些标点符号，数量超过了64个，也就是说，一个编码至少需要64比特。但无论如何字符数应该不超过128个，而且应该远远不够128个，也就是说编码长度不会超过8位。所以答案就是7。在采用7位编码时，不需要转义字符，而且可以区分字母的大小写。 这种标准已经存在并且被广泛使用，它被称为美国信息交换标准码（American Standard Code for Information Interchange），简称为ASCII码。 十六进制 ASCII 字符 十六进制 ASCII 字符 20 空格 30 0 21 ! 31 1 22 “ 32 2 23 # 33 3 24 $ 34 4 25 % 35 5 26 &amp; 36 6 27 ‘ 37 7 28 ( 38 8 29 ) 39 9 2A * 3A : 2B + 3B ; 2C , 3C &lt; 2D - 3D = 2E . 3E &gt; 2F / 3F ? 十六进制 ASCII 字符 十六进制 ASCII 字符 40 @ 50 P 41 A 51 Q 42 B 52 R 43 C 53 S 44 D 54 T 45 E 55 U 46 F 56 V 47 G 57 W 48 H 58 X 49 I 59 Y 4A J 5A Z 4B K 5B [ 4C L 5C \\ 4D M 5D ] 4E M 5E ^ 4F O 5F _ 十六进制 ASCII 字符 十六进制 ASCII 字符 60 ` 70 p 61 a 71 q 62 b 72 r 63 c 73 s 64 d 74 t 65 e 75 u 66 f 76 v 67 g 77 w 68 h 78 x 69 i 79 y 6A j 7A z 6B k 7B { 6C l 7C 6D m 7D } 6E n 7E ~ 6F o 在ASCII码中，一个大写字母与其对应的小写字母的ASCII码值相差20h。这种规律大大简化了程序代码的编写。 如果一个小写字母在累加器A中，把它转换成大写字母，有两种方法。第一种：SBI A, 20h第二种：ANI A, DFh ANI指令是用来”与”一个立即数。在上面的例子中，累加器中的数值与DFh执行按位与操作，其中DFh转成成二进制数就是1101 1111。除了自左向右数的第3位被置为0外，A中的其他位军被保留。通过将这一位置为0，我们是实现了将小写字母的ASCI码转换成大写字母的目的。 十六进制编码 缩写 控制字符的含义 00 NUL 空字符 01 SOH 标题开始 02 STX 文本开始 03 ETX 文本结束 04 EOT 传输中止 05 ENQ 询问 06 ACK 应答 07 BEL 响铃 08 BS 回退 09 HT 水平制表 0A LF 换行 0B VT 垂直制表 0C FF 换页 0D CR 回车 0E SO 移出 0F SI 移入 10 DLE 转义 11 DC1 设备控制1 12 DC2 设备控制2 13 DC3 设备控制3 14 DC4 设备控制4 15 NAK 否定应答 16 SYN 同步 17 ETB 块传输结束 18 CAN 取消 19 EM 媒介取消 1A SUB 替代字符 1B ESC 跳出 1C FS 文件分割或信息分割4 1D GS 组分割或信息分割3 1E RS 记录分割或信息分割2 1F US 单元分割或信息分割1 7F DEL 删除 TAB的作用就是在下一个水平位置即在距前一个字符的间距为字符长度8倍的位置打印下一个字符。 有一些控制字符甚至沿用至今，例如换页符，它使得打印机跳出当前页，并开始准备打印下一页。 回退符可以用来打印复合字符，比如说声调。 回车符使得打印头移至当前页面的最左端，换行符使打印头转移至当前位置下一行。这两个控制符都使得打印头移至新的一行。单独使用回车符可以在现有行上打印，而单独使用换行符可以跳到下一行，无需移动到最左端。 在ASCII码刚刚问世的那个时代，存储器的价格贵的令人咋舌，有一些观点认为ASCII码可以采用6位编码并配合转义字符来使用，这样既可以区分大小写又节约了存储器。这种方案并没有被采纳，当时还有一些人认为ASCCI码应采用8位编码。今天看来，8位的字节存储已经作为了一种标准。尽管ASCCI码从技术的本质上来看是7位编码，但仍以8位的形式存储。 尽管ASCCI码是计算机领域最重要的标准，但它并不是十全十美的，因为它太 美国化了！ASCII码中包含美元符号，而英镑符号怎么办？ 近十年来出现了不同版本的扩展的ASCII码，多个不同的版本严重影响了编码的一致性，导致了混淆和不兼容。 Unicode（统一化字符编码标准）。相对于ASCII的7位编码，Unicode采用了16位编码，每一个字符需要2个字节。编码范围为0000h~FFFFh，总共可以表示65536个不同字符。","tags":[{"name":"编码(隐匿在计算机软硬件背后的语言)","slug":"编码-隐匿在计算机软硬件背后的语言","permalink":"http://yoursite.com/tags/编码-隐匿在计算机软硬件背后的语言/"},{"name":"ASCII码","slug":"ASCII码","permalink":"http://yoursite.com/tags/ASCII码/"}]},{"title":"19 两种典型的微处理器","date":"2017-11-11T16:00:00.000Z","path":"2017/11/12/code_19/","text":"微处理器是将计算机中央处理器的所有构件整合在一起，集成在一个硅芯片上。 8080中，加载指令和保存指令的操作码分别是3Ah和32h，它们的助记符分别是STA（Store Accumulator） 和LDA（Load Accumulator）： 操作码 指令 32 STA [aaaa], A 3A LDA A, [aaaa] 8080芯片的微处理器的内部除累加器外还设置了6个寄存器（register），每个寄存器可以放一个8位数。这些寄存器和累加器非常相似，事实上累加器被视为一种特殊的寄存器。这个6个寄存器和累加器一样，本质上都是锁存器。 通常把两个8位的寄存器H和L合起来构成一个16位的寄存器对（register pair），称作HL，H用来保存高字节而L用来保存低字节。这个16位的值通常用来对存储器寻址。 很多计算机程序都同时用到多个数据，将这些数据存存放在寄存器比存放在存储器更便于访问，因为程序访问内存的次数越少其执行速度越快。 MOV指令主要用来把一个寄存器中的内容转移到另一个寄存器（也可能就是原来的寄存器）。 操作码 指令 操作码 指令 40 MOV B,B 50 MOV D,B 41 MOV B,C 51 MOV D,C 42 MOV B,D 52 MOV D,D 43 MOV B,E 53 MOV D,E 44 MOV B,H 54 MOV D,H 45 MOV B,L 55 MOV D,L 46 MOV B,[HL] 56 MOV D,[HL] 47 MOV B,A 57 MOV D,A 48 MOV C,B 58 MOV E,B 49 MOV C,C 59 MOV E,C 4A MOV C,D 5A MOV E,D 4B MOV C,E 5B MOV E,E 4C MOV C,H 5C MOV E,H 4D MOV C,L 5D MOV E,L 4E MOV C,[HL] 5E MOV E,[HL] 4F MOV C,A 5F MOV E,A 60 MOV H,B 70 MOV [HL],B 61 MOV H,C 71 MOV [HL],C 62 MOV H,D 72 MOV [HL],D 63 MOV H,E 73 MOV [HL],E 64 MOV H,H 74 MOV [HL],H 65 MOV H,L 75 MOV [HL],L 66 MOV H,[HL] 76 HLT 67 MOV H,A 77 MOV [HL],A 68 MOV L,B 78 MOV A,B 69 MOV L,C 79 MOV A,C 6A MOV L,D 7A MOV A,D 6B MOV L,E 7B MOV A,E 6C MOV L,H 7C MOV A,H 6D MOV L,L 7D MOV A,L 6E MOV L,[HL] 7E MOV A,[HL] 6F MOV L,A 7F MOV A,A LDA A, [aaaa]MOV B, [HL]第一种方式称做直接寻址；第二种方式称做间接寻址。 MOV操作码由8位组成：01dddsss其中ddd这3位是目标操作数的代码，sss这3位是源操作数的代码。它们所表示的意义如下：000 = 寄存器 B001 = 寄存器 C010 = 寄存器 D011 = 寄存器 E100 = 寄存器 H101 = 寄存器 L110 = 寄存器 HL 保存的存储器地址中的内容111 = 累加器 A 例如，指令MOV L, E 对应的操作码是01101011 用十六进制表示是6B。这与前面的表格是一致的。 可以设想一下，在8080内部可能是这样的：标记为sss的3位用于8-1数据选择器，标记为ddd的3位用来控制3-8译码器以此确定哪一个寄存器锁存了值。 寄存器B和C也可以组成16位的寄存器对BC，同样还可以用D和E组成寄存器对DE。如果这些寄存器对也包含要读取或保存的字节的存储器地址，可以用一下的指令实现： 操作码 指令 操作码 指令 02 STAX [BC], A 0A LDAX A, [BC] 12 STAX [DE], A 1A LDAX A, [DE] 另一种类型的传送指令称做传送立即数，它的助记符写作MVI。传送立即数指令是一个双字节指令，第一个字节为操作码，第二个是数据。这个单字节数据从存储器转移到某个寄存器，或转移到存储器的某个单元，改存储单元由HL寄存器对寻址。 操作码 指令 06 MVI B, xx 0E MVI C, xx 16 MVI D, xx 1E MVI E, xx 26 MVI H, xx 2E MVI L, xx 36 MVI [HL], xx 3E MVI A, xx MVI E, 37h 执行后，寄存器E存放的字节就是37h。这就是立即数寻址。 加法（ADD）、进位加法（ADC）、减法（SUB）和借位减法（SBB） 操作码 指令 操作码 指令 80 ADD A, B 90 SUB A, B 81 ADD A, C 91 SUB A, C 82 ADD A, D 92 SUB A, D 83 ADD A, E 93 SUB A, E 84 ADD A, H 94 SUB A, H 85 ADD A, L 95 SUB A, L 86 ADD A, [HL] 96 SUB A, [HL] 87 ADD A, A 97 SBB A, A 88 ADC A, B 98 SBB A, B 89 ADC A, C 99 SBB A, C 8A ADC A, D 9A SBB A, D 8B ADC A, E 9B SBB A, E 8C ADC A, H 9C SBB A, H 8D ADC A, L 9D SBB A, L 8E ADC A, [HL] 9E SBB A, [HL] 8F ADC A, A 9F SBB A, A CF(进位标志位)、ZF（零标志位）、SF（符号标志位）、PF（奇偶标志位）、AF（辅助仅为标志位）、 LDA、STA和MOV指令始终不会影响标志位，而ADD、SUB、ADC以及SBB指令会影响标志位的状态，集体情况如下： - 如果运算结果的最高有效位是1，那么符号位SF标志位置为1，表示该计算结果是负数。 - 如果运算结果为0，则零标志位ZF为1. - 如果运算结果“1”的位数是偶数，即具有偶数性，则奇偶标志位PF置为1；反之，如果“1”的位数是奇数，即运算结果具有奇数性，则PF置0.由于PF的这个特点，有时会被用来进行简单的错误检查。 - 当ADD和ADC运算产生仅为或者SUB和SBB运算不发生借位时，CF置为1。 - 辅助进位标志位AF只有在运算结果的低4位向高4位有进位时才置1。它只用于DAA（Decimal Adjust Accumulator， 十进制调整累加器）指令中。 操作码 指令 含义 37 STC 令CF置1 3F CMC 令CF取反 算数运算和逻辑运算指令 操作码 指令 操作码 指令 A0 AND A, B B0 OR A, B A1 AND A, C B1 OR A, C A2 AND A, D B2 OR A, D A3 AND A, E B3 OR A, E A4 AND A, H B4 OR A, H A5 AND A, L B5 OR A, L A6 AND A, [HL] B6 OR A, [HL] A7 AND A, A B7 OR A, A A8 XOR A, B B8 CMP A, B A9 XOR A, C B9 CMP A, C AA XOR A, D BA CMP A, D AB XOR A, E BB CMP A, F AC XOR A, H BC CMP A, H AD XOR A, L BD CMP A, L AE XOR A, [HL] BE CMP A, [HL] AF XOR A, A BF CMP A, A CMP指令通SUB指令类似，也是两个数相减，不同之处在于它并不在累加器中保存计算结果，计算的目的是为了设置标志位。这个标志位的值可以告诉我们两个操作数至今的大小关系。 MVI B, 25hCMP A, B指令执行后，累加器A中的值并没有变化。改变的是标志位的值，如果A中的值等于25h，则零标志位ZF置1；如果A中的值小于25h（没有发生借位），则进位标志位CF置1。 也可以对立即数进行这八种算术逻辑操作 操作码 指令 操作码 指令 C6 ADI A, xx E6 ANI A, xx CE ACI A, xx EE XRI A, xx D6 SUI A, xx F6 ORI A, xx DE SBI A, xx FE CPI A, xx 操作码 指令 27 DAA 2F CMA CMA是Complement Accumulator的简写。它对累加器按位取反。 DAA 即十进制调整累加器。DAA指令提供了一种用二进制码表示十进制的方法，成为BCD吗，程序员可以在该指令的帮助下实现十进制数的算术运算。BCD码采用的表示方法为，没4位为一段，每段所能表示的范围是：0000~1001，对应十进制的0~9。因为1字节有8位故可分割为2个段，因此在BCD码格式下，一个字节可以表示两位十进制数。 MVI A, 27hMVI B, 94hADD A, B累加器的结果是BBh，当然，这肯定不是BCD码。如果我们执行指令DAA，那么累加器最后保存的结果为21h，而且进位标志位CF置为1。因为十进制的27和94相加的结果为121。由此可以看到，使用BCD码进行十进制的算术运算是很方便的。 为了实现对一个数减1，我们把该数与FFh相加，它是-1的补码。8080提供了专门的指令用来对寄存器或存储器的数进行加1（称作增量）或减1（称作减量）操作。 操作码 指令 操作码 指令 04 INR B 05 DCR, B 0C INR C 0D DCR, C 14 INR D 15 DCR, C 1C INR E 1D DCR, E 24 INR H 25 DCR, H 2C INR L 2D DCR, L 34 INR [HL] 35 DCR, [HL] 3C INR A 3D DCR, A INR 和 DCR 都是单字节指令，它们可以影响CF之外的所有标志位。 循环移位（Rotate）指令，这些指令可以把累加器中的内容向左或向右移动1位，它们的具体操作如下： 操作码 指令 含义 07 RLC 使累加器循环左移 0F RRC 使累加器循环右移 17 RAL 带进位的累加器循环左移 1F RAR 带进位的累加器循环右移 这些指令只对进位标志位CF有影响。 假设累加器中存放的数是A7h，即二进制1010 0111。RLC指令使其每一位都向左移一位。最终的结果是，最低位（左端位低位，右端为高位）移出顶端移至尾部成为最高位。在这个例子中CF置1。执行RLC之后将变为0100 1111，同时CF置1。执行RRC之后将变为1101 0011，同时CF置1。 执行RAL指令时，累加器的数仍然按位左移，把CF中原来的值移至累加器中数值的最后一位，同时把累加器中的数据的原最高位移至CF。例如，假设累加器中一位之前的数是1010 0111且CF为0，执行RAL指令后，累加器中的数变为0100 1110而CF变为1。类似的，如果执行的是RAR指令，累加器中的数变为0101 0011而CF变为1。 当我们在程序中需要对某个数进行乘2（左移）或除2（右移）运算时，使用移位操作会使运算变得非常简单。 假设你在办公室工作，有人回到你办公桌前为你分配任务，每一项工作都用到某种文件夹。这些工作通常有这样的特点，在你完成某项工作之前首先要做另一项工作，并用到另一个文件夹。因此你只能放下第一个文件夹，并在它上面打开第二个文件夹继续工作。现在又有一个人给你分配了一个比前一项优先级跟高的工作，于是你打开第三个文件夹放在前面两个上，继续工作。而这项工作也需要先做一项相关工作，于是你只好打开第四个文件夹，现在你的办公桌上已经堆叠了四个文件夹了。 你可能已经注意到了，事实上，这些堆叠的文件夹很有序地保存了你干活的顺序轨迹。最上面的的文件夹总是代表优先级最高的工作，完成该工作之后就可以最接下来的工作了，以此类推。最后当你处理完办工桌上最后一个文件夹后，就可以回家了。 这种形式的存储器称作栈。使用栈时，我们已从底部到顶部的顺序把数据存入栈，并以相反的顺序把数据从栈中取出，因此该技术也称作后进先出存储器。 栈的功能是怎么实现的呢?首先，栈其实就是一段普通的RAM存储空间，只是这段空间相对独立不另作他用。8080微处理器设置了一个专门的16位寄存器对这段存储空间寻址，这个特殊的寄存器称为栈指针（SP, Stack Pointer）。 8080中，执行PUSH指令实际上是把16位的数据保存到栈，执行POP指令是把这些数据从栈中取回寄存器。 操作码 指令 操作码 指令 C5 PUSH BC C1 POP BC D5 PUSH DE D1 POP DE E5 PUSH HL E1 POP BC F5 PUSH PSW F1 POP PSW PUSH BC 指令将寄存器B和C的数据保存到栈，而POP BC则将这些数据从栈取回到寄存器B和C中，并且保持原来的顺序。最后一行指令中的PSW代表程序状态字，如前所述，这是一个8位的寄存器，用于保存标志位。最后一行到PUSH和POP指令的操作对象实际上是累加器和PSW，即压入和弹出栈的数据有累加器和PSW中的内容组成。如果你想把所有寄存器中的数据及全部标志位保存到栈，可以使用下面的命令：PUSH PSWPUSH BCPUSH DEPUSH HL 8080使用LXI指令为栈寄存器赋值，LXI是Load Extended Immediate的缩写即加载扩展的立即数。 操作码 指令 01 LXI BC, xxxx 11 LXI DE, xxxx 21 LXI HL, xxxx 31 LXI SP, xxxx 指令：LXI BC, 527Ah和下面两条指令等价：MVI B, 52hMVI C, 7Ah LXI指令保存一个字节。而且上表中最后一条指令LXI为栈指针赋了一个特殊的值。 类似的，还可以对寄存器对和栈指针对进行加1和减1操作，即把它们看做16寄存器。 操作码 指令 操作码 指令 03 INX BC 0B DCX BC 13 INX DE 1B DCX DE 23 INX HL 2B DCX HL 33 INX SP 3B DCX SP 下面的指令可以把任意两个寄存器组成的16位寄存器对的内容加到寄存器对HL中。 操作码 指令 09 DAD HL, BC 19 DAD HL, DE 29 DAD HL, HL 39 DAD HL, SP 这些指令可以减少操作的字节数。上面的第一条指令一般情况下需要6个字节。MOV A, LADD A, CMOV L, AMOV A, HADC A, BMOV H, ADAD指令一般用来计算存储器地址，只对进位标志位CF有影响。 接下来我们来认识一下各种各种的指令。下面两条指令的特点是操作码后面跟着2字节的地址，第一条指令把HL寄存器对的内容保存到该地址，第二条指令把该地址的内容加载到HL寄存器对。 操作码 指令 含义 22h SHLD [aaaa], HL 直接保存到HL中的数据 2Ah LhLD HL, [aaaa] 直接加载数据到HL 操作码 指令 含义 E9h PCHL PC, HL 将HL保存的数据加载到程序计数器 F9h SPHL SP, HL 将HL的数据加载到栈指针 操作码 指令 含义 E3h XTHL HL, [SP] 将HL中的内容和栈顶部2个字节进行交换 FBh XCHG HL, DE 把DE中的内容和HL中的内容进行交换 Call指令：执行指令后，程序计数器加载一个新的地址，而处理器会把原来的地址保存起来，保存到何处呢？最好的选择自然是栈了。 栈中保存的地址可以使处理器最后返回到转移前的位置。用于返回的指令称为Return（返回）。Return指令从栈中弹出两个字节，并把它们加载到PC中，这样就完成了返回到跳转点的工作。 在Call和Return指令的帮助下，程序员可以在程序中使用子程序，子程序是一段频繁使用的完成特定功能的代码。对于汇编语言来说，子程序是其基本的组成部分。 条件 操作码 指令 操作码 指令 操作码 指令 None C9 RET C3 JMP aaaa CD CALL aaaa Z not set C0 RNZ C2 JNZ aaaa C4 CNZ aaaa Z set C8 RZ CA JZ aaaa CC CZ aaaa C not set D0 RNC D2 JNC aaaa D4 CNC aaaa C set D8 RC DA JC aaaa DC CC aaaa Odd parity E0 RPO E2 JPO aaaa E4 CPO aaaa Even parity E8 RPE EA JPE aaaa EC CPE aaaa S not set F0 RP F2 JP aaaa F4 CP aaaa S set F8 RM FA JM aaaa FC CE aaaa OUT（输出）指令把累加器中的 内容写入到紧跟该指令后的字节所寻址的端口（port）。IN（输入）指令把一个字节从端口读入到累加器。它们的格式如下所示。 操作码 指令 D3 OUT PP DB IN PP 外围设备有时候需要获得处理器的注意。例如，当你按下键盘的某个键时，处理器应该马上注意到这个事件。这个过程由一个称为中断（interrupt）的机制实现，这是一个由外围设备产生的信号，连接至8080的INT输入端。 但是，当8080复位后，就不再响应中断。程序必须执行EI（Enable Interrupt）指令来允许中断，然后执行DI（Disable Interrupts）禁止中断。 操作码 指令 F3 DI FB EI 操作码 指令 操作码 指令 C7 RST 0 E7 RST 4 CF RST 1 EF RST 5 D7 RST 2 F7 RST 6 DF RST 3 FF RST 7 上面列出的指令都称为Restart（重新启动）指令，在其执行的过程中也会把当前PC中的数据保存到栈，这一点与CALL指令类似。但Restart指令在保存PC数据之后会立刻跳转到特定的地址，而且是根据参数的不同跳转到不同的地址：比如RST 0 将跳转到地址0000h处，RST 1将会跳转到地址0008h，一次类推，最后的RST 7 将跳转到0038h处。这些地址存放的代码都是用来处理中断的。例如，由键盘引起的中断将执行RST 4指令，程序将跳转到地址0020处，改地址存放的代码将负责从键盘读入数据。 操作码 指令 00 NOP NOP代表no op（operation）。无操作。NOP指令使处理器什么操作也不执行。 6800有一个16位的程序计数器PC、一个16位的栈指针SP、一个8位的状态寄存器（用来保存标志位），以及两个8位的累加器A、B。A和B都可以用做累加器（而不是把B作为普通的寄存器）。与8080不同，6800没有设置其他的8位寄存器。 6800设置了一个16位的索引寄存器，它可以用来保存16位的地址，其功能与8080的HL寄存器对相似。 6800实现的操作和8080大致相同，但对应的操作码和助记符是完全不同的。 8080假设低字节在前，高字节在后；而6800假设高字节在前，低字节在后。这两种方式分别称为little-endian（Intel方式）和big-endian（Motorola方式）。 微处理器的晶体管数量没18个月翻一倍，人们不禁要问：增加的这些大量的晶体管用来做什么呢？ 一些晶体管用来适应处理器不断增加的数据宽度——从4位、8位、16位到32位；另外一些新增的晶体管用来应对新的指令。例如支持浮点数的指令；还有在屏幕上呈现图片和电影。 现代处理器包括一个Cache（高速缓冲存储器），它是一个设置在处理器内部，访问速度非常快的RAM阵列，用来存放处理器最近要执行的指令。 上面提到的这些都需要在处理器内部增加更多的逻辑组件和晶体管。","tags":[{"name":"编码(隐匿在计算机软硬件背后的语言)","slug":"编码-隐匿在计算机软硬件背后的语言","permalink":"http://yoursite.com/tags/编码-隐匿在计算机软硬件背后的语言/"},{"name":"8080","slug":"8080","permalink":"http://yoursite.com/tags/8080/"},{"name":"6800","slug":"6800","permalink":"http://yoursite.com/tags/6800/"},{"name":"汇编语言","slug":"汇编语言","permalink":"http://yoursite.com/tags/汇编语言/"}]},{"title":"18 从算盘到芯片","date":"2017-11-10T16:00:00.000Z","path":"2017/11/11/code_18/","text":"算盘计算。 对数：两个数乘积就可以简单地表示为其对数之和。 一些人设计一些小装置期望代替对数表。其中，一种带对数刻度的滑尺久负盛名。 差分机和解析机。 人口普查：利用卡片上的288个穿孔来存储288位信息。 用继电器来构建计算机，被称为机电化计算机。资金的花费、空间的占用和能源的耗费。 真空管代替继电器。价格昂贵、耗电量大，以及产生的热量太多。 晶体管代替真空管。体积小、耗电量低，以及持久耐用。 集成电路需要经过复杂的工艺流程才能被制造出来，包括将硅片分层，然后非常精确地掺入杂质以及蚀刻不同的区域形成微小组件。 使用集成电路在一块电路板上制造一个完成的计算机处理器。 衡量微处理器性能的三个标准：（1） 4004是一个4位微处理器，这意味着处理器中数据通路宽度是4位。每次做加、减运算时，他只能处理4位的数字。（2） 4004每秒最大时钟频率为108, 000周期，即108KMz。也成主频。时钟频率决定了执行一条指令所需要的时间。（3） 4004的可寻址存储器只有640字节。","tags":[{"name":"编码(隐匿在计算机软硬件背后的语言)","slug":"编码-隐匿在计算机软硬件背后的语言","permalink":"http://yoursite.com/tags/编码-隐匿在计算机软硬件背后的语言/"},{"name":"微处理器的发展","slug":"微处理器的发展","permalink":"http://yoursite.com/tags/微处理器的发展/"}]},{"title":"17 自动操作","date":"2017-10-31T16:00:00.000Z","path":"2017/11/01/code_17/","text":"如果要把100个二进制加起来，你必须端坐在加法器前，并且耐心地输入所有的数并累加起来。但是当你终于完成时，却发现其中有两个数错了，而你只能重复一遍所有的功能。 如果把这100个二进制数输入到RAM阵列中而不是直接输入到加法器中，一旦修改一些数据，我们的功过将会变得容易的多。 用一个16位的计数器（第十四章构造的那种）就可以控制RAM阵列的地址信号。 我们没有办法使它停下来，在某一个时刻，RAM中剩余的所有待加之数都是00h，于是灯泡将不再“闪烁”。这时，你可以读取二进制的运算结果。但是当计数器达到FFFFh时，它会重新回滚到0000h，这时自动加法器会再一次把所有的数累加到已经计算出来的结果中去。 另外它只能做加法运算，并且只能做8位数的加法。 如果你不需要把100个数加在一起呢？如果你想做的是用自动加法器把50对数分别相加，得出50个不同的结果呢？ 先前的自动加法器都是用连接在锁存器的灯泡来显示运行结果的，但是如果你想对50对数分别求和的时候，这就不是一个好办法了。你可能会想到把运算结果存回到RAM阵列中。 如何配置一个自动加法器，使它不仅仅可以对一对数字做累加运算，还希望它能够自主确定要累加多少个数字，而且还能记住在RAM中存放了多少个计算结果。 我们希望它能做四件事：进行加法操作，首先它要把一个字节从存储器中传送到累加器中，这个操作称为加载（Load）。第二个操作吧存储其中的一个自家加（Add）到累加器的内容中去。第三个操作把累加器中的计算结果取出并存放（Store）到存储器中。另外我们需要一个方法令自动加法器停下（Halt）。 也许存放这些代码的最简单的方法是把它们存放在一个独立的RAM中。这个RAM和第一个RAM同时被访问。但是这个RAM中要存放的是不需要求和的数，而是一些代码，用来标记自动加法器对第一个RAM中指定地址要做的一种操作。这两个RAM可以分别被标记为“数据”RAM和“代码”RAM。 操作码 代码 Load（加载） 10h Store （保存） 11h Add （加法） 20h Halt （停止） FFh 以前8位加法器的输出是8位锁存器的输入，但现在为了执行Load指令，数据RAM阵列的输出有时也要作为8位锁存器的输入，这个新的变化需要一个2-1选择器来实现。 RAM阵列输出是Load指令，选择数据RAM的输出。只有当操作码是指令Store时，数据RAM的“写”（W）输入必须是1。 利用最少的附加硬件和一些新增的代码，可以让这个电路从累加器中减去一个数。第一步就是想操作码表增加一些代码。 操作码 代码 Load（加载） 10h Store （保存） 11h Add （加法） 20h Subtract （减法） 21h Halt （停止） FFh 对于Add和Subtract的代码，其区别就是最低有效位。如果操作码为21h，除了数据RAM阵列的数据传入加法器之前要取反，并且加法器进位输入置位1之外，电路所做的操作与执行Add指令所做的操作相同。 还有一个问题：加法器及连接到它的所有设备的宽度只有8位。以前提出过的一个解决办法是把两个8位加法器（其他的大部分设备也用两个）连在一起，构成一个16位的设备。 还有代价更小的解决方法，加入你想把两个16位的数相加，比如76ABh + 232Ch。这种16位的加法先单独处理最右边的字节，通常称为低字节，ABh+2Ch= D7h。然后再计算最左边的字节，即高字节的和：76h+23h=99h。得到相同的结果99D7h。 这里还有一个问题，就是低字节相加有时会产生一个进位，我们需要做的就是在第一步运算时保存低字节数运算的进位输出，并把它作为下一步高字节数运算的进位输入。如何保存1位呢？1位锁存器就是最好的选择了，该锁存器被称为进位锁存器。 为了使用进位锁存器，我们还需要另一个操作码，称之为“进位加法”。如果进行16位数的减法运算，则还需要一个新的指令，称为“借位减法”。 操作码 代码 Load（加载） 10h Store （保存） 11h Add （加法） 20h Subtract （减法） 21h Add With Carry （加法） 20h Subtract With Borrow（减法） 21h Halt （停止） FFh 增加了两个新的操作码之后，不再局限于8位数的加运算。通过执行进位加法操作，可以对16位数、24位数、32位数、40位数，甚至更多位数进行加法运算。假如要进行两个32位数加法运算，我们仅需要1条Add指令和3条Add with Carry指令。 当前的设计的自动加法器不允许在随后的计算中重复使用前面的计算结果。这个求和结果已经不能被访问了，每次我们使用它的时候都必须重新计算。 产生上述原因就在于我们构造的自动加法器具有如下的特性：它的代码存储器和数据存储器是同步的、顺序的，并且都从0000h开始寻址。代码存储器中的每一条指令对应数据存储器中相同地址的存储单元。一旦执行了一条store指令，相应的，就会有一个数被保存到数据存储器中，而这个数将不能重新加载到累加器中。 每个操作码在存储器中占1个字节。现在除了Halt操作外，每个指令在存储器中占据3个字节的空间，其中第一个字节为代码本身，另外两个字节用来存放1个16位存储器单元地址。对于Load指令，后两个字节保存的地址用来指明数据RAM阵列的一个存储单元，该单元存放的是需要被加载到累加器中的字节。 设计的关键是把代码RAM阵列的数据输出到3个8位锁存器中。每个锁存器保存改3字节指令的一个字节。第一个锁存器保存指令本身，第二个和第三个锁存器的输出构成了数据RAM阵列的16位地址。 每条指令的长度是3个字节。因此每次从存储器取回一个字节，所以取每条指令需要的时间为3个时钟周期，一个完整的指令周期需要4个时钟周期。而且，操作码和操作数可以存放在同一个RAM阵列。 通常，指令从0000h开始存放，这是因为计数器复位后从该位置访问RAM阵列。加入你计算了三个数的结果，你现在想利用这个结果，你可能需要把halt指令去掉，新增一个Load指令，然后再增加一条Add指令、Store指令和一条心的Halt指令。 也许你更想在其他的位置增加这些指令，而不是紧跟着这些指令来存放。可以用一条名为Jump（跳转）的新指令来替换Halt指令。 操作码 代码 Load（加载） 10h Store （保存） 11h Add （加法） 20h Subtract （减法） 21h Add With Carry （加法） 22h Subtract With Borrow（减法） 23h Jump（跳转 ） 30h Halt （停止） FFh 无论何时，只要自动加法器遇到Jump指令，计数器就会被强制输出改Jump指令后的16位地址。可以同过d型边沿触发器的预置和清零输入来实现。我们需要为16位计数器的每一位设置一个这样的触发器。一旦加载了某个特定的值，计数器就会从该值开始计数。 从RAM阵列锁存得到的16位地址既可以作为2-1选择器的输入，也可以作为16位计数器置位信号的输入。 毋庸置疑，Jump指令很有用。但与之相比，一个在我们想要的情况下跳转的指令更加有用，这种指令称作条件跳转。也许说明该命令重要性的最好方法是这样一个问题：怎样让自动加法器进行两个8位数的乘法运算？ 你可以先写6条指令，这6条指令是一次相乘后的结果，可以把这6条指令连续输入几次。也可以将复位键连续按几次得到最终结果。当然，这两种方法都不理想。 我们需要这样一种Jump指令，它只让过程重复执行所需要的次数，这种指令就是条件跳转指令。零锁存器存1一个数，称作零标志位。当加法器的输出全部为0时，零标志位等于1；当加法器的输出不全为0时，零标志位位0。 操作码 代码 Load（加载） 10h Store （保存） 11h Add （加法） 20h Subtract （减法） 21h Add With Carry （加法） 22h Subtract With Borrow（减法） 23h Jump（跳转 ） 30h Jump If Zero（零转移 ） 30h Jump If Carry（进位转移 ） 30h Jump If Not Zero（非零转移 ） 30h Jump If Not Carry（无进位转移） 30h Halt （停止） FFh Load指令的代码10h，称作机器码，或机器语言。 机器码都分配了对应的简短助记符，这些助记符都用大写字母来表示。 操作码 代码 助记符 Load（加载） 10h LOD Store （保存） 11h STO Add （加法） 20h ADD Subtract （减法） 21h SUB Add With Carry （加法） 22h ADC Subtract With Borrow（减法） 23h SBB Jump（跳转 ） 30h JMP Jump If Zero（零转移 ） 30h JZ Jump If Carry（进位转移 ） 30h JC Jump If Not Zero（非零转移 ） 30h JNZ Jump If Not Carry（无进位转移） 30h JNC Halt （停止） FFh 左边称为目标操作数，右边的操作数称为源操作数LOD A, [1003h] A代表累加器，把地址1003上的字节加载到累加器中ADD A, [001Eh] 把001Eh地址的字节加到累加器中STO [1003h], A 把累加器中的内容保存到1003h地址JNZ 0000h 如果零标志不是1则跳转到0000h地址处，这里没有用方括号，因为跳转指令要转移的地址是0000h，而不是保存于0000h的值，即0000h地址就是跳转指令的操作数 通过一个十六进制地址后面加一个冒号，可以表示某个指令保存在某个特定地址空间，例如：0000h: LOD A, [1003h] 下面的语句表示了数据在特定地址空间的存储情况。 1000h: 00h, A7h1002h: 00h, 1Ch1004h: 00h, 00h 上面的两个字节是用逗号分开的，它表示第一个字节保存在左侧的地址空间中，第二个字节保存在改地址后的下一个地址空间中。上面三条语句等价与这条语句： 1000h: 00h, A7h, 00h, 1Ch, 00h, 00h 这里给出的是一种汇编语言。它是全数字的机器语言和指令的文字描述的一种结合体。需要手工对其汇编，得出对应的机器语言，然后通过开关把这些机器码输入到RAM阵列中并运行该程序，","tags":[{"name":"编码(隐匿在计算机软硬件背后的语言)","slug":"编码-隐匿在计算机软硬件背后的语言","permalink":"http://yoursite.com/tags/编码-隐匿在计算机软硬件背后的语言/"},{"name":"汇编语言的由来","slug":"汇编语言的由来","permalink":"http://yoursite.com/tags/汇编语言的由来/"}]},{"title":"16 存储器组织","date":"2017-10-31T09:00:00.000Z","path":"2017/10/31/code_16/","text":"之所以被称为随机访问存储器，是因为读写操作很自由，我们只需要改变地址及相关的输入，就可以从8个锁存器中读出或写入需要的数据。相反，一些其他类型的存储器必须顺序读取，也就是说，读取地址101中存储的数据之前不得不线读取存储在地址100的数据。 8×1 RAM。阵列是以1比作为存储单位，共存储8个单位数据。所以这个RAM阵列中能存储的位数等于8于1的乘积 通过共享地址的方式可以把两个8×1的RAM阵列连接起来，就得到了8×2RAM。这个RAM阵列可存储的二进制数依然是8个，但每个数的位宽是2位。 还可以把两个8×1的RAM阵列看做是两个锁存器，使用一个2-1选择器和一个1-2译码器就可以把它们按照单个锁存器连接方式进行集成，本质上扮演了第4根地址线的角色。这种结构实质是一种16×1的RAM阵列。存储容量为16个单位，每个单位占1位。 RAM阵列的存储容量与其地址输入端的数量有直接的联系。在没有地址输入端的情况下，只能存储一个单位的数据；当存在1个地址输入端时，可以存储2个单位的数据；有两个地址输入端的时候，可以存储4个单位的数据；有3个地址输入端时，可以存储8个单位的数据；有4个地址输入端时，可以存储16个单位的数据。RAM阵列的存储容量 = 2 的 （地址输入端的个数）次方 1024×8 RAM可以存储 8192个比特信息，每8个比特位一组，共分为1024个组。 从专业的角度来讲，这个RAM阵列的存储容量为1024个字节。就好比一个邮局放置了1024个邮箱，而每个邮箱里面都可以存放1字节大小的邮件。 1024字节通常简称为1千字节，1千字节代表这1024个字节，并非1000个字节。 1KB = 1024 B = 2^10 B1MB = 1024 KB = 2^20 B1GB = 1024 MB = 2^30 B1TB = 1024 GB = 2^40 B1PB = 1024 TB = 2^50 B 64K×8 RAM 为65536个字节，需要配备16位的寻址端。 一个辛辛苦苦装满65536字节珍贵数据的64K×8 RAM阵列，如果断掉电源，会发生什么事情呢？首先所有的电磁铁都将因为没有电流而失去磁性，随着“梆”的一声，金属片讲弹回原位，所有继电器将还原到未触发状态。RAM中存储的数据呢？它们将如风中残烛般消失在黑暗中。 正因为如此，随机访问存储器也被称为易失性存储器。为了保证存储的数据不丢失，易失性存储器需要恒定的电流。","tags":[{"name":"编码(隐匿在计算机软硬件背后的语言)","slug":"编码-隐匿在计算机软硬件背后的语言","permalink":"http://yoursite.com/tags/编码-隐匿在计算机软硬件背后的语言/"},{"name":"RAM","slug":"RAM","permalink":"http://yoursite.com/tags/RAM/"}]},{"title":"15 字节与十六进制","date":"2017-10-31T04:00:00.000Z","path":"2017/10/31/code_15/","text":"一个字节有8位，取值范围是00000000~11111111 字节的一半，即4比特，我们称之为半字节。 一个8位二进制数表示10110110，这种表达方式自然又直观，但它还不够简洁。 我们完全可以采用十进制表示法来表示字节，但从二进制转换到十进制需要一些列计算，计算方法并不复杂，但是比较麻烦。 二进制 八进制 000 0 001 1 010 2 011 3 100 4 101 5 110 6 111 7 10 110 1110 = 2 6 6 10110110这个字节表示为八进制数266。这种方法简洁明了，但是还是有那么一点美中不足。 如果我们将16位二进制数直接表示为八进制会得到一下结果：1 011 001 111 000 101 = 1 3 1 7 0 5 如果我们把这个16位二进制数平分为两个字节并将其分别表示为八进制会得到如下所示的不同结果。10 110 0112 6 311 000 1013 0 5 为了使多字节值能和分开表示的单字节值取得一致，我们需要一种等分单个字节的系统，按照这种思想，我们可以把每个字节等分位4组，每组2比特（基于4的计数系统）；还可以等分为2组，每组4比特（基于16比特的计数系统）","tags":[{"name":"编码(隐匿在计算机软硬件背后的语言)","slug":"编码-隐匿在计算机软硬件背后的语言","permalink":"http://yoursite.com/tags/编码-隐匿在计算机软硬件背后的语言/"},{"name":"十六进制","slug":"十六进制","permalink":"http://yoursite.com/tags/十六进制/"}]},{"title":"14 反馈与触发器","date":"2017-10-30T09:00:00.000Z","path":"2017/10/30/code_14/","text":"振荡器，也被称为时钟。 R-S 触发器 输入 输出 S \\ R Q \\ Q非 1 \\ 0 1 \\ 0 0 \\ 1 0 \\ 1 0 \\ 0 Q \\ Q非 1 \\ 1 0 \\ 0 (不符合要求) 改进后： 输入 输出 数据 \\ 保持位 Q 0 \\ 1 0 1 \\ 1 1 0 \\ 0 Q 1 \\ 0 Q 输入 输出 数据 \\ 保持位 Q 0 \\ 1 0 1 \\ 1 1 X \\ 0 Q 电平触发的D型锁存器 输入 输出 D \\ Clk Q \\ Q非 0 \\ 1 0 \\ 1 1 \\ 1 1 \\ 0 X \\ 0 Q \\ Q非 2-1选择器 选择端 A B Q 0 0 X 0 0 1 X 1 1 X 0 0 1 X 1 1 边沿触发的D型触发器D | Ckl | Q | Q非 |:-:| :-: | :-:| :-: |0 | ↑ | 0 | 1 |1 | ↑ | 1 | 0 |X | 0 | Q | Q非 | 分频器：如果这个振荡器的频率是20Hz，那么Q的输出频率是它的一半，即10Hz，由于这个原因，这种电路称为分频器。 带预置和清零功能的边沿触发的D型触发器 Pre Clr D Ckl Q Q非 1 0 X X 1 0 0 1 X X 0 1 0 0 0 ↑ 0 1 0 0 1 ↑ 1 0 0 0 X 0 Q Q非","tags":[{"name":"编码(隐匿在计算机软硬件背后的语言)","slug":"编码-隐匿在计算机软硬件背后的语言","permalink":"http://yoursite.com/tags/编码-隐匿在计算机软硬件背后的语言/"},{"name":"减法的实现","slug":"减法的实现","permalink":"http://yoursite.com/tags/减法的实现/"},{"name":"触发器","slug":"触发器","permalink":"http://yoursite.com/tags/触发器/"}]},{"title":"13 如何实现减法","date":"2017-10-30T04:00:00.000Z","path":"2017/10/30/code_13/","text":"前言这一章让我明白了很久以前的一个困惑，那就是如何把减法转化成加法的，而且为什么用取反加一来表负数。 过程253 - 176 = 77 需要借位 怎样才能不需要借位呢？999 - 176 = 823823 + 253 = 1076现在应该减去999，但是为了避免借位，应该加上1减去10001076 + 1 - 1000 = 77 将十进制转化为二进制：11111101 - 10110000 = 01001101 11111111 - 10110000 = 01001111取反的实质是求1的补码01001111 + 11111101 = 101001100101001100 + 1 - 100000000 = 01001100 加入-500~499之间，总共1000个数，这个约束说明只能用三位十进制数，且不用负号就可以表示所有需要的数字。我们并不需要用到从500到999之间的正数，因为我们所需要的数的最大值是499。因此从500到599的三位数可以用来表示负数。具体情况如下： 用500表示-500用501表示-499用502表示-498……用998表示-2用999表示-1用000表示0用001表示1用002表示2……用497表示497用498表示498用499表示499 如果999加上1就是1000。由于我们处理的是三位数，这个结果实际上是000。 这种标记称为10的补数。为了将三位负数转化为10的补数，我们用999减去它再加上1。 减一个数等于加上一个负数。利用10的补数，我们将不会再用到减法。所有的步骤都用加法来进行。 这样的机制在二进制中被称为2的补数。以8位二进制为例。范围为00000000~11111111，对应0~255。但是如果你还想表示负数的话，则以1开头的每个八位表示一个负数，如下表所示 二进制数 十进制数 10000000 -128 10000001 -127 10000010 -126 …… …… 11111101 -3 11111110 -2 11111111 -1 00000000 0 00000001 1 00000010 2 …… …… 01111101 125 01111110 126 01111111 127 计算2的补码，首先计算1的补数，然后再加1.这等价于将每位取反再加1。用同样的步骤，每位取反再加1，可以将数值还原。 一般来说，对于涉及正数和负数的加法，如果两个操作数的符号位相同，但结果的符号位不同，则结果是无效的。 总结无符号的8位二进制数所表示的范围是0~255。有符号的8位二进制表示的范围是-128~127。无论有符号还是无符号的，数字本身是无法显示的。 二进制数的麻烦之处就是他们只是一些0和1，本身并没有任何含义。","tags":[{"name":"编码(隐匿在计算机软硬件背后的语言)","slug":"编码-隐匿在计算机软硬件背后的语言","permalink":"http://yoursite.com/tags/编码-隐匿在计算机软硬件背后的语言/"},{"name":"减法的实现","slug":"减法的实现","permalink":"http://yoursite.com/tags/减法的实现/"},{"name":"补码","slug":"补码","permalink":"http://yoursite.com/tags/补码/"}]},{"title":"12 二进制加法器","date":"2017-10-29T13:00:00.000Z","path":"2017/10/29/code_12/","text":"前言如果我们可以造出加法器，同样地，就可以利用假发来实现减法、乘法和除法，计算按揭付款，引导火箭飞到火星、下棋，以及填写我们的话费账单。 过程 + 加法 0 1 0 0 1 1 1 0 + 进位 0 1 0 0 0 1 0 1 AND 0 1 0 0 0 1 0 1 利用与门可以计算两个二进制数加法的进位。 OR 0 1 0 0 1 1 1 1 NAND 0 1 0 1 1 1 1 0 或门和加法的结果很相似，除了右下角的结果。与非门和加法的结果也很相似，除了左上角的结果。 如果把 OR的结果和NAND的结果相于，那么结果就和加法的结果是一样的。实际上电路中有一个专门的名称，叫做异或门。 XOR 0 1 0 0 1 1 1 0 异或门，不同则为1，相同则为0。 两个二进制数相加的结果是由异或门的输出给出的，而进位位是由与门的输出给出的。这样就构成了一个半加器。半加器的原因是，它将两个二进制数相加，得出了一个加法位和一个进位位。但是绝大多数是多于一位的。半加器没有做到的是将之前一次的加法可能产生的进位位纳入下一次运算。 三个十进制是这样计算的，8+6+7=21，首先8+6的加法位是4，进位位是1，加法位4和7相加得出加法位是1，进位位是1，然后进位位继续相加得出2，所以最终结果是，进位位是2，加法位是1。 二进制也是一样的。第一个半加器的输入A和输入B的输出结果是一个加和及相应的进位。这个和必须和前一列的进位输入相加，然后在把它们输入到第二个加法器中。第二个半加器的输出和是最后的结果。两个半加器的进位输出又被输入一个或门中。你可能会觉得，两个进位应该用异或门来相加得出和，但是你会发现两个半加器的进位输出是不会同时为1的。或门在这里已经足够，因为或门除了在输入都为1的时候以外，其他情况下结果和异或门结果相同。 两个半加器和一个或门构成一个全加器。 全加器的所有情况如下表 输入A 输入B 进位位M(A+B) 加法位N(A+B) 进位输入X 最终加法位(N+X) 进位位Z(N+X) 最终进位位(M+Z) 0 0 0 0 0 0 0 0 0 1 0 1 0 1 0 0 1 0 0 1 0 1 0 0 1 1 1 0 0 0 0 1 0 0 0 0 1 1 0 0 0 1 0 1 1 0 1 1 1 0 0 1 1 0 1 1 1 1 1 0 1 1 0 1 过程更为了然，输入A和B得出进位位M和加法位N，加法位N和前一列的结果的进位X得出最终加法位和进位位Z，然后加法Z和之前的进位位M相加得出最终进位，由于进位Z和进位M不可能同时为1，因为或门和异或门只有1，1这种情况不同，其他情况都相同，所以使用或门代替异或门。 扩展 一旦你搭建起了8位二进制加法器，你就可以再搭建另外一个加法器。把它们级联起来就可以很容易地扩展出一个16位加法器，只要把第一个8位二进制加法器的进位输出到第二个8位二进制加法器的进位输入即可。 真相计算机已经不再使用继电器了！第一台数字计算机在20世纪30年代被建造完成，但是所使用的就是继电器，后来也是用过真空管。今天的计算机使用的是晶体管。 晶体管的工作方式与继电器基本形同，晶体管要比继电器计算速度更快、体积更小，而且噪声更弱、耗能也更低，而且更便宜。","tags":[{"name":"编码(隐匿在计算机软硬件背后的语言)","slug":"编码-隐匿在计算机软硬件背后的语言","permalink":"http://yoursite.com/tags/编码-隐匿在计算机软硬件背后的语言/"},{"name":"二进制加法器","slug":"二进制加法器","permalink":"http://yoursite.com/tags/二进制加法器/"}]},{"title":"11 门","date":"2017-10-29T09:00:00.000Z","path":"2017/10/29/code_11/","text":"与门 AND 0 1 0 0 0 1 0 1 与门的符号不仅仅代表了两个串联的继电器。与门的输入未必一定要和开关相连，而且输出也不一定只能和灯泡相连。我们真正处理的是输入端的电压和输出端的电压。 OR 0 1 0 0 1 1 1 1 反相器 它能将低电平转换为高电平，将高电平转化为低电平 2-4译码器 4个与门和两个反相器连接成的电路叫做2-4译码器。输入为2个二进制位，各种组合共表示4个不同的值。输出是4个信号，任何时刻只能有一个是1，至于哪一个是1取决于两个输入。利用同样的道理，我们可以构造出3-8译码器或者4-16译码器。 或非门 NOR 0 1 0 1 0 1 0 0 与非门 NAND 0 1 0 1 1 1 1 0 带有两个反向输入的与门和或非门是相等的 带有两个反向输入的或门和与非门是相等的 这两组等价关系就是摩根定律在电路中的实现。 摩根定律可以简单地表示如下形式： 摩尔定律是简化布尔表达式的一种重要手段，因此也可以简化电路。","tags":[{"name":"编码(隐匿在计算机软硬件背后的语言)","slug":"编码-隐匿在计算机软硬件背后的语言","permalink":"http://yoursite.com/tags/编码-隐匿在计算机软硬件背后的语言/"},{"name":"门","slug":"门","permalink":"http://yoursite.com/tags/门/"}]},{"title":"10 逻辑与开关","date":"2017-10-29T04:00:00.000Z","path":"2017/10/29/code_10/","text":"代数安雅有3磅豆腐。贝蒂的豆腐是安雅的2倍。卡门的豆腐比贝蒂多5磅。迪尔德丽的豆腐是卡门的3倍。试问迪尔德丽有多少豆腐？ 首先将文字叙述转化为数学语言，下面用四个字母分别表示每个人所拥有的豆腐有多少磅：A = 3B = 2 AC = B + 5D = 3 C将四个表达式带入同一个式子进行合并：D = 3 CD = 3 (B + 5)D = 3 ((2 A) + 5)D = 3 ((2 3) + 5)D = 3 * 33 布尔的天才之处就是把代数从数的概念中抽离出来而使其更加抽象。操作数不是数字而是类，一个类就是一个事物的集合，它后来被称为集合。 集合中的并与交和电路中的并联与串联集合中的交集和并集： AND 0 1 0 0 0 1 0 1 这个运算与常规的乘法的结果是完全相同的。 OR 0 1 0 0 1 1 1 1 这个运算与常规的加法的结果是完全相同的。 电路中，开关闭合代表1，开关断开代表0。 串联 0 1 0 0 0 1 0 1 这与AND表示一模一样的 并联 0 1 0 0 1 1 1 1 这与OR表示一模一样的","tags":[{"name":"编码(隐匿在计算机软硬件背后的语言)","slug":"编码-隐匿在计算机软硬件背后的语言","permalink":"http://yoursite.com/tags/编码-隐匿在计算机软硬件背后的语言/"},{"name":"逻辑与开关","slug":"逻辑与开关","permalink":"http://yoursite.com/tags/逻辑与开关/"}]},{"title":"9 二进制数","date":"2017-10-27T16:00:00.000Z","path":"2017/10/28/code_9/","text":"bit（比特）代表一个二进制位。 在计算机时代，比特被看做是组成信息块的基本单位。 一个耐人寻味的利用二进制传递重要信息的例子：他对他的朋友说：“今晚如果从镇里来的英国军队通过海路或陆路入侵，你就在北教堂钟楼的拱门处高高挂起提灯作为特殊信号——一盏提灯表示英军从陆路进军，两盏则表示英军从海路入侵……” 假设两盏提灯是永久固定在教堂钟楼里上的。通常他们不会被点亮。这代表英军还没有入侵。如果一盏提灯亮起：表示英军从陆路入侵。如果两盏灯都亮：表示英军从海路入侵。 每一盏灯都代表一个比特。点亮的提灯表示比特值1；未点亮的提灯表示0。 四种信息的可能：00 = 英军不会入侵01 = 英军从陆路入侵10 = 英军从陆路入侵11 = 英军从海路入侵 UPC（Universal Product Code）是由30条不同宽度的垂直黑色条纹组成的，他们的间隙宽度也不同，条纹下面标有数字。 可以把这些条纹看成是细条和黑条、窄间隙和款间隙的排列。在UPC中，黑色条纹有四中不同的宽度，宽条纹的宽度分别是最细条纹宽度的两倍、三倍或四倍。同样，款间隙的宽度分别是最窄间隙宽度的两倍、三倍或四倍。 扫描仪只识别整个条形码的一条窄带，条形码做得很大为了便于操作人员用扫描仪对准。看起来像莫尔斯码。 当计算机从左向右扫描这个信息时，它会首先给遇到的第一个黑条分配一个值为1的比特，给与这个黑条相邻的白色间隙分配一个值为0的比特。随后的条纹好间隙被读作一行中的一系列比特，每个系列的比特可以是1位、2位、3位或4位，而这个位数取决于条纹和间隙的宽度。整个upc只不过是95位二进制数。 前三位通常都是101，这就是最左边的护线，它帮助计算机扫描仪定位。从护线中，扫描仪可以确定代表danger别特的条和间隙的宽度是多少。 最左边的护线之后是6组比特串，每串含有7个比特位。其中每一组可以是数字0~9的编码。接下来是一个5比特位的中间护线，这是一个固定的模式（始终是01010），它是一个内置式的检错码。如果计算机扫描仪没有在应有的位置找到中间护线，他就无法破解UPC码。这条中间护线是用来预防条形码被篡改或被印错的一种方法。 中间护线后面仍然是6组比特串，每组中含有7个比特位。之后最右边的护线，最后边的护线通常为101.最右边的护线可以实现UPC的反向扫描。 左边的编码：0001101 = 00011001 = 10010011 = 20111101 = 30100011 = 40110001 = 50101111 = 60111011 = 70110111 = 80001011 = 9 每个7位编码都是以0开头的，以1结尾的。另外每组编码仅有两组连续为1的比特位。每组编码含有奇数个1。这是预防条形码被篡改的一种方法。 如果每组比特位中含有偶数个1，它就称为偶校验；如果含有奇数个1，那么它称为奇校验。 右边的编码：1110010 = 01100110 = 11101100 = 21000010 = 31011100 = 41001110 = 51010000 = 61000100 = 71001000 = 81110100 = 9 这些编码都是之前编码的补码：之前出现0的点，现在都换成了1，反之亦然。这些编码都是以1开头，以0结尾的。除此之外，每组编码都含有偶数个1，属于偶校验。 一共十二个数字，编码解除的数字与UPC下面印刷的数字完全形同，当扫描仪由于某种原因无法解读条形码时，收银员可以手动输入这些数字，毫无疑问你也看到过这一幕。 第一个数字被称为数字系统符。0意味着这是一个常规的UPC。称重的商品，例如肉、农场品，这个编码就会是2。票券的upc的第一个数字通常为5。 接下来的5个数字表示是制造商编码。51000就是campbell公司的编码。所有campbell公司的产品都是这个编码。后面的五位代码是这个公司的某种商品的编码。只有和制造商编码同时出现的时候这个编码才有意义。不同的公司相同的商品的编码可能是不一样的。 UPC不包含物品的价格信息。价格信息可以从商店使用与该扫描仪相连的计算机中检索到。 最后一个字符称为模校验位。这个字符用来进行另外一种错误校验。将前11个数字用字母代替：A BCDEF GHIJK然后计算下式的值：3 （A+C+E+G+I+K） + （B+D+F+H+J）从这个值最近并且大于或等于它的一个10的整倍数中减去它，其结果称为模校验字符。3 （0+1+0+0+2+1） + （5+0+0+1+5） = 23紧挨23并且大于或等于23的10的整倍数是30，因此：30-23=7 通常情况下，要表示0~9的十进制数字只需要4个比特位就足够了。upc中每个数字用了7个比特位。这样，upc总共用了95个比特位来表示11个足够有效的十进制数。实际上，upc中还有空白位置（相当于9个0比特），它们位于左、右护线的两侧。这就意味着整个upc需要113个比特位来编码11个十进制数，平均每个十进制数所用的比特位超过了10个！ 如我们所看到的，有部分冗余对于检错来讲是非常重要的。这种商品编码如果能够被顾客用笔轻易地改动，那么这种产品编码措施也就没有任何意义了。 upc可以从两个方向度，这一点是非常方便的。如果扫码装置解码的第一个数是符合偶校验的，扫码仪机会知道，他正从右边向左边扫描upc码。 逆向扫描时右边数字的编码0100111 = 00110011 = 10011011 = 20100001 = 30011101 = 40111001 = 50000101 = 60010001 = 70001001 = 80010111 = 9 逆向扫描时左边数字的编码 1011000 = 01001100 = 11100100 = 21011110 = 31100010 = 41000110 = 51111010 = 61101110 = 71110110 = 81101000 = 9 所有这些7位编码都与由左向右扫描时得到的upc完全不同。这里不会有模棱两可的现象存在。","tags":[{"name":"编码(隐匿在计算机软硬件背后的语言)","slug":"编码-隐匿在计算机软硬件背后的语言","permalink":"http://yoursite.com/tags/编码-隐匿在计算机软硬件背后的语言/"},{"name":"二进制","slug":"二进制","permalink":"http://yoursite.com/tags/二进制/"}]},{"title":"8 十的替代品","date":"2017-10-27T09:00:00.000Z","path":"2017/10/27/code_8/","text":"10之所以指十只鸭子，唯一理由就是我们的手指有十只，如果我们有八只，那么10就会代表八，如果我们只有四只手指，那么10就会代表四，如果我们只有两只手指，那么10就会代表二。 如果我们采用八进制数字系统，那么我们不用符号9和8。因在十进制中，10没有特定的符号，因此在8进制中，同样没有表示8的特定符号。 十进制中，我们的计数方式是：0、1、2、3、4、5、、6、7、8、9，然后是10。在八进制计数数字系统中计数方式是：0、1、2、3、、4、5、6、7，然后是10。 使用非十进制的数字系统中，你可以将“10”读作“一零”，这样可以避免混淆。类似地，“13”读作一三，“20”读作“二零”。要想真正避免混淆，可以将“20”读作“基于8进制的数二零”或“八进制二零”。 8进制的数字： 0，1，2，3，4，5，6，7，10，11，12，13，14，15，16，17，20，21，22，23，24，25，26，27，30，31，32，33，34，35，36，37，40，41，42，43，44，45，46，47，50，51，52，53，54，55，56，57，60，61，62，63，64，65，66，67，70，71，72，73，74，75，76，77，100，……最后一个数字，我们读作“一零零”。这是卡通人物手指的数量自身想乘所得的结果。 八进制中：3725 = 3000(Eight) + 700(Eight) + 20(Eight) + 5(Eight)3725 = 3 512(Ten) + 7 64(Ten) + 2 8(Ten) + 5 1(Ten)3725 = 3 1000(Eight) + 7 100(Eight) + 2 10(Eight) + 5 1(Eight)3725 = 3 8^3(Ten) + 7 8^2(Ten) + 2 8^1(Ten) + 5 8^0(Ten) 八进制中： + 0 1 2 3 4 5 6 7 0 0 1 2 3 4 5 6 7 1 1 2 3 4 5 6 7 10 2 2 3 4 5 6 7 10 11 3 3 4 5 6 7 10 11 12 4 4 5 6 7 10 11 12 13 5 5 6 7 10 11 12 13 14 6 6 7 10 11 12 13 14 15 7 7 10 11 12 13 14 15 16 乘法表如下： * 0 1 2 3 4 5 6 7 0 0 0 0 0 0 0 0 0 1 0 1 2 3 4 5 6 7 2 0 2 4 6 10 12 14 16 3 0 3 6 11 14 17 22 25 4 0 4 10 14 20 24 30 34 5 0 5 12 17 24 31 36 43 6 0 6 14 22 30 36 44 52 7 0 7 16 25 34 43 52 61 既然已经为卡通人物开发了一套数字系统，就让我们在制定一套适合龙虾的吧。适于龙虾的数字系统是4为基数的四进制数字系统。 四进制的数字系统是这样的：0，1，2，3，10，11，12，13，20，21，22，23，30，31，32，33，100，101，102，103，110，等等。 在四进制系统中： 31232 = 3 256(Ten) + 1 64(Ten) + 2 16(Ten) + 3 4(Ten) + 2 1(Ten)31232 = 3 10000(Four) + 1 1000(Four) + 2 100(Four) + 3 10(Four) + 2 131232 = 3 4^4 + 1 4^3 + 2 4^2 + 3 4^1 + 2 * 4^0 如果我们是海豚，这个数字系统成为以2为基数的数字系统，或二进制。 二进制中，1的下一位就是10。这让人惊讶，但也并不是什么意外。无论使用哪种基数系统，当单个的数字用完时，第一个两位数就是10。二进制系统是这样计数的：0，1，10，11，100，101，110，111，1000，1001，1010，1011，1100，1101，1110，1111，等等 2的整数次幂 十进制数 八进制数 四进制数 二进制数 2^0 1 1 1 1 2^1 2 2 2 10 2^2 4 4 10 100 2^3 8 10 20 1000 2^4 16 20 100 10000 2^5 32 40 200 100000 2^6 64 100 1000 1000000 2^7 128 200 2000 10000000 2^8 256 400 10000 100000000 2^9 512 1000 20000 1000000000 2^10 1024 2000 100000 10000000000 2^11 2048 4000 200000 100000000000 2^12 4096 10000 1000000 1000000000000 101101011010(Two) = 1 2048(Ten) + 0 1024(Ten) + 1 512(Ten) + 1 256(Ten) + 0 128(Ten) + 1 64(Ten) + 0 32(Ten) + 1 16(Ten) + 1 8(Ten) + 0 4(Ten) + 1 2(Ten) + 0 1(Ten) 101101011010(Two) = 1 2^11 + 0 2^10 + 1 2^9 + 1 2^8 + 0 2^7 + 1 2^6 + 0 2^5 + 1 2^4 + 1 2^3 + 0 2^2 + 1 2^1 + 0 2^0 + 0 1 0 0 1 1 1 10 * 0 1 0 0 0 1 0 1 电线可以表示二进制数字。如果有电流流过这根电线就代表二进制数字1，如果没有，则代表二进制数字0。 开关可以表示二进制数字。如果开关闭合就代表二进制数字1，如果开关断开，则代表二进制数字0。 灯泡可以表示二进制数字。如果灯泡点亮，就代表二进制数字1，如果没点亮，则代表二进制数字0。 电报继电器可以表示二进制数字。如果继电器闭合，就代表二进制数字1，如果断开，则代表二进制数字0。 二进制数与计算机之间有着紧密的联系。","tags":[{"name":"编码(隐匿在计算机软硬件背后的语言)","slug":"编码-隐匿在计算机软硬件背后的语言","permalink":"http://yoursite.com/tags/编码-隐匿在计算机软硬件背后的语言/"},{"name":"十进制的延伸","slug":"十进制的延伸","permalink":"http://yoursite.com/tags/十进制的延伸/"}]},{"title":"7 我们的十个数字","date":"2017-10-27T04:00:00.000Z","path":"2017/10/27/code_7/","text":"这个星球上几乎所有人都用以下方式来书写数字：1 2 3 4 5 6 7 8 9 10 大多数文明都是机那里在以10为基数的数字系统上的，因为我们的手指是10个。 早期的数字系统中，只有罗马数字沿用到了今天。I表示1，V表示5，X表示10，L是50，C是100，D是500，M表示1000。 阿拉伯数字起源于印度，被阿拉伯人导入欧洲。 阿拉伯数字系统时和位置有关的。100和1,000,000这两个数中都只有一个1，而我们知道1,000,000比100大得多。实际上，早前的阿拉伯系统的10是用专门的符号来表示的。小小的零是数字和数学史上最重要的发明之一。它支持位置计数法，因此可以将25、205和250区分开来。 4825 = 4000 + 800 + 20 + 54825 = 4 1000 + 8 100 + 2 10 + 5 14825 = 4 10^3 + 8 10^2 + 2 10^1 + 5 10^0 每一个位置代表10的幂次方。我们不需要一个专门的符号来表示数字“10”，因为我们可以将1放在不同的位置，并用0作为占位符。 另外一个好处是，以同样的方式将数字置于小数点右边可以表示分数。数字4825.684就是： 4 1000 +8 100 +2 10 +5 1 +6 ÷ 10 +8 ÷ 100 +4 ÷ 1000 也就是： 4 1000 +8 100 +2 10 +5 1 +6 0.1 +8 0.01 +4 * 0.001 也就是： 4 10^3 +8 10^2 +2 10^1 +5 10^0 +6 ÷ 10^(-1) +8 ÷ 10^(-2) +4 ÷ 10^(-3) 加法表如下： + 0 1 2 3 4 5 6 7 8 9 0 0 1 2 3 4 5 6 7 8 9 1 1 2 3 4 5 6 7 8 9 10 2 2 3 4 5 6 7 8 9 10 11 3 3 4 5 6 7 8 9 10 11 12 4 4 5 6 7 8 9 10 11 12 13 5 5 6 7 8 9 10 11 12 13 14 6 6 7 8 9 10 11 12 13 14 15 7 7 8 9 10 11 12 13 14 15 16 8 8 9 10 11 12 13 14 15 16 17 9 9 10 11 12 13 14 15 16 17 18 乘法表如下： * 0 1 2 3 4 5 6 7 8 9 0 0 0 0 0 0 0 0 0 0 0 1 0 1 2 3 4 5 6 7 8 9 2 0 2 4 6 8 10 12 14 16 18 3 0 3 6 9 12 10 18 21 24 27 4 0 4 8 12 16 20 24 28 32 36 5 0 5 10 15 20 25 30 35 40 45 6 0 6 12 18 24 30 36 42 48 54 7 0 7 14 21 28 35 42 49 56 63 8 0 8 16 24 32 40 48 56 64 72 9 0 9 18 27 36 45 54 63 72 81 位置计数系统的好处并不在于它有多么好用，而在于对非十进制的系统而言，它仍然易于实现计数的。以10位基数的数字系统最大的问题就是它对于卡通人物没有任何意义。大多数卡通人物每只手只有4根手指，因此他们需要一个以8为基数的计数系统。而有意思的是，许多我们在十进制数中所了解到的知识同样适合卡通朋友们所钟爱的八进制计数系统。","tags":[{"name":"编码(隐匿在计算机软硬件背后的语言)","slug":"编码-隐匿在计算机软硬件背后的语言","permalink":"http://yoursite.com/tags/编码-隐匿在计算机软硬件背后的语言/"},{"name":"十进制数","slug":"十进制数","permalink":"http://yoursite.com/tags/十进制数/"}]},{"title":"6 电报机和继电站","date":"2017-10-25T16:00:00.000Z","path":"2017/10/26/code_6/","text":"摩尔斯的发明问世前的几十年里，人们为了提高远距离通信的速度，做过很多尝试。技术上比较简单的方法是，雇用一些人站在山上，作为中继系统，挥旗发出旗语。而在技术上稍复杂的解决方案是，使用带有机械的大型装置，代替人做挥旗的工作。 电报机的原理：在线路的这一段采取一些措施，使线路的另一端发生某种变化。 电磁现象：如果你有一根铁棒，那么在上面用细导线绕上几百圈，然后在导线上接通电流，铁棒就变成了一块磁铁。现在它可以吸引其他的铁块和钢块，电磁铁上缠绕足够多的细导线，会产生足够强的电阻，能防止电磁铁产生短路现象。断开电流，铁棒将会丧失磁性。 电磁铁是电报机的基础。在线路的一端闭合或断开开关，可以使线路另一端的电磁铁有所动作。 早期时，莫尔斯认为应该在纸张上写出什么东西。当然，电报机输出的不一定非得是单词，因为那样做太复杂了。 保持电键的按下状态一小段时间，就会产生一个“点”的莫尔斯码。按下状态保持的时间更长一些就会产生一个“划”的莫尔斯码。 线路的另一端是一个接收器，它主要是由一块电磁铁拉动一根金属杆构成的。最初，电磁铁控制的是一只钢笔。有一个装置通过使用一个压紧的弹簧来拉动一卷纸经过设备，与电磁铁连接着的钢笔就会弹起或者落下，在纸上画出点或划。能读懂莫尔斯码的人员可以把这些“点”或“划”译成字母和单词了。 当然，电报操作人员很快发现，他们很容易地通过听钢笔弹起和落下的声音来翻译成电码。然后，钢笔最终被废弃。 电报机的电键被按下时，发生器中的电磁铁拉动上面的活动横杠下降，它会发出“滴”的声音。当松开电键的时候，横杠弹回到原来的位置，发出“嗒”的声音。一次快速的“嘀-嗒”声代表点；一次慢速的“嘀-嗒”声则代表划。 设置中继系统时解决问题的一个方案。每隔200英里左右，为一个工作人员装配好发生器和电键，他就可以接收信息，然后再把它转发出去。 现在，想象你已经被一个电报公司聘用，把你仍在纽约和加利福尼亚之间的一个无名之地，让你在一个只有一桌一椅的小屋里工作。一条导线从东面的窗户伸进来，连接到发生器上。而你的电报机电键连到电池上，最后线路从西窗伸出去，你的职责就是接收从纽约发来的信息，然后转发它们，最终使它们到达加利福尼亚。 开始时，你喜欢接收完一条完整的信息后再把它转发。最后，你掌握了诀窍，在听到滴答声的同时就可以发送信息。 有一天，你瞄了瞄发生器那根上蹿下跳的横杆，又看了看在电键上上下翻飞的手指。恍然发现发生器上上下跳跃的节奏与电键是一致的。因此你就去外面找了根小木棍，然后用木棍和一些细绳把发生器和电键连接到了一起。现在设备可以自己工作了，而下午的时间，你可以去休个假，钓个鱼。 这是个有趣的想法，但是事实上，莫尔斯在早些时候就已经领会了这个设备的概念。这个称作“继电器”。传进来的电流驱动电磁铁拉动金属杆，金属杆同时又作为一个开关的组成部分，而这个开关连接着电池和输出线路。 继电器是一个意义非凡设备。当然，它是一个开关，但是这个开关的闭合和断开不是由人来操纵的，而是由电流控制的。","tags":[{"name":"编码(隐匿在计算机软硬件背后的语言)","slug":"编码-隐匿在计算机软硬件背后的语言","permalink":"http://yoursite.com/tags/编码-隐匿在计算机软硬件背后的语言/"},{"name":"电报机","slug":"电报机","permalink":"http://yoursite.com/tags/电报机/"},{"name":"继电站","slug":"继电站","permalink":"http://yoursite.com/tags/继电站/"}]},{"title":"5 绕过拐角的通信","date":"2017-10-24T16:00:00.000Z","path":"2017/10/25/code_5/","text":"你12岁了。你最好的朋友跟随家人搬到别的镇子。你另外的一个好朋友，也就是你的邻居，现在成了你的新的密友。问题是，这位新朋友的卧室窗户和你卧室的窗户不是对着的。尽管两栋房子挨着，但是卧室窗户是朝向同一个方向的。除非你能想个办法，在室外摆上一面镜子，不然手电筒就不能用来夜谈了。 怎么办？ 也许现在你已经懂得一些关于电学的只是，所以你打算用电池、灯泡、开关和导线自制一个“手电筒”。在第一次尝试中，你把电池还有开关放在卧室中接好，然后从窗户引出两根导线，绕过围墙，街道你朋友的卧室里，在那里把它们街道一个灯泡上。 既然你已经成功地安装了这个“手电筒”，你就可以照样再安装另一套这样的“远距离”设备，好让你的朋友也能够给你发信息。 恭喜你！你已经架好了一套双向电报系 聪敏的你可以采用如下方式对这套系统加以改进，这样可以节省25%的导线。 地球充当导体，这个大球直径7900英尺，由金属、岩石、水，以及有机质（其中大部分是没有生命的）组成。 想要用地球充当导体，可不是随便在西红柿地里插根线那么简单。你必须使用跟地球有充分接触的物体，也就是有很大表面积的导体。捏可以使用一个至少8英尺长、1/2英寸粗的铜柱电极砸进地里，然后在上面接上一根导线。或者，如果你家中的水管是用铜做的，并且是从屋外的地下接下来的，那么你可以在管上接上导线。 1英尺(ft)=0.3048米(m)8英尺(ft)=2.4384米(m)1英寸(in)=0.0254米(m)0.5英寸(in)=0.0127米(m)=1.27厘米(cm) 关于电流的接地，英国人们称其为“earth”，在美国叫“ground”。 电子从你朋友的房子地下出发，经过灯泡、导线和你房间的开关，最后回到电池的正极。而电子最初是从电池的负极传入地下的。 每时每刻地球都在充当着全世界成千上万条电路的导线，想到这些，你可能感到迷茫：电子怎么知道它要去什么地方？其实它们不知道。 地球是一个巨大的导体。地球是一个近乎无尽的电子之源，同是也是一个无比庞大的电子池。不过地球还是有一定电阻的。所以当我们使用1.5伏干电池和灯泡时，不同通过接地来节约我们所需的线路开支。 如果你使用的是高电压电池和大灯泡，你只需要在你和你朋友的房子之间接一根导线，因为可以把地球当成一条导线。 把电池和接地用V来代替它，想象成一个电子吸尘器，然后把地面想象成电子的海洋。电子吸尘器通过电路把电子从地下拉起来，让它们沿设计好的线路开始工作。 本章中，我们已在通信的演变中迈出了重要的一步。之前我们使用莫尔斯码交流时，必须要在视线直视的范围里，并且要保证在手电筒管线可以传播的距离之内。 如果跨越成百上千英里来进行通信，只需铺设足够长的线路即可。不过有个问题，线路越长它们的电阻就越大。电阻越大，线路的电流就越少。电流越少，灯泡就越暗。 假如现在使用的是原来的4条导线的双向电路，并且还用手电筒和小灯泡。买20号规格的电话线，花费为没100英尺9.99美元。如果你和你朋友的卧室之间的距离小于50英尺，这卷电话线就足够了。20号规格的电话线，直径大约是0.032英寸，大约每1000英尺只有10欧的电阻，也就是你们卧室间的往返距离——100英尺，大约有1欧的电阻。 1英里(mi)=1.609344千米(km)1英里(mi)=5280英尺(ft) 情况其实还不错，如果我们需要铺设一英里的线路呢？导线的电阻将大于100欧。小灯泡是4欧，电流是3/4=0.75安，现在电阻变成50欧，电流变成3/50=0.06安，几乎可以肯定，这点电流不足以点亮灯泡。 使用粗一点的导线是不错的解决方案，但是那会比较昂贵。10号规格线，没35英尺11.99美元，这种线只有一个接口，大约有0.1英寸粗，所以你需要两倍长度，没1000英尺只有1欧的阻抗，也就是每英里5欧。 另一种方法就是增加电压，使用更大电阻的灯泡。导线的电阻对这个电路的影响将变得小许多。 150年期，人们铺设第一个跨越美洲和欧洲的电报系统时，这些都是面临的问题。系统的极限是200英里。这个长度与纽约和加利福尼亚数千英里的距离相比，还是有很大差距的。 这个难题的解决方案不是给手电筒的，而是给“滴答滴答”的近代电报系统的，尽管它只不过是一个很简陋的装置，但是正是基于和这个装置，整个计算机系统才被构建起来。","tags":[{"name":"编码(隐匿在计算机软硬件背后的语言)","slug":"编码-隐匿在计算机软硬件背后的语言","permalink":"http://yoursite.com/tags/编码-隐匿在计算机软硬件背后的语言/"},{"name":"电路分析","slug":"电路分析","permalink":"http://yoursite.com/tags/电路分析/"}]},{"title":"4 手电筒的剖析","date":"2017-10-23T16:00:00.000Z","path":"2017/10/24/code_4/","text":"手电筒的构造：一对电池、一个灯泡、一个开关、一些金属片，还有一个可以容纳这些元件的塑料外壳。 一个电路就是一个环路。只有从电池到导线，再到灯泡和开关，然后再通过导线回到电池的整个回路是连通的，灯泡才能被点亮。 电路这种环状回路的特性说明电路中有某种东西在循环流动，或许有些像水流过水管那样。 电流是由电子的运动而产生的。 所有的物质都是有原子构成的。每一个原子由三种粒子构成：它们分别是中子、质子和电子。你可以把原子的结构画成一个小太阳系，其中中子和质子被束缚在原子核内，而电子则围绕着原子核旋转，犹如行星围绕着太阳旋转一样。 原子之间可以通过化学的方式结合成分子。分子的性质通常与组成它的原子大相径庭。例如，水是由水分子组成的，每个水分子由两个氢原子和一个氧原子组成。很明显，水跟氢气或氧气都是截然不同的。 氢、氧、钠和氯都是元素。水和盐都是化合物。不过盐水是混合物而不是化合物，因为水和盐都各自保留着他们自己的性质。 一个原子中电子的数目一般情况下是与质子数目相同。但是在某些情况下，电子可能从原子中脱离。这就是电流产生的原因。 用琥珀在羊毛上摩擦使得羊毛掠夺了琥珀的部分电子。结果羊毛因为电子超过了质子数数而卷曲，而琥珀的电子数比质子少了。结果羊毛因为电子数超过了质子数而卷曲。 质子和电子都具有带电荷的性质。质子和电子所带的电荷是相反的。 当质子和电子在相同数目的条件下共存时，它们都处于最和谐、最稳定的状态。如果质子和电子出现失衡现象，它们就会试图进行自我修复。当地毯偷偷摸摸地从你的鞋子上挖走电子之后，一切会在你接触到一些东西时而感到被电了一下时，又回到了平衡状态。静电火花就是电子运动引起的，是电子通过一个回路——从地毯传到你的身体，在回到鞋子中的过程造成的。 在风暴中，底层的云积聚了大量电子而顶端的云失去电子；最后一道闪电划破长空，使这一切又回到了平衡。闪电就是大量电子从一端快速地移动到另一端所形成的。 手电筒电路的电流显然要比火花或者闪电更容易驾驭的多。电路中，某原子所含有的一个电子逃逸到它相邻的下一个原子中，与此同时，这个原子又从相邻的上一个原子中获取一个电子，而失去电子的原子又会从与其相邻的一个原子获得电子，如此循环。电路中的电子不断地从一个原子移动到下一个原子，就形成了电流。 所有的电池的内部都会发生化学反应，也就是说一些分子被分裂成其他的分子，或者分子间互相结合形成了新分子。它们之间的化学反应能够使多余的自由电子聚集到标符号“-”的那端，而标有正好“+”的那端则变得急需额外的电子。于是，化学能就转化成了电能。 串联：两块电池合在一起，一块1.5伏，串联后，电压变成3伏。并联：并联后的电压还是1.5伏，没有串联电池的灯泡亮，电池的使用寿命将会延长一倍。 对于电流来说容易“导通”的，被称作导体。最好的导体是铜、银河金。其中铜是用来制作导线最常见的材料。到导电性相反的是阻抗性。它几乎不能传导任何电流，被称作为绝缘体。橡胶和塑料都是很好的绝缘体，它们常常被用来包裹导线。不过事实上，只要电压足够高，任何物质都可以导电。 导线越长，阻抗性越高。导线越粗，阻抗性越低。 电压——亚历山大·伏特（Alessandro Volta， 1745-1827），电流做功的势。不管电池是否连接到电路中，电压都是存在的。想想一块砖，当它在地板上，只有很少的势能。把它从地面上举到离地板四英尺的高度，现在这块砖就会有比较多的势能。你只是拿着这块砖，它并没有做什么，但是这块砖的势能却差别迥异。 电流的计量单位是安培，得名已安德烈·玛丽·安培（André Marie Ampère， 1775-1836），简称安 电阻的单位是欧姆，得名于乔治·西蒙·欧姆（George Simon Ohm， 1789-1854）。著名的欧姆定律就是他提出的。1I = E/R I表示电流，E用来表示电压，R表示电阻。 一段铜线直接将正负极连接起来，这种情形称为短路。电阻非常小，电流变大非常大。如果电池足够大的话，导线将会变热，甚至融化。 如果导线电阻较低的话，它将变热并且发光。这就是白炽灯发光的道理。通常，白炽灯的发明者是托马斯·阿尔瓦·爱迪生（Thomas Alva Edison， 1847-1931），但是这种观点是在他取得灯泡的专利之后被广为传播的，实际上在这个领域上很多科学家都有过研究。 灯泡里面有一根很细的金属丝，我们称之为灯丝，一般情况下灯丝是用钨做成的。金属丝的电阻使它开始发热。如果暴露在空气中，钨丝将达到燃点并开始燃烧，但是在灯泡的真空泡室内，钨丝就会发出光亮。 瓦特这个单位得名于詹姆斯·瓦特（James Watt， 1736-1819）。瓦特是功率的计量单位，计算公式如下： 1P = E * I 开关只能是闭合状态或断开状态。电流只能是有或者无。灯泡只能是发光或者不发光。就像莫尔斯码和布莱叶发明的二进制码一样，这个简单的手电筒要么是开着的，要么是关着的。","tags":[{"name":"编码(隐匿在计算机软硬件背后的语言)","slug":"编码-隐匿在计算机软硬件背后的语言","permalink":"http://yoursite.com/tags/编码-隐匿在计算机软硬件背后的语言/"},{"name":"电流的产生","slug":"电流的产生","permalink":"http://yoursite.com/tags/电流的产生/"},{"name":"电的相关概念","slug":"电的相关概念","permalink":"http://yoursite.com/tags/电的相关概念/"}]},{"title":"3 布莱叶盲文与二进制码","date":"2017-10-22T16:00:00.000Z","path":"2017/10/23/code_3/","text":"一、布莱叶盲文前传路易斯·布莱叶（Louis Braille）于1809年出生于法国的库普雷，距离巴黎市东25英里的小镇。布莱叶的父亲是一个马具匠人。在布莱叶3岁的时候，在父亲的工作间玩耍，不小心被一个尖锐的工具刺伤了一只眼睛。伤口感染也影响到了他的另一只眼睛，最后双目失明。10岁送往巴黎皇家盲人学校学习。 瓦尔丁·霍伊是巴黎皇家盲人学校的创始人，发明过一种在纸面上印下凸起文字的系统。霍伊先生实力健全，因此他被自身的感知模式所禁锢。对他来说，一个字母A就是一个A，而且字母A在记录时也不许看起来（或者感觉起来）像一个A（如果让他用手电筒交流的话，估计他会试图在空中比划要表达的字母，但是其实我们发现这个法子根本不灵）。 查尔斯·巴比尔，法国军队的以为军官，在1819年发明了一种自称为夜间书写的文字系统。厚纸上使用凸起的点和划的组合来表示文字，即使光线很暗，士兵们也可以传递信息。使用一个锥形的铁笔在厚纸的背面书写，这样纸的正面就会有相应的凸起。 巴比尔文字系统的缺点是太过复杂了。该系统并非使用与字母相对的点划编码串来表示字母，而是用与读音相对的编码串表示，因此有时仅仅是为了表示一个单词，就不得不使用很多的码字。 布莱叶在12岁的时候很熟悉巴比尔的这种文字系统了。凸起的点通过手指很容易阅读，写起来也比较简单。3年以后（15岁）就创建了自己的系统，这个系统的一些基本规范，知道今天还在被人们使用。1835年，路易斯·布莱叶患上了肺结核。1852年，过完43岁生日不久，就去世了。 二、布莱叶盲文 字母、数字和标点符号都被编码成2×3的点码单位中的一个或者多个凸起的点。这个点码单位包含的点通常使用1到6的数字来编号。现代应用中，使用特殊的打印机或轧花机可以将布莱叶盲文引到纸上。 大点表示一个凸起的点，小点则表示对应的位置是平的。例如上面的布莱叶盲文，其中，1，3，5是凸起的，二第2，4，6的位置是平的。 这些点码都是二进制的。一个单独的点不是平的就是凸起的。每组6个点，也就是一共2^6=64中组合。 小写字母表 词组you and me 一个单词之间每个字母所对应的点码单元之间都用一小块空白分开；而单词之间则用一个大的空格(实际上是没有凸点的点码单元)所分隔开来。 目前在英文出版物中最常用的盲文系统被称为二级布莱叶盲文。用了很多缩写。例如，如果字母的码字单独出现，他们就表示一个普通的单词。 you and me 使用二级布莱叶盲文表示。 字母a到j的码字加上6号凸点的组合，表示字母串的缩写，还有w字母。 a到j的码字，降低他们的凸点，只用到2、3、5和6的点，这样就得到了新的码字。根据上下文环境，它们用来表示一些标点符号或者字符串缩写。 表示字符串缩写“ble”的码字很重要，因为当它不是用来作为单词的一部分时候、，它的出现就意味着之后的码字应被译为数字。表示数字的码字与表示字母a到j的码字是相同的。 6号凸点，大写标识符。这个符号表示它之后的字母都被译为大写。","tags":[{"name":"编码(隐匿在计算机软硬件背后的语言)","slug":"编码-隐匿在计算机软硬件背后的语言","permalink":"http://yoursite.com/tags/编码-隐匿在计算机软硬件背后的语言/"},{"name":"布莱叶盲文","slug":"布莱叶盲文","permalink":"http://yoursite.com/tags/布莱叶盲文/"}]},{"title":"2 编码与组合","date":"2017-10-21T16:00:00.000Z","path":"2017/10/22/code_2/","text":"大多数人都会发现莫尔斯码的发送比接受比较方便。即使你并不熟记莫尔斯码，也可以很方便地使用这张按字母顺序排列的表格。比起发送莫尔斯码，接收编码并进行解码要费事费力的多，因为译码者不得不根据一串由“点”、“划”组成的晦涩的编码序列来反查字母。例如，如果你接收到一串形如“划-点-划-划”的编码，那么你就必须从表的第一个字母开始逐个搜索，知道找到与这串编码相符的字母“Y”为止。 一、点或划的格式表示 或许根据编码中所包含点、划的多少来对其进行分组，是一个更好的组织这些编码的方法。例如，一个点或一个划的莫尔斯码只能代表两个字母：“E”和“T”。 . E - T .. I -. N .- A – M … S -.. D ..- U -.- K .-. R –. G .– W — O …. H -… B …- V -..- X ..-. F -.-. C ..– Ü -.– Y .-.. L –.. Z .-.- Ä –.- Q .–. P —. Ö .— J —- Š 二、码字个数 点和划的数目 码字的数目 1 2 2 4 3 8 4 16 点和划的数目 码字的数目 1 2 2 2×2 3 2×2×2 4 2×2×2×2 点和划的数目 码字的数目 1 2^1 2 2^2 3 2^3 4 2^4 三、莫尔斯码的树形图 四、莫尔斯码的个数的延伸 编码系统可以扩展到5位或者更长。如果是6位的话，第六位的个数有2^6=64，一共有2+4+8+16+32+64=126种。 点和划的数目 码字的数目 1 2^1=2 2 2^2=4 3 2^3=8 4 2^4=16 5 2^5=32 6 2^6=64 7 2^7=128 8 2^8=256 9 2^9=512 10 2^10=1024 五、总结莫尔斯码称作二进制码，因为这种编码的组成元素只有两个——“点”和“划”。","tags":[{"name":"编码(隐匿在计算机软硬件背后的语言)","slug":"编码-隐匿在计算机软硬件背后的语言","permalink":"http://yoursite.com/tags/编码-隐匿在计算机软硬件背后的语言/"},{"name":"编码与组合","slug":"编码与组合","permalink":"http://yoursite.com/tags/编码与组合/"}]},{"title":"1 至亲密友","date":"2017-10-20T16:00:00.000Z","path":"2017/10/21/code_1/","text":"一、问题场景 你今年10岁，你的朋友就住在你街对面。实际上，你们各自的卧室的窗户正好彼此相对。每当夜幕降临之后，你们父母就会逼你们上床睡觉，但是你和你朋友想要再交流一会。怎么办？没有电话，没有手机，没有电脑，只有一个手电筒，怎么交流？ 二、解决方案办法①：用手电筒在天空中画字母。对于字母o，就在天空中画一个圈。但是，你很快就会发现，这个办法行不通。当你看着朋友的手电筒在空中圈圈点点，会发现很难再头脑中组合出那么多复杂的笔画。这些光线画出来的字母不太准确。 办法②：每个字符对应一连串的手电筒闪烁。“A”是闪一次，“B”是闪两次，“C”是闪三次，以此类推，“Z”就是闪26次。单词BAD可以用闪2次，闪1次，闪4次这样的一个组合来表示，而且字符之间设置小停顿使得这个单词不至于被误认为闪7次的字母“G”。另外单词之间停顿可以少为长一些。 这种方案听起来好像不错，如果你想发送的第一个消息是“how are you？”，那么你将要让手电筒闪131次！而且，这还忽略了标点符号的，你还没有设计闪多少次来对应一个问号。 三、莫尔斯电码 办法二已经离答案很接近了。我们能够肯定的是，在此之前一定有人也遇到了类似的问题，而你办法二的思路也是非常正确的。到了白天，跑一趟图书馆，查查资料，你发现了一个被称为摩尔斯电码的伟大发明。 你的办法二中，闪1下为“A”，闪26下为“Z”。而在摩尔斯电码里，只有两种闪烁——短闪和长闪。句子”how are you?”现在只有闪32下，而不再是131下，而且这其中包括了一个代表符号的编码。 当问及摩尔斯电码是如何工作的时候，人们不会谈论“短闪”和“长闪”。相反，他们使用“点（dot）”和“划（dash）”，因为这是在打印纸上显示编码的一个便利方法。 四、编码与生活 实际上，编码就是交流。有时候，我们认为编码就是指秘密的东西（密码）。但是大部分编码不是这样的。毕竟，大部分编码必须易于理解，因为他们是人类交流的基础。 在《百年孤独》这本书的开篇里，加利亚·马尔克斯回忆了一个时代，那时“这世界刚刚出现，以至于很多东西缺乏命名，这时就有必要亲自用手指明这些事物”。我们赋予这些东西名字时往往是很随意的。这就好比说为什么猫不被叫做“狗”而狗不被叫做“猫”一样，没有什么理由可言。你可以说英文词汇是一种编码。 我们发出的声音所形成的词语就是一种可识别的编码，这种编码称之为“口头话语”或“言辞”。 对于写在纸上的词，我们叫它“书面语言”或“文本”。许多语言中，语言和文字之间存在着很紧密的联系。 对于那些丧失听说能力的聋哑人来说，手语就是一种编码 对于那些失明的人，书面语言可以用布莱叶盲文来替代。 五、编码与计算机 我们会看见，各种类型的编码也用在计算机里存储和传递数字、声音、音乐、图片和电影。 计算机不能直接处理人类的编码，因为计算机无法通过与人类的眼睛、耳朵、嘴巴和手指完全相同的方式来接收人类发出的信息。 现在的个人计算机能够获取、存储、处理和呈现一切用于与人类沟通的信息，无论视觉信息（文字和图片），还是听觉信息（口语、声音、和音乐），或两者的结合（动画和电影）。 所有这些类型的信息都需要他们各自的编码，就像人类说话需要一套器官（嘴和耳朵）而写作和阅读需要另一套（手和眼）一样。 六、摩尔斯编码实际应用 对于手电筒，我们发送“点”和“划”对应的闪烁光。 使用手电筒发送摩尔斯编码时，迅速地打开和关闭开关代表一个“点”（快闪），让闪光时间保持的相对长一些代表“划”（慢速闪光）。例如在发送A时，首先以非常快的速度打开并关闭手电，然后再以稍慢的速度进行一次。在发送下一个字符前，需要暂时停一会。再次约定，一个“划”的时长是“点”的3倍。例如，如果一个“点”的时长是1秒，那么一个“划”的时长就应当是3秒。（在现实中，莫尔斯码的传输速度远远比这快的多）。接受者看到一个短促的闪烁和一个拖长的闪光后，就知道这是个A了。 在摩尔斯电码中，“点”和“划”之间的停顿是至关重要的。例如，当发送一个字母A时，在发送的“点”和“划”之间，手电筒要关闭一段时间，这相当于一个点的闪烁时长（如果“点”的时长是1秒，那么“点”和“划”之间的停顿也应当是1秒）。对于同一个单词的字母，则通过较长的停顿来分割，这相当于一个“划”的时长（或者说是3秒，如果一个“划”的时长就是3秒的话）。单词与单词则通过相当于两个“划”的时长来分割（如果一个“划”的时长为2秒，那么这个停顿就应当为6秒）。 七、摩尔斯编码中的规律 乍一看，摩尔斯编码的定义与打字机字母的排列一样都是随意的。然而，仔细研究之后，我们就会发现事实并非如此。 简单且短促的编码，被分配给字母表中使用频率较高的字母，例如E和T。而不太常用的字母，比如Q和Z则被分配以较长的编码。 三个点、三个划，再加上三个点就表示SOS，即国际求救信号。SOS不是一个缩写，这只是一个易于记忆的摩尔斯编码序列。 摩尔斯编码的一个缺点是，它没有区分大写字母和小写字母。 八、马尔斯编码的口语 当你和朋友最终熟记了摩尔斯编码之后，你们甚至可以在口语中使用它，用来取代正常的语言。 为了使编码发送的速度最快，你可以把“点”读成“嘀（dib）”，把“划”读成“嗒（dab）”。文字也可以用同样的方式简化成“点”和“划”的序列，摩尔斯编码的口语版把讲话内容缩减到只剩下两个声音了。 九、总结 问题的关键就在于数字2。两种闪烁，两种声音。 事实上，两个不同的事物，只要经过适当的组合，就可以表示所有类型的信息，这的确是千真万确的。","tags":[{"name":"编码(隐匿在计算机软硬件背后的语言)","slug":"编码-隐匿在计算机软硬件背后的语言","permalink":"http://yoursite.com/tags/编码-隐匿在计算机软硬件背后的语言/"},{"name":"莫尔斯电码","slug":"莫尔斯电码","permalink":"http://yoursite.com/tags/莫尔斯电码/"}]},{"title":"word文档题库转化为xml文件","date":"2017-07-28T12:47:00.000Z","path":"2017/07/28/wordToXml/","text":"需求：123456789101112131415161718192021222324252627282930313233343536373839404142434445word文档转为xml文件 word文档如下：一、单选题（220题）1、消防头盔经高温、低温、浸水、热辐射预处理后进行冲击吸收性能试验，头模所受冲击力的最大值应不大于，帽壳不得有碎片脱落。（A）A、3780NB、3380NC、3580N D、3680N 二、多选题（200题） 1、消防员灭火防护服撕破强力不小于多少N，下列错误的是（ BCD）A、100 B、200 C、300 D、400 三、是非题（180题） 1、消防员灭火防护服的面料由外层、防水透气层、隔热层、舒适层组成。（√） 转为xml文件如下： &lt;ArrayOfTopic&gt; &lt;Topic&gt; &lt;TopicType&gt;1&lt;/TopicType&gt; &lt;Ask&gt;消防头盔经高温、低温、浸水、热辐射预处理后进行冲击吸收性能试验，头模所受冲击力的最大值应不大于，帽壳不得有碎片脱落。（）&lt;/Ask&gt; &lt;Answer&gt;A&lt;/Answer&gt; &lt;Option&gt; &lt;string&gt;A、3780N&lt;/string&gt; &lt;string&gt;B、3380N&lt;/string&gt; &lt;string&gt;C、3580N&lt;/string&gt; &lt;string&gt;D、3680N&lt;/string&gt; &lt;/Option&gt; &lt;/Topic&gt; &lt;Topic&gt; &lt;TopicType&gt;2&lt;/TopicType&gt; &lt;Ask&gt;消防员灭火防护服撕破强力不小于多少N，下列错误的是（）&lt;/Ask&gt; &lt;Answer&gt;BCD&lt;/Answer&gt; &lt;Option&gt; &lt;string&gt;A、10&lt;/string&gt; &lt;string&gt;B、20&lt;/string&gt; &lt;string&gt;C、30&lt;/string&gt; &lt;string&gt;D、400&lt;/string&gt; &lt;/Option&gt; &lt;/Topic&gt; &lt;Topic&gt; &lt;TopicType&gt;3&lt;/TopicType&gt; &lt;Ask&gt;消防员灭火防护服的面料由外层、防水透气层、隔热层、舒适层组成。（）&lt;/Ask&gt; &lt;Answer&gt;A&lt;/Answer&gt; &lt;/Topic&gt;&lt;/ArrayOfTopic&gt; 开发环境： 语言：java工具：myeclipse处理word文档：poi相关jar包处理xml文件：dom4j相关jar包 参考网址：java使用poi读取doc和docx文件利用dom4j创建xml文件并保存到本地实例 发现：poi会把word文档转化为一个字符串，我就把它输出来了，发现它是一行一行输出的。 于是我用split函数把它分割成了字符串数组。基本上是题目一行，当然有的题目也是两行，答案有的是一行，有的答案是大于两行的。 总体思路：就是一行一行的找，如果是题型就记下题型，如果是题目，就提取答案和题目，如果是答案选项，就提取答案选项。 然后我发现了这样一个现象：如果某一行以一、二、三开头的就表示题型，如果以1~9开头的就表示题目，如果A~F开头的就表示答案选项。 提取答案和题目：如果这一行是题目，就在这一行中提取答案，最开始的方法是：找括号里面的东西，利用 indexOf找到（和）的位置，利用substring截取。然后发现题目中也会出现括号，而且频率很高。于是换了一种方法，找到（并且它的下一位是字母，然后（后面找），这个）一定是离刚才找的（是最近的。 其实找到（和）位置之后，就可以把里面的答案替换成空字符就可以了。发现string类没有这个函数，StringBuffer里面的replace有这个方法。 提取答案选项：怎么得到答案选项呢？最开始的方法是以顿号分割，然后在截取拼接。发现这样也不行，因为答案选项中也有很多顿号的。于是换了一种方法，就是：从A开始，截取B前面那一位；在从B开始，截取到C前面那一位……D到最后。 注意的地方：文档很不标准，有的括号是英文的，有的括号是中文的。答案选项的A~F有的这种字体的，有的是另一种字体的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543package cn.leagle;import java.io.FileInputStream;import java.io.FileWriter;import java.io.IOException;import java.io.InputStream;import java.io.Writer;import org.apache.poi.xwpf.extractor.XWPFWordExtractor;import org.apache.poi.xwpf.usermodel.XWPFDocument;import org.dom4j.Document;import org.dom4j.DocumentHelper;import org.dom4j.Element;import org.dom4j.io.OutputFormat;import org.dom4j.io.XMLWriter;import org.junit.Test;/** * * @author leagle * * * * 一、 首先必须去掉换行 * * 比如： 消防头盔左、右水平视野应不小于____，上视野应不小于____，下视野 应不小于____。 * ( C ) * 改成：消防头盔左、右水平视野应不小于____，上视野应不小于____，下视野应不小于____。( C ) * * 二、输出所有题目的答案，以便查找的答案是否正确 * * 比如：(BMW) (B46) (ACF) * * * 有很多漏洞： * (1) 诸如包括字符串(ACF)的题目，解析的答案便会有错。 * (2) 诸如：A、3780EB、3380EC、3580E D、3680E这样的答案选项，解析的答案也会有错。 * * * */public class PoiTestDocx &#123; /* * 答案的漏洞测试 */ @Test public void optionTest() &#123; String temp = &quot;A、3780EB、3380EC、3580E D、3680E&quot;; temp = temp.replaceAll(&quot; &quot;, &quot;&quot;); int i = 0; for (char c = (char) (temp.charAt(i) + 1); c &lt;= &apos;F&apos;; c++) &#123; if (!temp.contains(&quot;&quot; + c)) &#123; char index = (char) (c - 1); String opString = temp.substring(temp.indexOf(index, temp.indexOf(index - 1))); System.out.println(opString); break; &#125; char index = (char) (c - 1); String opString = temp.substring(temp.indexOf(index), temp.indexOf(c, temp.indexOf(index))); System.out.println(opString); &#125; &#125; /** * * 生成的xml文件如下： * * &lt;ArrayOfTopic&gt; * &lt;Topic&gt; * &lt;TopicType&gt;1&lt;/TopicType&gt; * &lt;Ask&gt;消防头盔经高温、低温、浸水、热辐射预处理后进行冲击吸收性能试验，头模所受冲击力的最大值应不大于，帽壳不得有碎片脱落。（）&lt;/Ask&gt; * &lt;Answer&gt;A&lt;/Answer&gt; * &lt;Option&gt; * &lt;string&gt;A、3780N&lt;/string&gt; * &lt;string&gt;B、3380N&lt;/string&gt; * &lt;string&gt;C、3580N&lt;/string&gt; * &lt;string&gt;D、3680N&lt;/string&gt; * &lt;/Option&gt; * &lt;/Topic&gt; * * &lt;Topic&gt; * &lt;TopicType&gt;3&lt;/TopicType&gt; * &lt;Ask&gt;消防员灭火防护服的面料由外层、防水透气层、隔热层、舒适层组成。（）&lt;/Ask&gt; * &lt;Answer&gt;A&lt;/Answer&gt; * &lt;/Topic&gt; * &lt;/ArrayOfTopic&gt; */ @Test public void xmlTest() &#123; Document document = DocumentHelper.createDocument(); Element arrayOfTopic = document.addElement(&quot;ArrayOfTopic&quot;); Element topic = arrayOfTopic.addElement(&quot;Topic&quot;); Element topicType = topic.addElement(&quot;TopicType&quot;); topicType.addText(&quot;1&quot;); Element ask = topic.addElement(&quot;Ask&quot;); ask.addText(&quot;消防头盔经高温、低温、浸水、热辐射预处理后进行冲击吸收性能试验，头模所受冲击力的最大值应不大于，帽壳不得有碎片脱落。（）&quot;); Element answer = topic.addElement(&quot;Answer&quot;); answer.addText(&quot;A&quot;); Element option = topic.addElement(&quot;Option&quot;); Element strElement = option.addElement(&quot;string&quot;); strElement.addText(&quot;A、3780N&quot;); strElement = option.addElement(&quot;string&quot;); strElement.addText(&quot;B、3380N&quot;); strElement = option.addElement(&quot;string&quot;); strElement.addText(&quot;C、3580N&quot;); strElement = option.addElement(&quot;string&quot;); strElement.addText(&quot;D、3680N&quot;); topic = arrayOfTopic.addElement(&quot;Topic&quot;); topicType = topic.addElement(&quot;TopicType&quot;); topicType.addText(&quot;3&quot;); ask = topic.addElement(&quot;Ask&quot;); ask.addText(&quot;消防员灭火防护服的面料由外层、防水透气层、隔热层、舒适层组成。（）&quot;); answer = topic.addElement(&quot;Answer&quot;); answer.addText(&quot;A&quot;); try &#123; OutputFormat outputFormat = OutputFormat.createPrettyPrint(); outputFormat.setLineSeparator(&quot;\\r\\n&quot;); Writer writer = new FileWriter(&quot;D:\\\\dom4jTest2.xml&quot;); XMLWriter outPut = new XMLWriter(writer, outputFormat); outPut.write(document); outPut.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; @Test public void answerTest() &#123; String string = &quot;A、3780NB、3380NC、3580ND、3680N&quot;; int a = string.indexOf(&apos;A&apos;); int b = string.indexOf(&apos;B&apos;); int c = string.indexOf(&apos;C&apos;); int d = string.indexOf(&apos;D&apos;); System.out.println(string.substring(a, b)); System.out.println(string.substring(b, c)); System.out.println(string.substring(c, d)); System.out.println(string.substring(d)); &#125; /* 对于汉字, charAt函数适用不适用 */ @Test public void stringTest() &#123; String s = &quot;我是中国人&quot;; System.out.println(s.charAt(0)); System.out.println(s.charAt(1)); &#125; /* 测试去掉所有空格 */ @Test public void stripSpaceTest() &#123; String s = &quot;2、消防头盔左、右水平视野应不小于____，上视野应不小于____，下视野应不小于____。( C )&quot;; s = s.replaceAll(&quot; &quot;, &quot;&quot;); System.out.println(s); &#125; /** * @throws IOException * * word文档转为xml文件 * * word文档如下： * 一、单选题（220题） * 1、消防头盔经高温、低温、浸水、热辐射预处理后进行冲击吸收性能试验，头模所受冲击力的最大值应不大于，帽壳不得有碎片脱落。（A） * A、3780NB、3380NC、3580N D、3680N * * 二、多选题（200题） 1、消防员灭火防护服撕破强力不小于多少N，下列错误的是（ BCD） * A、100 B、200 C、300 D、400 * * 三、是非题（180题） 1、消防员灭火防护服的面料由外层、防水透气层、隔热层、舒适层组成。（√） * * 转为xml文件如下： * * &lt;ArrayOfTopic&gt; * &lt;Topic&gt; * &lt;TopicType&gt;1&lt;/TopicType&gt; * &lt;Ask&gt;消防头盔经高温、低温、浸水、热辐射预处理后进行冲击吸收性能试验，头模所受冲击力的最大值应不大于，帽壳不得有碎片脱落。（）&lt;/Ask&gt; * &lt;Answer&gt;A&lt;/Answer&gt; * &lt;Option&gt; * &lt;string&gt;A、3780N&lt;/string&gt; * &lt;string&gt;B、3380N&lt;/string&gt; * &lt;string&gt;C、3580N&lt;/string&gt; * &lt;string&gt;D、3680N&lt;/string&gt; * &lt;/Option&gt; * &lt;/Topic&gt; * * &lt;Topic&gt; * &lt;TopicType&gt;2&lt;/TopicType&gt; * &lt;Ask&gt;消防员灭火防护服撕破强力不小于多少N，下列错误的是（）&lt;/Ask&gt; * &lt;Answer&gt;BCD&lt;/Answer&gt; * &lt;Option&gt; * &lt;string&gt;A、10&lt;/string&gt; * &lt;string&gt;B、20&lt;/string&gt; * &lt;string&gt;C、30&lt;/string&gt; * &lt;string&gt;D、400&lt;/string&gt; * &lt;/Option&gt; * &lt;/Topic&gt; * * &lt;Topic&gt; * &lt;TopicType&gt;3&lt;/TopicType&gt; * &lt;Ask&gt;消防员灭火防护服的面料由外层、防水透气层、隔热层、舒适层组成。（）&lt;/Ask&gt; * &lt;Answer&gt;A&lt;/Answer&gt; * &lt;/Topic&gt; * &lt;/ArrayOfTopic&gt; * * * * * 注意的地方： * 1. 括号分两种,一种是（）,另一种是() * 2. 答案选项的字母分两种,一种是A~F,另一种是Ａ~Ｆ * */ @Test public void wordToXmlTest() throws IOException &#123; InputStream is = new FileInputStream(&quot;D:\\\\test.docx&quot;); XWPFDocument doc = new XWPFDocument(is); @SuppressWarnings(&quot;resource&quot;) XWPFWordExtractor extractor = new XWPFWordExtractor(doc); /* 把word文档转成string */ String text = extractor.getText(); /* 把每行分出来 */ String[] textString = text.split(&quot;\\n&quot;); String topicType = &quot;&quot;; String number = &quot;&quot;; /* 创建xml总结点ArrayOfTopic */ Document document = DocumentHelper.createDocument(); Element root = document.addElement(&quot;ArrayOfTopic&quot;); Element option = null; /* 遍历每一行 */ for (String string : textString) &#123; if (string.length() == 0) continue; /* * 获取每行的第一个字符, 根据第一个字符来判断属于哪种情况 * * 第一种情况：一、单选题（220题） * 结果：类型 * 判断：其中有一、二、三代表地址一种情况 * * 第二种情况：1、消防头盔经高温、低温、浸水、热辐射预处理后进行冲击吸收性能试验，头模所受冲击力的最大值应不大于，帽壳不得有碎片脱落。（A） * 结果：题目和答案 * 判断：其中1~9代表第二种情况 * * 第三种情况：A、3780NB、3380NC、3580N D、3680N * 结果：答案选项 * 判断：其中A~F代表第三种情况 */ int i = 0; /* * 去掉所有空格 * * 原因：( A ) 变成 (A) * 目的：找出答案前面那个括号的位置 * 同时也规范了题目和答案 */ String temp = string.replaceAll(&quot; &quot;, &quot;&quot;); /* topic节点 */ Element Topic = null; /* 得到类型 */ if (temp.charAt(i) == &apos;一&apos;) &#123; topicType = &quot;1&quot;; &#125; else if (temp.charAt(i) == &apos;二&apos;) &#123; topicType = &quot;2&quot;; &#125; else if (temp.charAt(i) == &apos;三&apos;) &#123; topicType = &quot;3&quot;; &#125; /* * 属于题目类型 * 原型为：1、消防头盔经高温、低温、浸水、热辐射预处理后进行冲击吸收性能试验，头模所受冲击力的最大值应不大于，帽壳不得有碎片脱落。（A） * * 需求: 得到答案：A * 得到题目：消防头盔经高温、低温、浸水、热辐射预处理后进行冲击吸收性能试验，头模所受冲击力的最大值应不大于，帽壳不得有碎片脱落。（） */ if (&apos;0&apos; &lt;= temp.charAt(i) &amp;&amp; temp.charAt(i) &lt;= &apos;9&apos;) &#123; Topic = root.addElement(&quot;Topic&quot;); /* * 得到题目的序号 * * 原型：1、消防头盔经高温 序号：1 解决：截取开始到顿号之间的字符串 */ number = temp.substring(i, temp.indexOf(&quot;、&quot;)); /* 添加TopicType节点并且赋予内容 */ Element TopicType = Topic.addElement(&quot;TopicType&quot;); TopicType.addText(topicType); int start = 0, end = 0; /* * 去掉序号和顿号 * * 原型：1、消防头盔经高温、低温、浸水、热辐射预处理后进行冲击吸收性能试验，头模所受冲击力的最大值应不大于，帽壳不得有碎片脱落。（A） * 结果：消防头盔经高温、低温、浸水、热辐射预处理后进行冲击吸收性能试验，头模所受冲击力的最大值应不大于，帽壳不得有碎片脱落。（A） * 解决：截取顿号到最后之间的字符串 */ String substr = temp.substring(temp.indexOf(&quot;、&quot;) + 1); /* * 找到答案前面括号前面的括号的位置 * * 原型为：消防头盔经高温、低温、浸水、热辐射预处理后进行冲击吸收性能试验，头模所受冲击力的最大值应不大于，帽壳不得有碎片脱落。（A） * * 解决： * 找到到( 或者 （ 并且下一位是字母, 就代表找到了位置 * 当然这也不是正确答案, 比如(BMW) (B46)(ACF) * 需要自己查看找出的答案是否正确 */ for (int j = 0; j &lt; substr.length(); j++) &#123; if (substr.charAt(j) == &apos;（&apos; || substr.charAt(j) == &apos;(&apos;) &#123; if (&apos;A&apos; &lt;= substr.charAt(j + 1) &amp;&amp; substr.charAt(j + 1) &lt;= &apos;F&apos;) &#123; /*发现有一个例子(B46), 防止它的出现*/ if (&apos;0&apos; &lt;= substr.charAt(j + 2) &amp;&amp; substr.charAt(j + 2) &lt;= &apos;9&apos;) &#123; continue; &#125; start = j; break; &#125; else if (&apos;Ａ&apos; &lt;= substr.charAt(j + 1) &amp;&amp; substr.charAt(j + 1) &lt;= &apos;Ｆ&apos;) &#123; /*发现有一个例子(B46), 防止它的出现*/ if (&apos;0&apos; &lt;= substr.charAt(j + 2) &amp;&amp; substr.charAt(j + 2) &lt;= &apos;9&apos;) &#123; continue; &#125; start = j; break; &#125; else if (substr.charAt(j + 1) == &apos;√&apos; || substr.charAt(j + 1) == &apos;×&apos;) &#123; /*发现有一个例子(B46), 防止它的出现*/ if (&apos;0&apos; &lt;= substr.charAt(j + 2) &amp;&amp; substr.charAt(j + 2) &lt;= &apos;9&apos;) &#123; continue; &#125; start = j; break; &#125; &#125; &#125; /* * 检测题目中是否只有一个换行符 * * 原型： * 1、消防头盔经高温、低温、浸水、热辐射预处理后进行冲击吸收性能试验，头模所受冲击力的最大值应不大于， * 帽壳不得有碎片脱落。（A） * * 这样的话,是没有括号的,必须要把它变成一行 * * 变成这样： * 1、消防头盔经高温、低温、浸水、热辐射预处理后进行冲击吸收性能试验，头模所受冲击力的最大值应不大于，帽壳不得有碎片脱落。（A） */ if (start == 0) &#123; System.out.println(&quot;TopicType:&quot; + topicType + &apos;\\t&apos; + number + &quot;题目中出现了两个换行符&quot;); continue; &#125; /* * 找出答案后面的那个括号 * * 解决： 既然找到了左边括号, 就从这个位置开始查找右边括号 两个式子的原因是 因为有两种括号 */ end = Math.max(end, substr.indexOf(&quot;)&quot;, start)); end = Math.max(end, substr.indexOf(&quot;）&quot;, start)); /* * 使用StringBuffer的原因是想使用它的replace(int start, int end, Stringstr) */ StringBuffer s = new StringBuffer(substr); /* 把答案替换成空格,以便得出题目 */ String ask = s.replace(start + 1, end, &quot;&quot;).toString(); /* 添加Ask节点并且赋予内容 */ Element Ask = Topic.addElement(&quot;Ask&quot;); Ask.addText(ask); /* 获取答案 */ String answer = substr.substring(start + 1, end); // System.out.println(answer); /* 添加Answer节点 */ Element Answer = Topic.addElement(&quot;Answer&quot;); /* * 如果题目是判断对错类型 * * √用A表示,×用B表示 */ if (answer.equals(&quot;√&quot;)) &#123; answer = &quot;A&quot;; &#125; else if (answer.equals(&quot;×&quot;)) &#123; answer = &quot;B&quot;; &#125; else &#123; /* 添加Option节点 */ option = Topic.addElement(&quot;Option&quot;); &#125; /* 给Answer节点赋予内容 */ Answer.addText(answer); &#125; /* * 属于答案类型, 需要获取答案选项 * * 原型为：A、3780NB、3380NC、3580N D、3680N * * 需求: * A、3780N * B、3380N * C、3580N * D、3680N * * 截取A到B前面那个字符, 即为：A、3780N * 截取B到C前面那个字符, 即为：B、3380N * 截取C到D前面那个字符, 即为：C、3580N * 截取D到最后, 即为：D、3680N * * 还是有漏洞 * 比如：A、3780EB、3380EC、3580E D、3680E * 会分成： * A、3780E * B、3380E * C、3580E * D、3680 * E * * * 因为有A和Ａ,所以分了两种情况 */ if (&apos;A&apos; &lt;= temp.charAt(i) &amp;&amp; temp.charAt(i) &lt;= &apos;F&apos;) &#123; for (char c = (char) (temp.charAt(i) + 1); c &lt;= &apos;F&apos;; c++) &#123; if (!temp.contains(&quot;&quot; + c)) &#123; char index = (char) (c - 1); String opString = temp.substring(temp.indexOf(index, temp.indexOf(index - 1))); Element str = option.addElement(&quot;string&quot;); str.addText(opString); break; &#125; char index = (char) (c - 1); String opString = temp.substring(temp.indexOf(index), temp.indexOf(c, temp.indexOf(index))); Element str = option.addElement(&quot;string&quot;); str.addText(opString); &#125; &#125; else if (&apos;Ａ&apos; &lt;= temp.charAt(i) &amp;&amp; temp.charAt(i) &lt;= &apos;Ｆ&apos;) &#123; for (char c = (char) (temp.charAt(i) + 1); c &lt;= &apos;Ｆ&apos;; c++) &#123; if (!temp.contains(&quot;&quot; + c)) &#123; char index = (char) (c - 1); String opString = temp.substring(temp.indexOf(index, temp.indexOf(index - 1))); Element str = option.addElement(&quot;string&quot;); str.addText(opString); break; &#125; char index = (char) (c - 1); String opString = temp.substring(temp.indexOf(index), temp.indexOf(c, temp.indexOf(index))); Element str = option.addElement(&quot;string&quot;); str.addText(opString); &#125; &#125; &#125; try &#123; OutputFormat outputFormat = OutputFormat.createPrettyPrint(); outputFormat.setLineSeparator(&quot;\\r\\n&quot;); Writer writer = new FileWriter(&quot;D:\\\\dom4jTest.xml&quot;); XMLWriter outPut = new XMLWriter(writer, outputFormat); outPut.write(document); outPut.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; close(is); &#125; /** * 关闭输入流 * * @param is */ private static void close(InputStream is) &#123; if (is != null) &#123; try &#123; is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 使用方法：根据提示，把题目中间的换行符去掉。然后输出所有答案，如果答案有错的，那只有手动书写这道题目了。 奇葩问题：然后我就遇到了一个很奇葩的问题，我需要取字符串的第一个字符，在遍历的时候会出错，这个放到最后再说。因为不一定每一个人都会犯这样的错误。 代码如下：123456789//word字符串String text = extractor.getText();//分割出来String[] textString = text.split(&quot;\\n&quot;);//遍历for (String string : textString) &#123; //去得第一个字符 temp.charAt(0);&#125; 12报错：java.lang.StringIndexOutOfBoundsException: String index out of range: 0 12思考：0也取不到吗？这不可能啊! 换了一种方式：1234567891011String text = extractor.getText();//分割出来String[] textString = text.split(&quot;\\n&quot;);//遍历for (String string : textString) &#123; //去得第一个字符 for(int i = 0 ; i &lt; stirng.length(); i++) &#123; temp.charAt(i); break; &#125;&#125; 12结果：这样就是对的，我真的百思不得其解。然后我就这样写了。 12345678910111213真相：后来我知道是怎么回事了。上海市消防总队2017年后勤岗位练兵理论题库（9-中队装备技师岗位）一、单选题（220题）第三行是空行，取不到charAt(0);我上面的代码，定义了一个i，就是这么来的。因为太多i了，所以就直接添加了个i。","tags":[{"name":"poi","slug":"poi","permalink":"http://yoursite.com/tags/poi/"},{"name":"dom4j","slug":"dom4j","permalink":"http://yoursite.com/tags/dom4j/"},{"name":"word文档题库解析","slug":"word文档题库解析","permalink":"http://yoursite.com/tags/word文档题库解析/"},{"name":"xml文件创建","slug":"xml文件创建","permalink":"http://yoursite.com/tags/xml文件创建/"}]},{"title":"构造队列","date":"2017-07-13T09:09:00.000Z","path":"2017/07/13/queue/","text":"题目链接：网易有道2017内推编程题第二题 12时间限制：1秒空间限制：32768K 小明同学把1到n这n个数字按照一定的顺序放入了一个队列Q中。现在他对队列Q执行了如下程序：1234567891011121314151617while(!Q.empty()) //队列不空，执行循环&#123; int x=Q.front(); //取出当前队头的值x Q.pop(); //弹出当前队头 Q.push(x); //把x放入队尾 x = Q.front(); //取出这时候队头的值 printf(&quot;%d\\n&quot;,x); //输出x Q.pop(); //弹出这时候的队头&#125; 做取出队头的值操作的时候，并不弹出当前队头。小明同学发现，这段程序恰好按顺序输出了1,2,3,…,n。现在小明想让你构造出原始的队列，你能做到吗？[注：原题样例第三行5有错，应该为3，以下已修正] 输入描述: 第一行一个整数T（T ≤ 100）表示数据组数，每组数据输入一个数n（1 ≤ n ≤ 100000），输入的所有n之和不超过200000。 输出描述: 对于每组数据，输出一行，表示原始的队列。数字之间用一个空格隔开，不要在行末输出多余的空格. 输入: 412310 输出： 12 12 1 38 1 6 2 10 3 7 4 9 5 我的思路：本来也想逆推来着，可是不知道怎么推，就按照题目的意思一步一步把原数组推出来。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main(int argc, char *argv[])&#123; int T; cin&gt;&gt;T; vector&lt;vector&lt;int&gt; &gt; b; for (int k = 0; k &lt; T; k++) &#123; int n; cin&gt;&gt;n; vector&lt;int&gt; a(n); b.push_back(vector&lt;int&gt;(n)); for (int i = 0; i &lt; n; i++) a[i] = i; int front = 0, rear = n - 1; for (int i = 1; i &lt;= n; i++) &#123; int x = a[front]; front = (front + 1) % n; rear = (rear + 1) % n; a[rear] = x; x = a[front]; b[k][x] = i; front = (front + 1) % n; &#125; &#125; for (int i = 0; i &lt; T; i++) &#123; for (int j = 0; j &lt; b[i].size(); j++) &#123; if (j == 0) cout&lt;&lt;b[i][j]; else cout&lt;&lt;&apos; &apos;&lt;&lt;b[i][j]; &#125; cout&lt;&lt;endl; &#125; return 0;&#125;","tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"},{"name":"网易有道","slug":"网易有道","permalink":"http://yoursite.com/tags/网易有道/"},{"name":"队列","slug":"队列","permalink":"http://yoursite.com/tags/队列/"}]},{"title":"洗牌","date":"2017-07-13T09:08:00.000Z","path":"2017/07/13/cards/","text":"题目链接：网易有道2017内推编程题第一题 12时间限制：1秒空间限制：32768K 洗牌在生活中十分常见，现在需要写一个程序模拟洗牌的过程。现在需要洗2n张牌，从上到下依次是第1张，第2张，第3张一直到第2n张。首先，我们把这2n张牌分成两堆，左手拿着第1张到第n张（上半堆），右手拿着第n+1张到第2n张（下半堆）。接着就开始洗牌的过程，先放下右手的最后一张牌，再放下左手的最后一张牌，接着放下右手的倒数第二张牌，再放下左手的倒数第二张牌，直到最后放下左手的第一张牌。接着把牌合并起来就可以了。例如有6张牌，最开始牌的序列是1,2,3,4,5,6。首先分成两组，左手拿着1,2,3；右手拿着4,5,6。在洗牌过程中按顺序放下了6,3,5,2,4,1。把这六张牌再次合成一组牌之后，我们按照从上往下的顺序看这组牌，就变成了序列1,4,2,5,3,6。 现在给出一个原始牌组，请输出这副牌洗牌k次之后从上往下的序列。 输入描述: 第一行一个数T(T ≤ 100)，表示数据组数。对于每组数据，第一行两个数n,k(1 ≤ n,k ≤ 100)，接下来一行有2n个数a1,a2,…,a2n(1 ≤ ai ≤ 1000000000)。表示原始牌组从上到下的序列。 输出描述: 对于每组数据，输出一行，最终的序列。数字之间用空格隔开，不要在行末输出多余的空格 输入: 33 11 2 3 4 5 63 21 2 3 4 5 62 21 1 1 1 输出： 1 4 2 5 3 61 5 4 3 2 61 1 1 1 我的思路：我就照着题目的思路写了一下，原本以为会超时，没想到没有超时，而且还通过了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main(int argc, char *argv[])&#123; int T, n; cin&gt;&gt;T; vector&lt; vector&lt;int&gt; &gt; a (T, vector&lt;int&gt;()); vector&lt;int&gt; k(T); for (int i = 0; i &lt; T; i++) &#123; cin&gt;&gt;n&gt;&gt;k[i]; for (int j = 0; j &lt; 2 * n; j++) &#123; int temp; cin&gt;&gt;temp; a[i].push_back(temp); &#125; &#125; for (int i = 0; i &lt; T; i++) &#123; for (int j = 0; j &lt; k[i]; j++) &#123; n = a[i].size() / 2; vector&lt;int&gt; b(n), c(n); for (int j = 0; j &lt; n; j++) &#123; b[j] = a[i][j]; &#125; for (int j = n; j &lt; 2 * n; j++) &#123; c[j - n] = a[i][j]; &#125; int m = 2 * n - 1; for (int j = n - 1; j &gt;= 0; j--) &#123; a[i][m] = c[j]; m--; a[i][m] = b[j]; m--; &#125; &#125; &#125; for (int i = 0; i &lt; T; i++) &#123; for (int j = 0; j &lt; a[i].size(); j++) &#123; if (j == 0) cout&lt;&lt;a[i][j]; else cout&lt;&lt;&apos; &apos;&lt;&lt;a[i][j]; &#125; cout&lt;&lt;endl; &#125; return 0;&#125; 12345678910111213141516171819202122看了评论之后，一个人说： 如果当前数小于等于n（即在左手），则他下次出现的位置是 2*当前位置-1 如果当前位置大于n（即在右手）,则他下次出现的位置是 2*（当前位置 - n）我就又重新思考，他们的位置关系：对于数组：1 2 3 4 5 6第一次后：1 4 2 5 3 6第二次后：1 5 4 3 2 6你便会发现： 前3个位于1、3、5, 对于代码而言：0、2、4 后3个位于2、4、6, 对于代码而言：1、3、5for (int i = 0; i &lt; n; i++) a[2 * i] = b[i];for (int i = 0; i &lt; n; i++) a[2 * i + 1] = b[i + n];发现也可以写到一起：for (int i = 0; i &lt; n; i++) &#123; a[2 * i] = b[i]; a[2 * i + 1] = b[i + n];&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;vector&gt; #include &lt;algorithm&gt;using namespace std;int main(int argc, char *argv[])&#123; vector&lt;int&gt; getSqe(int n, int k); int T; cin&gt;&gt;T; int n, k; vector&lt;vector&lt;int&gt; &gt; result; while(T--) &#123; cin&gt;&gt;n&gt;&gt;k; result.push_back(getSqe(n, k)); &#125; for (int i = 0; i &lt; result.size(); i++) &#123; for (int j = 0; j &lt; result[i].size(); j++) &#123; if (j == 0) &#123; cout&lt;&lt;result[i][j]; &#125; else &#123; cout&lt;&lt;&apos; &apos;&lt;&lt;result[i][j]; &#125; &#125; cout&lt;&lt;endl; &#125; return 0;&#125;vector&lt;int&gt; getSqe(int n, int k) &#123; vector&lt;int&gt; result(2 * n); for (int i = 0; i &lt; 2 * n; i++) &#123; cin&gt;&gt; result[i]; &#125; while (k--) &#123; vector&lt;int&gt; temp(result.begin(), result.end()); for (int i = 0; i &lt; n; i++) &#123; result[2 * i] = temp[i]; result[2 * i + 1] = temp[n + i]; &#125; &#125; return result;&#125;","tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"},{"name":"网易有道","slug":"网易有道","permalink":"http://yoursite.com/tags/网易有道/"},{"name":"找规律","slug":"找规律","permalink":"http://yoursite.com/tags/找规律/"}]},{"title":"分饼干","date":"2017-07-11T08:18:00.000Z","path":"2017/07/11/cookies/","text":"题目链接：网易2017春招笔试真题编程题集合第十二题 12时间限制：1秒空间限制：32768K 易老师购买了一盒饼干，盒子中一共有k块饼干，但是数字k有些数位变得模糊了，看不清楚数字具体是多少了。易老师需要你帮忙把这k块饼干平分给n个小朋友，易老师保证这盒饼干能平分给n个小朋友。现在你需要计算出k有多少种可能的数值 输入描述: 输入包括两行： 第一行为盒子上的数值k，模糊的数位用X表示，长度小于18(可能有多个模糊的数位) 第二行为小朋友的人数n 输出描述: 输出k可能的数值种数，保证至少为1 输入: 9999999999999X3 输出： 4 我的思路：把所有情况找出来，不就得了，就用了回溯法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;using namespace std;#include&lt;vector&gt;string s;int sum = 0;int main(int argc, char *argv[])&#123; long long getIntValue(string s); // 把字符串转化为数字 vector&lt;int&gt; getXVector(string s);// 得到X的位置 void getKinds(vector&lt;int&gt; x, int k, int n);// 获得所有的情况 int n; cin&gt;&gt;s&gt;&gt;n; vector&lt;int&gt; x = getXVector(s); getKinds(x, 0, n); cout&lt;&lt;sum&lt;&lt;endl; return 0;&#125;long long getIntValue(string s) &#123; long long value = 0; for(int i = 0; i &lt; s.size(); i++) &#123; value = value * 10 + (s[i] - &apos;0&apos;); &#125; return value;&#125;vector&lt;int&gt; getXVector(string s) &#123; vector&lt;int&gt; x; for(int i = 0; i &lt; s.size(); i++) &#123; if (s[i] == &apos;X&apos;) x.push_back(i); &#125; return x;&#125;void getKinds(vector&lt;int&gt; x, int k, int n) &#123; if (k == x.size()) &#123; long long num = getIntValue(s); if (num % n == 0) sum++; &#125; else &#123; for (int i = 0; i &lt;= 9; i++) &#123; if (x[k] == 0 &amp;&amp; i == 0) continue; s[x[k]] = &apos;0&apos; + i; getKinds(x, k + 1, n); &#125; &#125;&#125; 1结果：运行超时。 参考： 古典文化的评论 12dp[i][j] 表示从从左往右数，第i位数字，余数为j的个数 dp[0][0] = 1 代表初始情况下模n为0的个数为1 12345678910int newJ = (j * 10 + k) % n; 如上图所示，4774 % 4=2，过程是怎么样来的？ 可以细化为： 第一位数为4：(0 * 10 + 4) % 4 = 0 tip: 0 * 10，所以dp[0][0] = 1 第二位数为7：(0 * 10 + 7) % 4 = 3 第三位数为7：(3 * 10 + 7) % 4 = 1 第四位数为3：(1 * 10 + 4) % 4 = 2 dp[i][newJ] += dp[i - 1][j]; newJ(i)是由j(i-1)得来的，所以满足j(i-1)的情况下会同样满足newJ(i)，所以满足newJ(i)的个数等于本身的个数加上满足j(i-1)的个数。 4772 % 4 这个延续的过程，如下： 0 1 2 3 0 1 0 0 0 1(4) 1 0 0 0 2(7) 0 0 0 1 3(7) 0 1 0 0 4(4) 0 0 1 0 又比如2X % 2 的所有情况，如下： 0 1 0 1 0 1(2) 1 0 2(X) 5 5 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main(int argc, char *argv[])&#123; string s; int n; cin&gt;&gt;s&gt;&gt;n; vector&lt;vector&lt;int&gt; &gt; dp (s.length() + 1, vector&lt;int&gt;(n, 0)); dp[0][0] = 1; for (int i = 1; i &lt;= s.length(); i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (dp[i - 1][j] == 0) continue; if (s[i - 1] == &apos;X&apos;) &#123; for (int k = 0; k &lt; 10; k++) &#123; int temp = (j * 10 + k) % n; dp[i][temp] += dp[i - 1][j]; &#125; &#125; else &#123; int temp = (j * 10 + (s[i - 1] - &apos;0&apos;)) % n; dp[i][temp] += dp[i - 1][j]; &#125; &#125; &#125; cout&lt;&lt;dp[s.length()][0]&lt;&lt;endl; return 0;&#125; 1测试用例通过90%，原因是因为结果太大，int装不下，只要把int改成long long就可以了。 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main(int argc, char *argv[])&#123; string s; int n; cin&gt;&gt;s&gt;&gt;n; // 注意类型 long long vector&lt;vector&lt;long long&gt; &gt; dp (s.length() + 1, vector&lt;long long&gt;(n, 0)); dp[0][0] = 1; for (int i = 1; i &lt;= s.length(); i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (dp[i - 1][j] == 0) continue; if (s[i - 1] == &apos;X&apos;) &#123; for (int k = 0; k &lt; 10; k++) &#123; int temp = (j * 10 + k) % n; dp[i][temp] += dp[i - 1][j]; &#125; &#125; else &#123; int temp = (j * 10 + (s[i - 1] - &apos;0&apos;)) % n; dp[i][temp] += dp[i - 1][j]; &#125; &#125; &#125; cout&lt;&lt;dp[s.length()][0]&lt;&lt;endl; return 0;&#125; 1当然，可以改成二维数组。 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main(int argc, char *argv[])&#123; string s; int n; cin&gt;&gt;s&gt;&gt;n; vector&lt;vector&lt;long long&gt; &gt; dp (2, vector&lt;long long&gt;(n, 0)); dp[0 &amp; 1][0] = 1; for (int i = 1; i &lt;= s.length(); i++) &#123; for (int j = 0; j &lt; n; j++) // 注意的地方，用之前，先置为0 dp[i &amp; 1][j] = 0; for (int j = 0; j &lt; n; j++) &#123; if (dp[(i - 1) &amp; 1][j] == 0) continue; if (s[i - 1] == &apos;X&apos;) &#123; for (int k = 0; k &lt; 10; k++) &#123; int temp = (j * 10 + k) % n; dp[i &amp; 1][temp] += dp[(i - 1) &amp; 1][j]; &#125; &#125; else &#123; int temp = (j * 10 + (s[i - 1] - &apos;0&apos;)) % n; dp[i &amp; 1][temp] += dp[(i - 1) &amp; 1][j]; &#125; &#125; &#125; cout&lt;&lt;dp[s.length() &amp; 1][0]&lt;&lt;endl; return 0;&#125;","tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"},{"name":"网易","slug":"网易","permalink":"http://yoursite.com/tags/网易/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"}]},{"title":"堆砖块","date":"2017-07-10T08:15:00.000Z","path":"2017/07/10/bricks/","text":"题目链接：网易2017春招笔试真题编程题集合第十一题 12时间限制：1秒空间限制：32768K 小易有n块砖块，每一块砖块有一个高度。小易希望利用这些砖块堆砌两座相同高度的塔。为了让问题简单，砖块堆砌就是简单的高度相加，某一块砖只能使用在一座塔中一次。小易现在让能够堆砌出来的两座塔的高度尽量高，小易能否完成呢。 输入描述: 输入包括两行：第一行为整数n(1 ≤ n ≤ 50)，即一共有n块砖块第二行为n个整数，表示每一块砖块的高度height[i] (1 ≤ height[i] ≤ 500000) 输出描述: 如果小易能堆砌出两座高度相同的塔，输出最高能拼凑的高度，如果不能则输出-1.保证答案不大于500000。 输入: 32 3 5 输出： 5 我的思路：这不就是01背包问题吗？我就快马加鞭的写了一通。1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;#define N 50#define MAX 500001int main(int argc, char *argv[])&#123; int a[N],b[MAX]=&#123;0&#125;; int sum = 0; int n; cin&gt;&gt;n; for (int i = 0; i &lt; n; i++) &#123; cin&gt;&gt;a[i]; sum += a[i]; &#125; if (sum % 2 != 0) &#123; cout&lt;&lt;-1&lt;&lt;endl; return 0; &#125; else sum /= 2; for (int i = 0; i &lt; n; i++) &#123; int value = a[i]; for (int j = sum; j &gt;= 1; j--) &#123; int temp = b[j - value] + value; if (j &gt;= value &amp;&amp; temp &gt; b[j]) b[j] = temp; &#125; &#125; if (b[sum] == sum) cout&lt;&lt;sum&lt;&lt;endl; else cout&lt;&lt;-1&lt;&lt;endl; return 0;&#125; 1结果：没有通过所有实例，原来不是所有的砖块都要用到，比如3,3,5那么答案就是3。这就和01背包相差甚远了。 参考1： 双塔问题 大致意思就是这样，dp[i][j] 表示高度分别为i和j是否存在。若存在即为1，若不存在即为0。 dp[0][0] = 1 代表存在高度分别为0和0的情况，比如什么都不放。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main(int argc, char *argv[])&#123; int sum = 0, n; cin&gt;&gt;n; vector&lt;int&gt; a(n); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; sum += a[i]; &#125; sum /= 2; vector&lt; vector&lt;int&gt; &gt; dp(2, vector&lt;int&gt;(sum + 1, 0)); dp[0][0] = 1; for (int i = 0; i &lt; n; i++) &#123; int value = a[i]; for (int j = sum; j &gt;= 0; j--) &#123; for (int k = sum; k &gt;= 0; k--) &#123; if (j &gt;= value) dp[j][k] = dp[j][k] || dp[j - value][k]; if (k &gt;= value) dp[j][k] = dp[j][k] || dp[j][k - value]; &#125; &#125; &#125; for (int i = 1; i &lt;= sum; i++) &#123; if (dp[i][i] == 1) &#123; cout&lt;&lt;i&lt;&lt;endl; return 0; &#125; &#125; cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl; return 0;&#125; 1结果：内存超限 参考2： 古典文化的评论参考1里面把这种方法已经讲的很详细了，我就不多说了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main(int argc, char *argv[])&#123; int n; cin&gt;&gt;n; vector&lt;int&gt; a(n + 1), sum(n + 1); for (int i = 1; i &lt;= n; i++) cin&gt;&gt;a[i]; sum[0] = 0; for (int i = 1; i &lt;= n; i++) &#123; sum[i] = a[i] + sum[i - 1]; &#125; vector&lt; vector&lt;int&gt; &gt; dp(n + 1, vector&lt;int&gt;(sum[n] + 1, -1)); dp[0][0] = 0; for (int i = 1; i &lt;= n; i++) &#123; int value = a[i]; for (int j = sum[i]; j &gt;= 0; j--) &#123; dp[i][j] = dp[i-1][j]; if (j + value &lt;= sum[i] &amp;&amp; dp[i - 1][j + value] != -1) &#123; dp[i][j] = max(dp[i][j], dp[i - 1][j + value]); &#125; if (value &gt;= j &amp;&amp; dp[i - 1][value - j] != -1) &#123; dp[i][j] = max(dp[i][j], dp[i - 1][value - j] + j); &#125; if (j &gt; value &amp;&amp; dp[i - 1][j - value] != -1) &#123; dp[i][j] = max(dp[i][j], dp[i - 1][j - value] + value); &#125; &#125; &#125; if (dp[n][0] == 0) cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl; else cout&lt;&lt;dp[n][0]&lt;&lt;endl; return 0;&#125; 1结果：内存超限。 还记得01背包将多维数组变成一维数组，这个可不可以变成一维数组呢？答案是不可以，只能缩短为二位数组，因为 dp[i][j] = dp[i-1][j]，它始终要用到前面一行的同为j列的结果。 0的时候第一行1的时候第二行(可以用第一行的结果)2的时候第一行(覆盖第一行（0）的数据，可以用第二行（1）的结果)3的时候第二行(覆盖第二行（2）的数据，可以用第一行（2）的结果) 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main(int argc, char *argv[])&#123; int n; cin&gt;&gt;n; vector&lt;int&gt; a(n + 1); vector&lt;int&gt; sum(n+1); sum[0] = 0; for (int i = 1; i &lt;= n; i++) &#123; cin&gt;&gt;a[i]; sum[i] = a[i] + sum[i - 1]; &#125; vector&lt; vector&lt;int&gt; &gt; dp(2, vector&lt;int&gt;(sum[n] + 1, -1)); dp[0][0] = 0; for (int i = 1; i &lt;= n; i++) &#123; int value = a[i]; for (int j = sum[i]; j &gt;= 0; j--) &#123; dp[i &amp; 1][j] = dp[ (i-1) &amp; 1][j]; if (j + value &lt;= sum[i] &amp;&amp; dp[ (i-1) &amp; 1][j + value] != -1) &#123; dp[i &amp; 1][j] = max(dp[i &amp; 1][j], dp[ (i-1) &amp; 1][j + value]); &#125; if (value &gt;= j &amp;&amp; dp[ (i-1) &amp; 1][value - j] != -1) &#123; dp[i &amp; 1][j] = max(dp[i &amp; 1][j], dp[ (i-1) &amp; 1][value - j] + j); &#125; if (j &gt;= value &amp;&amp; dp[ (i-1) &amp; 1][j - value] != -1) &#123; dp[i &amp; 1][j] = max(dp[i &amp; 1][j], dp[ (i-1) &amp; 1][j - value] + value); &#125; &#125; &#125; if (dp[n &amp; 1][0] == 0) cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl; else cout&lt;&lt;dp[n &amp; 1][0]&lt;&lt;endl; return 0;&#125; 1234567891011121314结果：成功。不过我有一点始终不明白，上述有四种情况，分别是：第一种：不放第二种：放到矮的那一堆，但是依旧是矮的（（j + value） &lt;= sum[i]）第三种：放到矮的那一堆，但是变成高的了（value &gt;= j）第四种：放到高的那一堆（j &gt;= value）第二种的时候，j可能大于value，j也有可能小于value，也就是说：满足第二种情况的时候有时候也满足第三种或第四种的条件，但是它不属于第三种或第四种情况，但是它会执行。满足第三种情况的时候有时候也满足第二种条件，但是它不属于第二种情况，但是它会执行。满足第四种情况的时候有时候也满足第二种条件，但是它不属于第二种情况，但是它会执行。但是结果是正确的，我始终想不通。 参考3： minnnng的评论 假设砖块分为A，B两堆，dp[i][j]中的j表示B-A的长度。而dp[i][j]的值则表示当B-A的值为j时，A的最大长度是多少。 因为B-A有可能是负的，所以j整体偏移sum个长度，即2*sum+1。dp[0][0] 代表相差 （-sum），dp[0][sum]代表相差0，dp[0][2$\\ast$sum]代表相差sum。 dp[i][j] = dp[i-1][j] 表示我不用第i块砖dp[i][j] = max(dp[i-1][j+h] + h, dp[i][j]) 表示我把砖放在A堆。dp[i][j] = max(dp[i-1][j-h], dp[i][j]) 表示我把砖放在B堆。 以上语句摘抄与上述评论中的内容，唯一不同的是，我dp[i][j]表示B-A的值为j时，A的最大长度。 我认为这种思路更有说服性，简单明了，不会错失所有情况。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main(int argc, char *argv[])&#123; int n; cin&gt;&gt;n; vector&lt;int&gt; a(n + 1); vector&lt;int&gt; sum(n+1); sum[0] = 0; for (int i = 1; i &lt;= n; i++) &#123; cin&gt;&gt;a[i]; sum[i] = a[i] + sum[i - 1]; &#125; vector&lt; vector&lt;int&gt; &gt; dp(2, vector&lt;int&gt;(2 * sum[n] + 1, -1)); dp[0][sum[n]] = 0; for (int i = 1; i &lt;= n; i++) &#123; int value = a[i]; for (int j = sum[n] + sum[i]; j &gt;= sum[n] - sum[i]; j--) &#123; dp[i &amp; 1][j] = dp[ (i-1) &amp; 1][j]; if ((j + value) &lt;= (sum[n] + sum[i]) &amp;&amp; dp[ (i-1) &amp; 1][j + value] != -1) dp[i &amp; 1][j] = max(dp[i &amp; 1][j], dp[ (i-1) &amp; 1][j + value] + value); if ((j - value) &gt;= (sum[n] - sum[i]) &amp;&amp; dp[ (i-1) &amp; 1][j - value] != -1) dp[i &amp; 1][j] = max(dp[i &amp; 1][j], dp[ (i-1) &amp; 1][j - value]); &#125; &#125; if (dp[n &amp; 1][sum[n]] == 0) cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl; else cout&lt;&lt;dp[n &amp; 1][sum[n]]&lt;&lt;endl; return 0;&#125;","tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"},{"name":"网易","slug":"网易","permalink":"http://yoursite.com/tags/网易/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"}]},{"title":"小易记单词","date":"2017-07-07T09:44:00.000Z","path":"2017/07/07/rememberWord/","text":"题目链接：网易2017春招笔试真题编程题集合第十题 12时间限制：1秒空间限制：32768K 小易参与了一个记单词的小游戏。游戏开始系统提供了m个不同的单词，小易记忆一段时间之后需要在纸上写出他记住的单词。小易一共写出了n个他能记住的单词，如果小易写出的单词是在系统提供的，将获得这个单词长度的平方的分数。注意小易写出的单词可能重复，但是对于每个正确的单词只能计分一次。 输入描述: 输入数据包括三行： 第一行为两个整数n(1 ≤ n ≤ 50)和m(1 ≤ m ≤ 50)。以空格分隔 第二行为n个字符串，表示小易能记住的单词，以空格分隔，每个单词的长度小于等于50。 第三行为m个字符串，系统提供的单词，以空格分隔，每个单词的长度小于等于50。 输出描述: 输出一个整数表示小易能获得的分数 输入: 3 4apple orange strawberrstrawberry orange grapefruit watermelon 输出： 136 我的思路：起初我还想一个字符一个字符进行比较，遇到空格便是一个单词。 然后意识到，字符串也是可以比较的。 又遇到了不能重复，我就用了一个数组来表示答对的单词。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;#define N 50int main(int argc, char *argv[])&#123; string s1[N], s2[N], s3[N]; int sum = 0, score = 0; int m, n; cin&gt;&gt;m&gt;&gt;n; for (int i = 0; i &lt; m; i++) cin&gt;&gt;s1[i]; for (int i = 0; i &lt; n; i++) cin&gt;&gt;s2[i]; for (int i = 0; i &lt; m; i++) &#123; bool flag = false; for (int j = 0; j &lt; n ; j++) &#123; if (s1[i] == s2[j]) &#123; flag = true; break; &#125; &#125; if (flag) &#123; bool isIN = false; for (int k = 0; k &lt; sum; k++) &#123; if (s3[k] == s1[i]) &#123; isIN = true; break; &#125; &#125; if (!isIN) &#123; s3[sum++] = s1[i]; score += pow(s1[i].size(), 2); &#125; &#125; &#125; cout&lt;&lt;score&lt;&lt;endl; return 0;&#125; 结果是对的，我看了一下评论，看到一个人和我做的一样，看到他下面的评论，可以用vis标记系统单词已经被记住的。 我想到了工作安排那一道题，我好想也是这么做的，为什么就记不住呢？ 12345678910111213141516171819202122232425262728293031改进版：#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;#define N 50int main(int argc, char *argv[])&#123; string s1[N], s2[N]; int s[N] = &#123;0&#125;, score = 0; int m, n; cin&gt;&gt;m&gt;&gt;n; for (int i = 0; i &lt; m; i++) cin&gt;&gt;s1[i]; for (int i = 0; i &lt; n; i++) cin&gt;&gt;s2[i]; for (int i = 0; i &lt; m; i++) &#123; int j; for (j = 0; j &lt; n ; j++) &#123; if (s1[i] == s2[j]) &#123; if (!s[j]) &#123; score += pow(s1[i].size(), 2); s[j] = 1; &#125; break; &#125; &#125; &#125; cout&lt;&lt;score&lt;&lt;endl; return 0;&#125;","tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"},{"name":"网易","slug":"网易","permalink":"http://yoursite.com/tags/网易/"},{"name":"标记已用","slug":"标记已用","permalink":"http://yoursite.com/tags/标记已用/"}]},{"title":"涂棋盘","date":"2017-07-07T08:37:00.000Z","path":"2017/07/07/chessboard/","text":"题目链接：网易2017春招笔试真题编程题集合第九题 12时间限制：1秒空间限制：32768K 小易有一块n*n的棋盘，棋盘的每一个格子都为黑色或者白色，小易现在要用他喜欢的红色去涂画棋盘。小易会找出棋盘中某一列中拥有相同颜色的最大的区域去涂画，帮助小易算算他会涂画多少个棋格。 输入描述: 接下来的n行每行一个字符串表示第i行棋盘的颜色，’W’表示白色，’B’表示黑色 输出描述: 输出小易会涂画的区域大小 输入: 3BWWBBBBWB 输出： 3 我的思路：一列一列的找，找出最长连续的即可。一开始，我想一列中的白色最多和黑色最多很开，但是很快就否定了，既然找最大，就不用分的那么细了。直接上代码吧。12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;#define N 50int main(int argc, char *argv[])&#123; string s[N]; int n, max = 0; cin&gt;&gt;n; for (int i = 0; i &lt; n; i++) cin&gt;&gt;s[i]; for (int j = 0; j &lt; n; j++) &#123; int i = 0; char c = s[i][j]; while (i &lt; n) &#123; int k, num; for (k = i; k &lt; n &amp;&amp; s[k][j] == c; k++); num = k - i; if (num &gt; max) max = num; if (k == n)// 不然容易出现堆溢出，因为会调用 c = s[n][j] break; c = s[k][j]; i = k; &#125; &#125; cout&lt;&lt;max&lt;&lt;endl; return 0;&#125; 看了大神的代码之后，才发现我写的虽然对，但是有点绕。123456789101112131415161718192021222324252627改进代码：#include &lt;iostream&gt;using namespace std;#define N 50int main(int argc, char *argv[])&#123; string s[N]; int n, max = 1; cin&gt;&gt;n; for (int i = 0; i &lt; n; i++) cin&gt;&gt;s[i]; for (int j = 0; j &lt; n; j++) &#123; int num = 1; for (int i = 0; i &lt; n - 1; i++) &#123; if (s[i][j] == s[i+1][j]) &#123; num++; if (num &gt; max) max = num; &#125; else &#123; num = 1; &#125; &#125; &#125; cout&lt;&lt;max&lt;&lt;endl; return 0;&#125;","tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"},{"name":"网易","slug":"网易","permalink":"http://yoursite.com/tags/网易/"},{"name":"连续区域长度","slug":"连续区域长度","permalink":"http://yoursite.com/tags/连续区域长度/"}]},{"title":"奇怪的表达式","date":"2017-07-07T07:20:00.000Z","path":"2017/07/07/expression/","text":"题目链接：网易2017春招笔试真题编程题集合第八题 12时间限制：1秒空间限制：32768K 常规的表达式求值，我们都会根据计算的优先级来计算。比如$\\ast$ /的优先级就高于+-。但是小易所生活的世界的表达式规则很简单，从左往右依次计算即可，而且小易所在的世界没有除法，意味着表达式中没有/，只有(+, - 和 $\\ast$)。现在给出一个表达式，需要你帮忙计算出小易所在的世界这个表达式的值为多少 输入描述: 输入为一行字符串，即一个表达式。其中运算符只有-,+,*。参与计算的数字只有0~9.保证表达式都是合法的，排列规则如样例所示。 输出描述: 输出一个数，即表达式的值 输入: 3+5*7 输出： 56 我的思路：首先我想到了栈，想到了运算优先级，想到了中缀表达式是不能直接算出结果的，必须通过转化为后缀表达式，然后通过后缀表达式来进行计算。 既然这道题目不考虑优先级，那就好算了。首先把第一个元素压入栈，然后遇到符号，就把栈里面的一个元素和符号后面的那个元素进行计算，然后出栈，把结果压入栈，依次类推。 我考虑到万一数字不是一位数怎么办？所以就首先写了一个把数字找出来，把符号找出来，然后就好写了。123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;int main(int argc, char *argv[])&#123; string s = &quot;1+10*11&quot;; int temp = 0; for (int i = 0; i &lt; s.size(); i++) &#123; if (s[i] == &apos; &apos;) continue; else if (&apos;0&apos; &lt;= s[i] &amp;&amp; s[i] &lt;= &apos;9&apos;) &#123; int c = s[i] - &apos;0&apos;; temp = temp * 10 + c; &#125; else if (s[i] ==&apos;+&apos; || s[i] ==&apos;-&apos; || s[i] ==&apos;*&apos;) &#123; cout&lt;&lt;temp&lt;&lt;endl; cout&lt;&lt;s[i]&lt;&lt;endl; temp = 0; &#125; &#125; cout&lt;&lt;temp&lt;&lt;endl; return 0;&#125; 数字和符号都找好了，我需要知道第一个数字，和遇到符号之后，我还要知道符号后面的数字，我就把它写成了个函数。1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;int main(int argc, char *argv[])&#123; //得到一个数字，k是从第几个位置开始 int getIntValue(string s, int k); string s; cin&gt;&gt;s; int b = getIntValue(s, 0); for(int i = 0; i &lt; s.size(); i++) &#123; if (s[i] ==&apos;+&apos; || s[i] ==&apos;-&apos; || s[i] ==&apos;*&apos;) &#123; int temp = getIntValue(s, i + 1); if (s[i] ==&apos;+&apos;) &#123; b = b + temp; &#125; else if (s[i] ==&apos;-&apos;) &#123; b = b - temp; &#125; else if (s[i] ==&apos;*&apos;) &#123; b = b * temp; &#125; &#125; &#125; cout&lt;&lt;b&lt;&lt;endl; return 0;&#125;int getIntValue(string s, int k) &#123; int temp = 0; for (int i = k; i &lt; s.size(); i++) &#123; if (s[i] == &apos; &apos;) continue; else if (&apos;0&apos; &lt;= s[i] &amp;&amp; s[i] &lt;= &apos;9&apos;) &#123; int c = s[i] - &apos;0&apos;; temp = temp * 10 + c; &#125; else if (s[i] ==&apos;+&apos; || s[i] ==&apos;-&apos; || s[i] ==&apos;*&apos;) &#123; break; &#125; &#125; return temp;&#125; 后来看了一下评论，发现数字只是0~9，根本不会出现两位以上的数字，那这就更好办了，函数也不需要了。 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;int main(int argc, char *argv[])&#123; string s; cin&gt;&gt;s; int b = s[0] - &apos;0&apos;; for(int i = 0; i &lt; s.size(); i++) &#123; if (s[i] ==&apos;+&apos; || s[i] ==&apos;-&apos; || s[i] ==&apos;*&apos;) &#123; int temp = s[i + 1] - &apos;0&apos;; if (s[i] ==&apos;+&apos;) &#123; b = b + temp; &#125; else if (s[i] ==&apos;-&apos;) &#123; b = b - temp; &#125; else if (s[i] ==&apos;*&apos;) &#123; b = b * temp; &#125; &#125; &#125; cout&lt;&lt;b&lt;&lt;endl; return 0;&#125;","tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"},{"name":"网易","slug":"网易","permalink":"http://yoursite.com/tags/网易/"},{"name":"栈","slug":"栈","permalink":"http://yoursite.com/tags/栈/"}]},{"title":"集合","date":"2017-07-04T04:03:00.000Z","path":"2017/07/04/collection/","text":"题目链接：网易2017春招笔试真题编程题集合第七题 12时间限制：1秒空间限制：32768K 小易最近在数学课上学习到了集合的概念,集合有三个特征：1.确定性 2.互异性 3.无序性.小易的老师给了小易这样一个集合：S = { p/q | w ≤ p ≤ x, y ≤ q ≤ z }需要根据给定的w，x，y，z,求出集合中一共有多少个元素。小易才学习了集合还解决不了这个复杂的问题,需要你来帮助他。 输入描述: 输出集合中元素的个数 输出描述: 输出魔力手环使用k次之后的状态，以空格分隔，行末无空格。 输入: 1 10 1 1 输出： 10 我的思路：如果：$\\frac p q = \\frac m n$， 那么：$p \\times n = q \\times m$总的来说,依旧是去除重复这一核心思路。123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;#define N 10000 int main(int argc, char *argv[])&#123; int a[2][N]; int w, x, y, z; cin&gt;&gt;w&gt;&gt;x&gt;&gt;y&gt;&gt;z; a[0][0] = w; a[1][0] = y; int sum = 1; for (int i = w; i &lt;= x; i++) &#123; for (int j = y; j &lt;= z; j++) &#123; bool flag = true; for (int k = 0; k &lt; sum; k++) &#123; if (a[0][k] * j == a[1][k] * i) &#123; flag = false; break; &#125; &#125; if (flag) &#123; a[0][sum] = i; a[1][sum] = j; sum++; &#125; &#125; &#125; cout&lt;&lt;sum&lt;&lt;endl; return 0;&#125;","tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"},{"name":"网易","slug":"网易","permalink":"http://yoursite.com/tags/网易/"},{"name":"去除重复","slug":"去除重复","permalink":"http://yoursite.com/tags/去除重复/"}]},{"title":"工作安排","date":"2017-07-03T10:49:00.000Z","path":"2017/07/03/workplan/","text":"题目链接：网易2017春招笔试真题编程题集合第六题 12时间限制：1秒空间限制：32768K 现在有n位工程师和6项工作(编号为0至5)，现在给出每个人能够胜任的工作序号表(用一个字符串表示，比如：045，表示某位工程师能够胜任0号，4号，5号工作)。现在需要进行工作安排，每位工程师只能被安排到自己能够胜任的工作当中去，两位工程师不能安排到同一项工作当中去。如果两种工作安排中有一个人被安排在的工作序号不一样就被视为不同的工作安排，现在需要计算出有多少种不同工作安排计划。 输入描述: 输入数据有n+1行：第一行为工程师人数n(1 ≤ n ≤ 6)接下来的n行，每行一个字符串表示第i(1 ≤ i ≤ n)个人能够胜任的工作(字符串不一定等长的) 输出描述: 输出一个整数，表示有多少种不同的工作安排方案 输入例子: 6012345012345012345012345012345012345 输出例子： 720 我的思路：其实，我理解的意思是，所有的工作都要做完，根据上面的例子，所有的情况应该是$6^6$，但是上面的答案是$6!$，我就理解成了，所有的工作都要做完，并且所有的人都要参与进去。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/*这道题目题意有点模糊我理解的意思：所有的工作都要做完，而且所有的成员都要参与进去下面的代码就是实现上述功能 */#include &lt;iostream&gt;using namespace std;#include&lt;string.h&gt;#define N 6int sum = 0;int b[N];int main(int argc, char *argv[])&#123; void fun(string a[], int m, int n, int k); bool judge(int n, int k); string a[6] = &#123; &quot;012345&quot;, &quot;012345&quot;, &quot;012345&quot;, &quot;012345&quot;, &quot;012345&quot;, &quot;012345&quot; &#125;; int n = 6; int k = 6; fun(a, 0, n, k); cout&lt;&lt;sum&lt;&lt;endl; return 0;&#125;//确保所有的人都参与 bool judge(int n, int k) &#123; for (int i = 0; i &lt; k; i++) &#123; int j; for (j = 0; j &lt; n; j++)&#123; if (b[j] == i) break; &#125; if (j == n) return false; &#125; return true;&#125;//回溯求解 void fun(string a[], int m, int n, int k) &#123; if (m == n &amp;&amp; judge(n, k)) sum++; else &#123; for (int i = 0; i &lt; k; i++) &#123; for (int j = 0; j &lt; a[i].size(); j++) &#123; if((int)(a[i][j] - &apos;0&apos;) == m)&#123; b[m] = i; fun(a, m+1, n, k); &#125; &#125; &#125; &#125;&#125; 12345结果：运行错误，没有通过所有实例后来看了一下评论，原来意思理解错了。真正意思：①：每个人做一件事情，且唯一②：不用把所有的工作做完 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/*这道题目题意有点模糊其实意思是：1、所有工程师都必须有事可做，且只能做一件事情。2、不必所有事都要做。 下面的代码就是实现上述功能 */#include &lt;iostream&gt;using namespace std;#include&lt;string.h&gt;#define N 6int sum = 0;char b[N];int main(int argc, char *argv[])&#123; void fun(string a[], int m, int k); bool judge(int n); string a[N]; int k; cin&gt;&gt;k; for(int i = 0; i &lt; k; i++) cin&gt;&gt;a[i]; fun(a, 0, k); cout&lt;&lt;sum&lt;&lt;endl; return 0;&#125;//判断有没有人做相同的工作 bool judge(int n) &#123; for (int i = 0; i &lt; n - 1; i++) &#123; for (int j = i + 1; j &lt; n; j++) &#123; if (b[i] == b[j]) return false; &#125; &#125; return true;&#125;//回溯法求解 void fun(string a[], int m, int k) &#123; if (m == k) &#123; sum++; &#125; else &#123; for (int j = 0; j &lt; a[m].size(); j++) &#123; b[m] = a[m][j]; if (judge(m+1)) fun(a, m + 1, k); &#125; &#125;&#125; 12我是用了个双重循环来进行判断。看到其他的评论里，有人是用一个一维数组来记录这份工作是否被做，这样做，感觉效率更高一些。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*这道题目题意有点模糊其实意思是：1、所有工程师都必须有事可做，且只能做一件事情。2、不必所有事都要做。 下面的代码就是实现上述功能 */#include &lt;iostream&gt;using namespace std;#include&lt;string.h&gt;#define N 6int sum = 0;int b[N] = &#123;0&#125;;int main(int argc, char *argv[])&#123; void fun(string a[], int m, int k); string a[N]; int k; cin&gt;&gt;k; for(int i = 0; i &lt; k; i++) cin&gt;&gt;a[i]; fun(a, 0, k); cout&lt;&lt;sum&lt;&lt;endl; return 0;&#125;//回溯法求解 void fun(string a[], int m, int k) &#123; if (m == k) &#123; sum++; &#125; else &#123; for (int j = 0; j &lt; a[m].size(); j++) &#123; int temp = (int)(a[m][j] - &apos;0&apos;); if (b[temp] == 0) &#123; b[temp] = 1; fun(a, m + 1, k); b[temp] = 0; &#125; &#125; &#125;&#125;","tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"},{"name":"网易","slug":"网易","permalink":"http://yoursite.com/tags/网易/"},{"name":"回溯法","slug":"回溯法","permalink":"http://yoursite.com/tags/回溯法/"}]},{"title":"魔力手环","date":"2017-07-02T04:48:00.000Z","path":"2017/07/02/magicBracelet/","text":"题目链接：网易2017春招笔试真题编程题集合第五题 12时间限制：1秒空间限制：32768K 小易拥有一个拥有魔力的手环上面有n个数字(构成一个环),当这个魔力手环每次使用魔力的时候就会发生一种奇特的变化：每个数字会变成自己跟后面一个数字的和(最后一个数字的后面一个数字是第一个),一旦某个位置的数字大于等于100就马上对100取模(比如某个位置变为103,就会自动变为3).现在给出这个魔力手环的构成，请你计算出使用k次魔力之后魔力手环的状态。 输入描述: 输入数据包括两行：第一行为两个整数n(2 ≤ n ≤ 50)和k(1 ≤ k ≤ 2000000000),以空格分隔第二行为魔力手环初始的n个数，以空格分隔。范围都在0至99. 输出描述: 输出魔力手环使用k次之后的状态，以空格分隔，行末无空格。 输入: 3 21 2 3 输出： 8 9 7 我的思路：当我拿到题目的那一刻，我在想，有这么简单，一定在逗我，我猜我写完之后，一定会超时。试试吧。1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;#define MAX 50int main(int argc, char *argv[])&#123; int k, n; int a[MAX]; cin&gt;&gt;n&gt;&gt;k; for (int i = 0; i &lt; n; i++) cin&gt;&gt;a[i]; for (int i = 0; i &lt; k; i++) &#123; int temp = a[0]; for (int j = 0;j &lt; n - 1; j++) &#123; a[j] += a[j+1]; if (a[j] &gt;= 100) a[j] %= 100; &#125; a[n-1] += temp; if (a[n-1] &gt;= 100) a[n-1] %= 100; &#125; for (int i = 0; i &lt; n; i++) &#123; if (i == 0) cout&lt;&lt;a[i]; else cout&lt;&lt;&apos; &apos;&lt;&lt;a[i]; &#125; cout&lt;&lt;endl; return 0;&#125; 12345结果：果然运行超时。我是自己想呢？还是直接看评论？自己想了一小会，算了，不想了，直接看评论吧。还好我及时看了评论，不然我这辈子都想不出来。 快速幂取余：参考内容：快速幂取余算法矩阵快速幂的应用题 – 魔力手环 核心公式：$a^b$ mod $c$ = $(a^{2^\\frac b2})$ mod $c$，b 是偶数$a^b$ mod $c$ = $(a \\ast a^{2^\\frac b2})$ mod $c$，b 是奇数 例子演示：$a^{10} = a^{2^5} = a^2 \\ast a^{4^2} = a^2 \\ast a^{8^1} = a^2 \\ast a^8 \\ast a^{16^0} = a^2 \\ast a^8$$a^7 = a \\ast a^{2^3} = a \\ast a^2 \\ast a^{4^1} = a \\ast a^2 \\ast a^4 \\ast a^{8^0} = a \\ast a^2 \\ast a^4$ 核心代码一：123456789101112int quickMod(int a, int b, int c) &#123; int ans = 1; while (b) &#123; if (b % 2 == 1) ans = (ans * a) % c; b /= 2; a = (a * a) % c; &#125; return ans; &#125; 例子演示：$a^{10}$ a b ans $a$ 10 1 $a^2$ 5 $1 \\ast a^2$ $a^4$ 2 $1 \\ast a^2$ $a^8$ 1 $1 \\ast a^2 \\ast a^8$ $a^{16}$ 0 结束 $a^7$ a b ans $a$ 7 $1 \\ast a$ $a^2$ 3 $1 \\ast a \\ast a^2$ $a^4$ 1 $1 \\ast a \\ast a^2 \\ast a^4$ $a^8$ 0 结束 10 的二进制为：1010$a^{10} = a^2 \\ast a^8$7 的二进制为：111$a^7 = a \\ast a^2 \\ast a^4$1有没有发现规律？凡是为1的就乘以a^n(n为（1、2、4、8……）)。 核心代码二：123456789101112int quickMod(int a, int b, int n) &#123; int ans = 1; while (b) &#123; if (b &amp; 0x1) //如果二进制位为1 ans = ans * a % n; a = a * a % n; b &gt;&gt;= 1 //b向又移1位 &#125; return ans; &#125; 例子演示： $a^{10}$ a b ans $a$ 1010 1 $a^2$ 0101 $1 \\ast a^2$ $a^4$ 0010 $1 \\ast a^2$ $a^8$ 0001 $1 \\ast a^2 \\ast a^8$ $a^{16}$ 0000 结束 $a^7$ a b ans $a$ 111 $1 \\ast a$ $a^2$ 011 $1 \\ast a \\ast a^2$ $a^4$ 001 $1 \\ast a \\ast a^2 \\ast a^4$ $a^8$ 000 结束 大神思路： 大神说：如输入A = [[1, 2, 3]], k = 2。我们可以构造一个这样的矩阵B[[1, 0, 1], [1, 1, 0], [0, 1, 1]]，使得$A*B^k$相当于A转换k次后的样子。于是原问题就变成求矩阵快速幂。快速幂取余中，$a^k$ % c = $(a \\% c)^k \\% c$。 1实际上，把ans当做矩阵A，a当做矩阵B，当然矩阵B的生成也是有规律的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;using namespace std;#define N 50int ans[1][N]; int a[N][N] = &#123;0&#125;;int main(int argc, char *argv[])&#123; //两个矩阵相乘，a1和a2是两个矩阵，m和n是最终矩阵的行数和列数 //row为第一个数组的列数或者第二个数组的行数 //type为0：代表 a = a*a;type为1：代表ans = ans*a void Core(int a1[N][N], int a2[N][N], int m, int n, int row, int type); void power(int k, int n);//快速幂取余，k代表次数，n代表个数 int n, k; cin&gt;&gt;n&gt;&gt;k; //输入矩阵ans for (int i = 0; i &lt; n; i++) cin&gt;&gt;ans[0][i]; //生成矩阵a for (int i = 0; i &lt; n; i++) &#123; a[i][i] = 1; a[(i+1) % n][i] = 1; &#125; //计算矩阵快速幂 power(k, n); //输出矩阵ans for (int i = 0; i &lt; n; i++) &#123; if (i == 0) cout&lt;&lt;ans[0][i]; else cout&lt;&lt;&apos; &apos;&lt;&lt;ans[0][i]; &#125; cout&lt;&lt;endl; return 0;&#125;void Core(int a1[N][N], int a2[N][N], int m, int n, int row, int type) &#123; int temp[N][N] = &#123;0&#125;; for(int i = 0; i &lt; m; i++) &#123; //两个矩阵相乘，保存到temp中 for (int j = 0; j &lt; n; j++) &#123; for (int k = 0; k &lt; row; k++) &#123; if(a1[i][k] == 0 || a2[k][j] == 0) //剪枝 continue; temp[i][j] += a1[i][k] * a2[k][j]; &#125; if (temp[i][j] &gt;= 100) //100取余运算 temp[i][j] %= 100; &#125; &#125; if (type == 1) &#123; for(int i = 0; i &lt; m; i++) //给ans赋值 for (int j = 0; j &lt; n; j++) ans[i][j] = temp[i][j]; &#125; else if (type == 0) &#123; for(int i = 0; i &lt; m; i++) //给a赋值 for (int j = 0; j &lt; n; j++) a[i][j] = temp[i][j]; &#125;&#125;void power(int k, int n) &#123; while(k) &#123; if (k &amp; 0x1 == 1) Core(ans, a, 1, n, n, 1); Core(a, a, n, n, n, 0); k &gt;&gt;= 1; &#125;&#125;","tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"},{"name":"网易","slug":"网易","permalink":"http://yoursite.com/tags/网易/"},{"name":"快速幂取余","slug":"快速幂取余","permalink":"http://yoursite.com/tags/快速幂取余/"},{"name":"矩阵相乘","slug":"矩阵相乘","permalink":"http://yoursite.com/tags/矩阵相乘/"}]},{"title":"消除重复元素","date":"2017-06-29T14:19:00.000Z","path":"2017/06/29/distinct/","text":"题目链接：网易2017春招笔试真题编程题集合第四题 12时间限制：1秒空间限制：32768K 小易有一个长度为n序列，小易想移除掉里面的重复元素，但是小易想是对于每种元素保留最后出现的那个。小易遇到了困难,希望你来帮助他。 输入描述: 输入包括两行：第一行为序列长度n(1 ≤ n ≤ 50)第二行为n个数sequence[i] (1 ≤ sequence[i] ≤ 1000),以空格分隔 输出描述: 输出消除重复元素之后的序列，以空格分隔，行末无空格 输入例子: 9100 100 100 99 99 99 100 100 100 输出例子： 99 100 我的思路：其实去重复元素的例子以前做过，但是以前做的都是保存重复元素的第一个元素。 用一个二维数组记录重复元素和重复元素的最后一个元素的位置，然后递增排序，就可以得到结果。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;using namespace std;#define MAX 50 int main(int argc, char *argv[])&#123; int a[MAX], b[2][MAX], count = 0;// b数组用来记录除重数组， //第一行是元素，第二行是位置 int n; cin&gt;&gt;n; for(int i = 0; i &lt; n; i++) cin&gt;&gt;a[i]; b[0][0] = a[0]; b[1][0] = 0; count++; int i, j; for (i = 1; i &lt; n; i++) &#123; for (j = 0; j &lt; count; j++) &#123; // 判断是否是重复元素 if(a[i] == b[0][j]) &#123; b[1][j] = i; // 覆盖位置 break; &#125; &#125; if (j == count) &#123;// 不是重复元素 b[0][count] = a[i]; //插入数据 b[1][count] = i; //保存位置 count++; &#125; &#125; //排序得到结果 for (int i = 0; i &lt; count-1; i++) &#123; int temp = i; for (int j = i+1; j &lt; count; j++) &#123; if (b[1][j] &lt; b[1][temp]) temp = j; &#125; if (temp != i) &#123; int c = b[0][i]; b[0][i] = b[0][temp]; b[0][temp] = c; c = b[1][i]; b[1][i] = b[1][temp]; b[1][temp] = c; &#125; &#125; for (int i = 0; i &lt; count; i++) &#123; if(i == 0) cout&lt;&lt;b[0][i]; else cout&lt;&lt;&apos; &apos;&lt;&lt;b[0][i]; &#125; cout&lt;&lt;endl; return 0;&#125; 1结果虽然正确，但是感觉代码量还是有点庞大。 大神的思路： ①：倒着去除重复元素，那么保留的就是正序的最后一个②：然后倒着输出就是结果 也许这样说不容易理解，看了代码，就会立马明白。 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;#define MAX 50 int main(int argc, char *argv[])&#123; int a[MAX], b[MAX], count = 0; int n; cin&gt;&gt;n; for(int i = 0; i &lt; n; i++) cin&gt;&gt;a[i]; b[0] = a[n-1]; count++; int i, j; for (i = n-2; i &gt;= 0; i--) &#123; // 倒着去除重复元素 for (j = 0; j &lt; count; j++) &#123; if(a[i] == b[j]) break; &#125; if (j == count) &#123; b[count++] = a[i]; &#125; &#125; for (int i = count-1; i &gt;= 0; i--) &#123;// 倒着输出 if(i == count-1) cout&lt;&lt;b[i]; else cout&lt;&lt;&apos; &apos;&lt;&lt;b[i]; &#125; cout&lt;&lt;endl; return 0;&#125;","tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"},{"name":"网易","slug":"网易","permalink":"http://yoursite.com/tags/网易/"},{"name":"去除重复","slug":"去除重复","permalink":"http://yoursite.com/tags/去除重复/"}]},{"title":"调整队形","date":"2017-06-28T14:29:00.000Z","path":"2017/06/28/adjustOrder /","text":"题目链接：网易2017春招笔试真题编程题集合第三题 12时间限制：1秒空间限制：32768K 在幼儿园有n个小朋友排列为一个队伍，从左到右一个挨着一个编号为(0~n-1)。其中有一些是男生，有一些是女生，男生用’B’表示，女生用’G’表示。小朋友们都很顽皮，当一个男生挨着的是女生的时候就会发生矛盾。作为幼儿园的老师，你需要让男生挨着女生或者女生挨着男生的情况最少。你只能在原队形上进行调整，每次调整只能让相邻的两个小朋友交换位置，现在需要尽快完成队伍调整，你需要计算出最少需要调整多少次可以让上述情况最少。例如：GGBBG -&gt; GGBGB -&gt; GGGBB这样就使之前的两处男女相邻变为一处相邻，需要调整队形2次 输入描述: 输入数据包括一个长度为n且只包含G和B的字符串.n不超过50. 输出描述: 输出一个整数，表示最少需要的调整队伍的次数 输入例子: GGBBG 输出例子： 2 我的思路：①：如果G的个数大于B的个数，那么移动G；否则移动B②：满足①后，如果左边的个数大于右边的个数，则把G或B移动到左边；否则则把G或B移动到右边 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149我的代码：#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;using namespace std;#define MAX 50 int main(int argc, char *argv[])&#123; char arr[MAX]; void shift(char arr[], int m, int n);// 交换位置 bool judge(char arr[], int n);// 判断是否符合要求（男生和女生分开） cin&gt;&gt;arr; int n = strlen(arr), middle, sum = 0; if (judge(arr, n))&#123; cout&lt;&lt;0&lt;&lt;endl; return 0; &#125; int leftG, leftB, rightG, rightB; leftG = leftB = rightG = rightB = 0; if (n % 2 == 0) // 规定中间点 middle = n / 2 - 1; else middle = n / 2; int i,j; for(i = 0; i &lt;= middle; i++) &#123; // 计算左边的G和B的个数 if (arr[i] == &apos;G&apos;) leftG++; else if (arr[i] == &apos;B&apos;) leftB++; &#125; for(j = middle + 1; j &lt; n; j++) &#123; // 计算左边的G和B的个数 if (arr[j] == &apos;G&apos;) rightG++; else if (arr[j] == &apos;B&apos;) rightB++; &#125; if((leftG + rightG) &gt; (leftB + leftB)) &#123; // 如果G的个数大于B的个数 if(leftG &gt; rightG) &#123; // 如果左边G的个数大于右边G的个数 for (i = 0; i &lt; n; i++) &#123; // 把所有的G移动到左边 // 逐个寻找右边的G，把它移到左边B的位置 if (judge(arr, n))&#123; cout&lt;&lt;sum&lt;&lt;endl; break; &#125; if(arr[i] == &apos;B&apos;) &#123; // 找到B的位置 for (j = i + 1; j &lt; n; j++)&#123;// 找到G的位置 if (arr[j] == &apos;G&apos;) &#123; shift(arr, i, j);// 把G移动到左边 sum += abs(i - j);// 累加交换次数 break; &#125; &#125; &#125; &#125; &#125; else &#123;// 如果左边G的个数小于右边G的个数 for (i = n-1; i &gt;= 0; i--) &#123;// 把所有的G移动到右边 // 逐个寻找左边的G，把它移到右边B的位置 if (judge(arr, n))&#123;// 首先判断是否符合队列要求 cout&lt;&lt;sum&lt;&lt;endl; break; &#125; if(arr[i] == &apos;B&apos;) &#123;// 找到B的位置 for (j = i - 1; j &gt;= 0; j--)&#123; if (arr[j] == &apos;G&apos;) &#123; //找到G的位置 shift(arr, i, j);// 把G移动到右边 sum += abs(i - j);// 累加交换次数 break; &#125; &#125; &#125; &#125; &#125; &#125; else &#123;// 如果B的个数大于G的个数，和上面类似的道理。 if(leftB &gt; rightB) &#123; for (i = 0; i &lt; n; i++) &#123; if (judge(arr, n))&#123; cout&lt;&lt;sum&lt;&lt;endl; break; &#125; if(arr[i] == &apos;G&apos;) &#123; for (j = i + 1; j &lt; n; j++)&#123; if (arr[j] == &apos;B&apos;) &#123; shift(arr, i, j); sum += abs(i - j); break; &#125; &#125; &#125; &#125; &#125; else &#123; for (i = n-1; i &gt;= 0; i--) &#123; if (judge(arr, n))&#123; cout&lt;&lt;sum&lt;&lt;endl; break; &#125; if(arr[i] == &apos;G&apos;) &#123; for (j = i - 1; j &gt;= 0; j--)&#123; if (arr[j] == &apos;B&apos;) &#123; shift(arr, i, j); sum += abs(i - j); break; &#125; &#125; &#125; &#125; &#125; &#125; return 0;&#125;void shift(char arr[], int m, int n) &#123; if (m &lt; n) &#123; char c = arr[n]; for (int i = n; i &gt; m; i--) arr[i] = arr[i-1]; arr[m] = c; &#125; else &#123; char c = arr[n]; for (int i = n; i &lt; m; i++) arr[i] = arr[i+1]; arr[m] = c; &#125; &#125;bool judge(char arr[], int n) &#123; int i, j; for(i = 0; i &lt; n-1 &amp;&amp; arr[i]==arr[i+1]; i++); if(i == n-1) return true; for(j = i+1; j &lt; n-1 &amp;&amp; arr[j]==arr[j+1]; j++); if(j == n-1) return true; else return false;&#125; 1结果虽然对了，但是我内心是崩溃的，有这么麻烦吗？算了，还是看看大神们是怎么做的。 大神操作： 大神说： 最终目标是将男孩移到最左边，或者将女孩移到最左边。 如果有B个男孩，则移到最左边的index分别为：0,1,2…B-1,所以所有index的和为（B-1）*B/2。一次遍历，计算目前男孩所在的index的和为sumB，则sumB减去上面的和就是所求的结果。 因此只要一次遍历，计算男孩所在的男孩的个数和男孩所在的index的和，求之差就行了。女孩同理。 最后求最小值。 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main(int argc, char *argv[])&#123; string s; cin&gt;&gt;s; int n = s.size(); int gNum, bNum, gSum, bSum; gNum = bNum = gSum = bSum = 0; for (int i = 0; i &lt; n; i ++) &#123; if (s[i] == &apos;G&apos;)&#123; gNum++; gSum += i; &#125; else &#123; bNum++; bSum += i; &#125; &#125; int ret1 = bSum - (bNum - 1) * bNum / 2; int ret2 = gSum - (gNum - 1) * gNum / 2; cout&lt;&lt;min(ret1, ret2)&lt;&lt;endl; return 0;&#125;","tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"},{"name":"网易","slug":"网易","permalink":"http://yoursite.com/tags/网易/"}]},{"title":"赶去公司","date":"2017-06-27T11:15:00.000Z","path":"2017/06/27/goToCompany/","text":"题目链接：网易2017春招笔试真题编程题集合第二题 12时间限制：1秒空间限制：32768K 终于到周末啦！小易走在市区的街道上准备找朋友聚会，突然服务器发来警报,小易需要立即回公司修复这个紧急bug。假设市区是一个无限大的区域，每条街道假设坐标是(X，Y)，小易当前在(0，0)街道，办公室在(gx,gy)街道上。小易周围有多个出租车打车点，小易赶去办公室有两种选择，一种就是走路去公司，另外一种就是走到一个出租车打车点，然后从打车点的位置坐出租车去公司。每次移动到相邻的街道(横向或者纵向)走路将会花费walkTime时间，打车将花费taxiTime时间。小易需要尽快赶到公司去，现在小易想知道他最快需要花费多少时间去公司。 输入描述： 输入数据包括五行: 第一行为周围出租车打车点的个数n(1 ≤ n ≤ 50) 第二行为每个出租车打车点的横坐标tX[i] (-10000 ≤ tX[i] ≤ 10000) 第三行为每个出租车打车点的纵坐标tY[i] (-10000 ≤ tY[i] ≤ 10000) 第四行为办公室坐标gx,gy(-10000 ≤ gx,gy ≤ 10000),以空格分隔 第五行为走路时间walkTime(1 ≤ walkTime ≤ 1000)和taxiTime(1 ≤ taxiTime ≤ 1000),以空格分隔 输出描述： 输出一个整数表示，小易最快能赶到办公室的时间 输入例子: 2-2 -20 -2-4 -215 3 输出例子: 42 我的思路:根据输入的例子画了一个坐标。①：起点到终点的距离是一定的，出租车花的时间比走路时间少，找出离起点最近的出租车坐标不就得了。1结论：walkTime有可能小于taxiTime的 ②：既然这样的话，分两种情况呗，walkTime &lt; taxiTime, 找出离起点最远的出租车坐标；walkTime &gt; taxiTime,找出离起点最近的出租车坐标；1结论：我是真蠢，当walkTime &lt; taxiTime时，直接走路就可以了，打的干嘛。 ③：那就这样分情况，walkTime &lt; taxiTime, 直接走路；walkTime &gt; taxiTime,找出离起点最近的出租车坐标；1结论：即使walkTime &gt; taxiTime, 如果出租车离起点很远的话，那也是不合算的。所以说走路到公司这种情况是一定要算的，那出租车那种情况怎么得到呢？ ④：起点和终点会构成一个长方形，出租车可能会在这个长方形，也有可能不在这个长方形中。要不分两种情况，一种是在长方形的出租车，另一种是长方形外的出租车。如果存在长方形内的出租车，那找长方形内最近的出租车一定是花时间最少的；如果不存在，那就找长方形外的出租车的最近点，然后在和走路的比较。123456789结论：卧槽，好麻烦。这样做应该可以做出来，但是也太绕了吧。后来我没有忍住，看了一下别人提交的代码，发现好少，但是具体思路没有看到。我就在想，是不是有别的思路呢？后来又仔细审了一下题目：一种就是走路去公司，另外一种就是走到一个出租车打车点，然后从打车点的位置坐出租车去公司。我想到了，这不就是两种情况吗？第一种是走路，第二种是找出租车然后再到公司。把第二种所有的情况的时间都算出来，不用纠结找最远的出租车还是最近的出租车，把起点到出租车再到公司的总时间算出来即可，然后找出最优解。第二种最优解再和第一种比较，最终得到结果。 反思：其实题目已经告诉了你解决方案，而我一直在纠结去哪里找出离起点最近的出租车坐标，关注的点歪了，而且歪的很离谱。 核心:这道题其实就是找出最小值而已。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354我的代码：#include &lt;iostream&gt;using namespace std;#include&lt;math.h&gt;#include&lt;limits.h&gt;#define taxiNumber 50int minvalue = INT_MAX;int main(int argc, char *argv[])&#123; int n, t[taxiNumber][taxiNumber]; int startPoint[1][2] = &#123;0,0&#125;, endPoint[1][2]; int walkTime, taxiTime; cin&gt;&gt;n; for(int i = 0; i &lt; n; i++) &#123; int tX; cin&gt;&gt;tX; t[0][i] = tX; &#125; for(int i = 0; i &lt; n; i++) &#123; int tY; cin&gt;&gt;tY; t[1][i] = tY; &#125; cin&gt;&gt;endPoint[0][0]&gt;&gt;endPoint[0][1]; cin&gt;&gt;walkTime&gt;&gt;taxiTime; int xDistance = abs(endPoint[0][0] - startPoint[0][0]); int yDistance = abs(endPoint[0][1] - startPoint[0][1]); int pureWalkTime = (xDistance + yDistance) * walkTime; for(int i = 0; i &lt; n; i++) &#123; xDistance = abs(t[0][i] - startPoint[0][0]); yDistance = abs(t[1][i] - startPoint[0][1]); int walk = (xDistance + yDistance) * walkTime; xDistance = abs(endPoint[0][0] - t[0][i]); yDistance = abs(endPoint[0][1] - t[1][i]); int taxi = (xDistance + yDistance) * taxiTime; int time = walk + taxi; if(time &lt; minvalue) minvalue = time; &#125; if(minvalue &lt; pureWalkTime) cout&lt;&lt;minvalue&lt;&lt;endl; else cout&lt;&lt;pureWalkTime&lt;&lt;endl; return 0;&#125; 1234567891011121314151617181920212223优秀代码：#include&lt;iostream&gt;#include&lt;cmath&gt; using namespace std; int n,tx[55],ty[55],gx,gy,walkTime,taxiTime;int main()&#123; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) cin&gt;&gt;tx[i]; for(int i=0;i&lt;n;i++) cin&gt;&gt;ty[i]; cin&gt;&gt;gx&gt;&gt;gy; cin&gt;&gt;walkTime&gt;&gt;taxiTime; int ans=(abs(gx-0)+abs(gy-0))*walkTime; for(int i=0;i&lt;n;i++)&#123; int res=(abs(tx[i]-0)+abs(ty[i]-0))*walkTime; res+=(abs(tx[i]-gx)+abs(ty[i]-gy))*taxiTime; ans=min(ans,res); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;","tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"},{"name":"网易","slug":"网易","permalink":"http://yoursite.com/tags/网易/"},{"name":"最小值","slug":"最小值","permalink":"http://yoursite.com/tags/最小值/"}]},{"title":"双核处理","date":"2017-06-26T07:07:00.000Z","path":"2017/06/26/dualCore/","text":"题目链接：网易2017春招笔试真题编程题集合第一题121. 时间限制：1秒2. 空间限制：32768K 一种双核CPU的两个核能够同时的处理任务，现在有n个已知数据量的任务需要交给CPU处理，假设已知CPU的每个核1秒可以处理1kb，每个核同时只能处理一项任务。n个任务可以按照任意顺序放入CPU进行处理，现在需要设计一个方案让CPU处理完这批任务所需的时间最少，求这个最小的时间。 输入描述: 输入包括两行：第一行为整数n(1 ≤ n ≤ 50)第二行为n个整数length[i] (1024 ≤ length[i] ≤ 4194304)，表示每个任务的长度为length[i]kb，每个数均为1024的倍数。 输出描述: 输出一个整数，表示最少需要处理的时间 输入例子: 5 3072 3072 7168 3072 1024 输出例子: 9216 参考内容： 动态规划解决01背包问题 “詆調壹點”的回答下面的“HelloHello233”的回答 我的思路：把这些任务分成两组，然后选择两组时间差最小的那一次分组，然后再取时间比较大的一组。 怎么才能把所有的分组找出来呢？头脑中就想出了“全排列”的概念。好像只是有点点联系，没有必要的联系。 于是我开始思考所有的分组，假如有5个任务，那么只考虑一组的任务分配，另一组就是剩下的任务数。所以第一组的分配为：1，2，第一组如果分配3和4的话，就重复了，再者说，$ C_5^1=C_5^4，C_5^2=C_5^3 $，所以第二组的分配对应为：4，3。假如一共有6个任务，那么第一组的分配为：1,2,3，第二组的分配为：5,4,3。所以我想到了以前做的概率题，经常用到的一个公式就是：$ C_m^n $。 假如有5个任务，那么所有的分配情况就是：$ C_5^1 和 C_5^2$。假如有6个任务，那么所有的分配情况就是：$ C_6^1、 C_6^2 和 C_6^3 $。所以就发现了规律了，假如有n个任务，那么所有的分组情况就是$C_n^1 C_n^2 C_n^3\\ldots C_n^\\frac n2$。 想了想，好想运算量非常非常大。算了，不管了，先把它搞出来吧。 组合部分：关于$ C_m^n $，我应该怎么把所有的情况找出来呢？我就想起来以前做的8皇后问题，用的回溯法，然后就开始试着写代码了。 假如组合为：$ C_6^3 $，结果是：123 124 125 126 134 135 136 145 146 156234 235 236 245 246 256345 346 356456 第一个数字的范围为：1~m-n+1，第二个数字的范围为：2~m-n+2，$ \\ldots$，第n-1个数字的范围为：n-1~m-1，第n个数字的范围为：n~m。 在排列组合的时候，第n个数字的最小值永远比前一个数字大1 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include&lt;limits.h&gt;using namespace std;#define MAX 51int combinArr[MAX];int main(int argc, char *argv[])&#123; void combine(int n, int m, int num); combinArr[0] = 0; combine(2,5,1); return 0;&#125;void combine(int n, int m, int num)&#123; if(num == n+1) &#123; for(int i = 1; i &lt;= n; i++) cout&lt;&lt;combinArr[i]; cout&lt;&lt;endl; &#125;else &#123; for(int i = combinArr[num-1]+1; i &lt;= (m-n+num); i++) &#123; combinArr[num] = i; combine(n, m, num+1); &#125; &#125;&#125; 双核处理 - 我的思路所有的排列组合都找出来了，找出一次组合之后，比如对于$ C_6^3 $，找出123之后，把123所对应的任务数相加，然后再让总任务数减去组合里面的任务数，然后就可以得出两者的差距，然后找出最小的差距即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include&lt;limits.h&gt;#include&lt;math.h&gt;using namespace std;#define MAX 51int a[MAX], b[MAX];// a用来记录组合的数组; b用来记录输入的任务数 int minvalue = INT_MAX;// 两组任务的差距 int out, sum=0;// out用来记录结果; sum用来记录任务的综合 int main(int argc, char *argv[])&#123; void pai(int n, int m, int num);// 组合部分;m和n分别为组合的上下角码;num为1 void compare(int a[], int n, int b[]);//找出差距最小的那一次组合;a为组合;n为a的个数;b为任务数据 a[0] = 0;//a[0]为1主要为了组合部分的第一个数字 int n ; cin&gt;&gt;n; for(int i = 1; i &lt;= n; i++)&#123; //录入任务数 并求出sum int sc; cin&gt;&gt;sc; b[i] = sc; sum += b[i]; &#125; for(int i =1; i &lt;= n/2; i++) // 根据任务的个数，来进行所需要的组合 pai(i, n, 1); cout&lt;&lt;out&lt;&lt;endl;// 输出结果 return 0;&#125;void pai(int n, int m, int num)&#123; void compare(int a[], int m, int b[]); if(num == n+1) &#123; compare(a,n,b); //每一次的组合就要进行一次比较 &#125;else &#123; for(int i = a[num-1]+1; i &lt;= (m-n+num); i++) &#123; a[num] = i; pai(n, m, num+1); &#125; &#125;&#125;void compare(int a[], int n, int b[])&#123; int i, j, num1=0, num2=0; for(i = 1; i&lt;= n; i++) //找出其中一组的任务数 num1 += b[a[i]]; num2 = sum - num1;//另一组的任务数 if(abs(num1-num2) &lt; minvalue)&#123; //更改最小的差距 minvalue = abs(num1-num2); if(num1 &gt; num2) //找出最终结果 out = num1; else out = num2; &#125; &#125; 1结果为：运行超时 01背包问题由于运行超时，然后看了别人的答案，就开始探索01背包问题。其实之前上课的时候学过这个内，当时可能在睡觉，或者在做别的事情，结果现在只是记住了这个标题。 问题描述： 有n 个物品，它们有各自的重量和价值，现有给定容量的背包，如何让背包里装入的物品具有最大的价值总和？ 核心概述： 设$V[i,j]$为前$i$个物品放到背包容量为$j$的背包中为最优解，设$v_i$为第$i$个物品的价值，$w_j$为第$i$个物品的重量。对于$V[i,j]$。(1) 第$i$个物品放不到背包里，则最优解为$V[i-1,j]$(2) 第$i$个物品可以放进背包里，则最优解为前$i-1$个物品的最优解$V[i-1,j-w_i]$与第$i$个物品价值的和，或者就是前$i-1$个物品的最优解，这里取两个中的最大值，即$V[i,j]=Max \\lbrace V[i-1,j-w_i]+v_i,V[i-1,j] \\rbrace$ 核心公式： $V[i,j] = V[i-1,j], w_i &gt; j$$V[i,j] = Max \\lbrace V[i-1,j-w_i]+v_i,V[i-1,j] \\rbrace , w_i \\leq j$当$j \\geq 0$时,$V[0,j]=0$;当$i \\geq 0$时，$V[i,0]$=0 情景再现： 背包容量：5 物品序号 重量 价值 1 2 12￥ 2 1 10￥ 3 3 20￥ 4 2 15￥ 自己根据公式推导一下，就会得出以下的表格。 $i/j$ 0 1 2 3 4 5 0 0 0 0 0 0 0 1 0 0 12 12 12 12 2 0 10 12 22 22 22 3 0 10 12 22 30 32 4 0 10 15 25 30 37 1234567优化前伪代码：for i=1...number for j=1...weight w[i] &gt; j v[i][j] = v[i-1][j] w[i] &lt;= j v[i][j] = max&#123; v[i-1, j-w[i]] + v[i], v[i-1,j] &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;using namespace std;#define weight 5 //背包容量 #define goodsNum 4 //物品个数 int main(int argc, char *argv[])&#123; int goods[goodsNum][2] = &#123;&#123;2, 12&#125;, &#123;1, 10&#125;, &#123;3, 20&#125;, &#123;2, 15&#125;&#125;;//物品的重量和价值 int a[goodsNum+1][weight+1];//记录V[i,j] for(int i=0;i&lt;=weight;i++) //当i&gt;=0时,V[0,i]=0; a[0][i]=0; for(int i=0;i&lt;=goodsNum;i++) //当i&gt;=0时,V[i,0]=0; a[i][0]=0; for(int i = 1;i &lt;= goodsNum; i++)&#123; for(int j = 1; j &lt;= weight; j++)&#123; int goodWeight = goods[i-1][0]; int goodValue = goods[i-1][1]; if(goodWeight &gt; j) &#123; a[i][j] = a[i-1][j]; &#125; else &#123; int putin = a[i-1][j-goodWeight] + goodValue; if(a[i-1][j] &lt; putin) a[i][j] = putin; else a[i][j] = a[i-1][j]; &#125; &#125; &#125; //输出V[i,j] for(int i =0;i&lt;=goodsNum;i++)&#123; for(int j=0; j&lt;=weight; j++) cout&lt;&lt;a[i][j]&lt;&lt;&apos; &apos;; cout&lt;&lt;endl; &#125; //找到背包里包含的物品 int find = weight; int hang = goodsNum; while(find &gt; 0)&#123; for(int i=hang;i&gt;=1;i--)&#123; if(a[i][find] != a[i-1][find])&#123; cout&lt;&lt;i&lt;&lt;&apos; &apos;; hang = i-1; find = find - goods[i-1][0]; break; &#125; &#125; &#125; cout&lt;&lt;endl;&#125; 背包优化： 其实，计算第$i$行的最优值时，只会用到第$i-1$行的数据，用不到$i-2$行的数据，所以可以把二维数组缩减为以为一维数组。但是这样的话，就找不到背包里所包含的物品。 核心公式： 为了混淆，这里用$B$代表一维数组，$B[j]$ 是容量为$j$的最优值，$w_i$代表第$i$个物品的容量，$v_i$代表第$i$个物品的价值。最优值$B[j]=Max \\lbrace B[j-w_i]+v_i,B[j] \\rbrace$ &nbsp;&nbsp;&nbsp;&nbsp;仅当$w_i &lt;= j$ 12345伪代码：for i=1...number for j=weitht...1 w[i] &lt;= j B[j] = max&#123; B[j-w[i]] + v[i], B[j] &#125; 1234注意：j是递减的，为什么呢？如果j是递增的话，会重复的放入某一件物品。自己写写一位数组的变化就知道了。 一维数组的变化( j递减 )： i B[5] B[4] B[3] B[2] B[1] B[0] i=1 12 12 12 12 0 0 i=2 22 22 22 12 10 0 i=3 32 30 22 12 10 0 i=4 37 30 25 15 10 0 有没有发现这个一维数组的每一行和二维数组的每一行是一样的。 一维数组的变化( j递增 )： i B[0] B[1] B[2] B[3] B[4] B[5] i=1 0 0 12 12 24 24 i=2 0 10 20 30 40 50 i=3 0 10 20 30 40 50 i=4 0 10 20 30 40 50 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;#define weight 5#define goodsNum 4int main(int argc, char *argv[])&#123; int goods[goodsNum][2] = &#123;&#123;2, 12&#125;, &#123;1, 10&#125;, &#123;3, 20&#125;, &#123;2, 15&#125;&#125;; int a[weight+1]; for(int i=0;i&lt;=weight;i++) a[i]=0; for(int i =0;i&lt;goodsNum;i++)&#123; for(int j=weight; j&gt;=1; j--)&#123; int goodWeight = goods[i][0]; int goodValue = goods[i][1]; int input = goodValue+a[j-goodWeight]; if(goodWeight &lt;= j &amp;&amp; input &gt; a[j]) a[j] = input; &#125; for(int i=weight;i&gt;=0;i--) cout&lt;&lt;a[i]&lt;&lt;&apos; &apos;; cout&lt;&lt;endl; &#125;&#125; 双核处理 - 01背包那人说，总任务数除以2就是背包的容量，然后每个任务数就是每个物品的容量。 一开始，我在疑惑：01背包问题是背包的容量大于装入物品的容量，但是这个双核处理问题是计算大于背包容量的最小容量，我一直在纠结这个问题，这个应该怎么转化为背包问题呢？ 后来，我想通了。任务分成两组，背包的容量是总任务除以2，其中一组大于背包容量，另外一组是小于背包容量，也有可能两组相等。我们求的是大于或等于背包容量的那一组。你只需要把其中一组计算出来，然后用总数一减不就得出来了。所以你计算小于背包容量的那一组，这样就可以转化为01背包问题了。 123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;#define MAX 102400#define NUM 50int main(int argc, char *argv[])&#123; int n, task[NUM], sum = 0; cin&gt;&gt;n; for(int i = 0; i &lt; n; i++) &#123; cin&gt;&gt;task[i]; task[i] /= 1024; sum += task[i]; &#125; int packWeight = sum / 2; int arr[MAX] = &#123;0&#125;; for(int i = 0; i &lt; n; i++) &#123; for (int j = packWeight; j &gt;= 1; j--) &#123; int taskWeight = task[i]; int input = taskWeight + arr[j-taskWeight]; if(taskWeight &lt;= j &amp;&amp; input &gt; arr[j]) arr[j] = input; &#125; &#125; int maxTaskTime = (sum - arr[packWeight]) * 1024; cout&lt;&lt;maxTaskTime&lt;&lt;endl; return 0;&#125;","tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"},{"name":"网易","slug":"网易","permalink":"http://yoursite.com/tags/网易/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"01背包","slug":"01背包","permalink":"http://yoursite.com/tags/01背包/"}]},{"title":"周杰伦音乐专辑封面","date":"2016-08-07T05:36:00.000Z","path":"2016/08/07/jay/","text":"周杰伦（Jay Chou），1979年1月18日出生于台湾省新北市，中国台湾流行乐男歌手、音乐人、演员、导演、编剧、监制、商人。 12342000年《Jay》;2001年《范特西》;2002年《八度空间》;2003年《叶惠美》;2004年《七里香》;2005年《十一月的肖邦》;2006年《依然范特西》;2007年《我很忙》;2008年《魔杰座》;2010年《跨时代》;2011年《惊叹号》;2012年《十二新作》;2014年《哎呦，不错哦》;2016年《周杰伦的床边故事》 《Jay》发行日期：2000-11-13 1234567891011专辑曲目： 1.可爱女人 2.完美主义 3.星晴 4.娘子 5.斗牛 6.黑色幽默 7.伊斯坦堡 8.印第安老斑鸠 9.龙卷风 10.反方向的钟 《范特西》，发行日期：2001-09-20 1234567891011专辑曲目： 1.爱在西元前 2.爸我回来了 3.简单爱 4.忍者 5.开不了口 6.上海一九四三 7.对不起 8.威廉古堡 9.双截棍 10.安静 《八度空间》，发行日期：2002-07-18 1234567891011专辑曲目： 1.半兽人 2.半岛铁盒 3.暗号 4.龙拳 5.火车叨位去（台） 6.分裂 7.爷爷泡的茶 8.回家过去 9.米兰的小铁匠 10.最后的战役 《叶惠美》，发行日期：2003-07-31 123456789101112专辑曲目： 1.以父之名 2.懦夫 3.晴天 4.三年二班 5.东风破 6.你听得到 7.同一种调调 8.她的睫毛 9.爱情悬崖 10.梯田 11.双刀 《七里香》，发行日期：2004-08-03 1234567891011专辑曲目： 1.我的地盘 2.七里香 3.借口 4.外婆 5.将军 6.搁浅 7.乱舞春秋 8.困兽之斗 9.园游会 10.止战之殇 《11月的萧邦》，发行日期：2005-11-01 12345678910111213专辑曲目： 1.夜曲 2.蓝色风暴(百事可乐广告歌) 3.发如雪 4.黑色毛衣 5.四面楚歌 6.枫 7.浪漫手机 8.逆鳞 9.麦芽糖 10.珊瑚海 11.漂移 12.一路向北 《依然范特西》，发行日期：2006-09-01 1234567891011专辑曲目： 1.夜的第七章 2.听妈妈的话 3.千里之外 4.本草纲目 5.退后 6.红模仿 7.心雨 8.白色风车 9.迷迭香 10.菊花台 《我很忙》，发行日期：2007-11-02 1234567891011专辑曲目： 1.牛仔很忙 2.彩虹 3.青花瓷 4.阳光宅男 5.蒲公英的约定 6.无双 7.我不配 8.扯 9.甜甜的 10.最长的电影 《魔杰座》，发行日期：2008-10-15 123456789101112专辑曲目： 1.龙战骑士 2.给我一首歌的时间 3.蛇舞 4.花海 5.魔术先生 6.说好的幸福呢 7.兰亭序 8.流浪诗人 9.时光机 10.乔克叔叔 11.稻香 《跨时代》，发行日期：2010-05-18 123456789101112专辑曲目： 1.跨时代 2.说了再见 3.烟花易冷 4.免费教学录影带 5.好久不见 6.雨下一整晚 7.嘻哈空姐 8.我落泪，情绪零碎 9.爱的等飞行日记 10.自导自演 11.超人不会飞 《惊叹号》，发行日期：2011-11-11 123456789101112专辑曲目： 1.惊叹号 2.皮影戏 3.Mine Mine 4.你好吗 5.迷魂曲 6.超跑女神 7.世界未末日 8.水手怕水 9.琴伤 10.公主病 11.疗伤烧肉粽 《12新作》，发行日期：2012-12-28 12345678910111213专辑曲目： 1.四季列车 2.手语 3.公公偏头痛 4.明明就 5.傻笑 6.比较大的大提琴 7.爱你没差 8.红尘客栈 9.梦想启动 10.大笨钟 11.哪里都是你 12.乌克丽丽 《哎呦，不错哦》，发行日期：2014-12-26 12345678910111213专辑曲目： 1.阳明山 2.窃爱 3.算什么男人 4.天涯过客 5.怎么了 6.一口气全念对 7.我要夏天 8.手写的从前 9.鞋子特大号 10.听爸爸的话 11.美人鱼 12.听见下雨的声音 《周杰伦的床边故事》，发行日期：2016-06-24 1234567891011专辑曲目： 1.床边故事2.说走就走3.一点点4.前世情人5.英雄6.不该7.土耳其冰淇淋8.告白气球9.Now You See Me10.爱情废柴","tags":[{"name":"周杰伦","slug":"周杰伦","permalink":"http://yoursite.com/tags/周杰伦/"},{"name":"专辑封面","slug":"专辑封面","permalink":"http://yoursite.com/tags/专辑封面/"}]}]