[{"title":"消除重复元素","date":"2017-06-29T14:19:00.000Z","path":"2017/06/29/distinct/","text":"题目链接：网易2017春招笔试真题编程题集合第四题 12时间限制：1秒空间限制：32768K 小易有一个长度为n序列，小易想移除掉里面的重复元素，但是小易想是对于每种元素保留最后出现的那个。小易遇到了困难,希望你来帮助他。 输入描述: 输入包括两行：第一行为序列长度n(1 ≤ n ≤ 50)第二行为n个数sequence[i] (1 ≤ sequence[i] ≤ 1000),以空格分隔 输出描述: 输出消除重复元素之后的序列，以空格分隔，行末无空格 输入例子: 9100 100 100 99 99 99 100 100 100 我的思路：其实去重复元素的例子以前做过，但是以前做的都是保存重复元素的第一个元素。 用一个二维数组记录重复元素和重复元素的最后一个元素的位置，然后递增排序，就可以得到结果。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;using namespace std;#define MAX 50 int main(int argc, char *argv[])&#123; int a[MAX], b[2][MAX], count = 0;// b数组用来记录除重数组， //第一行是元素，第二行是位置 int n; cin&gt;&gt;n; for(int i = 0; i &lt; n; i++) cin&gt;&gt;a[i]; b[0][0] = a[0]; b[1][0] = 0; count++; int i, j; for (i = 1; i &lt; n; i++) &#123; for (j = 0; j &lt; count; j++) &#123; // 判断是否是重复元素 if(a[i] == b[0][j]) &#123; b[1][j] = i; // 覆盖位置 break; &#125; &#125; if (j == count) &#123;// 不是重复元素 b[0][count] = a[i]; //插入数据 b[1][count] = i; //保存位置 count++; &#125; &#125; //排序得到结果 for (int i = 0; i &lt; count-1; i++) &#123; int temp = i; for (int j = i+1; j &lt; count; j++) &#123; if (b[1][j] &lt; b[1][temp]) temp = j; &#125; if (temp != i) &#123; int c = b[0][i]; b[0][i] = b[0][temp]; b[0][temp] = c; c = b[1][i]; b[1][i] = b[1][temp]; b[1][temp] = c; &#125; &#125; for (int i = 0; i &lt; count; i++) &#123; if(i == 0) cout&lt;&lt;b[0][i]; else cout&lt;&lt;&apos; &apos;&lt;&lt;b[0][i]; &#125; cout&lt;&lt;endl; return 0;&#125; 1结果虽然正确，但是感觉代码量还是有点庞大。 大神的思路： ①：倒着去除重复元素，那么保留的就是正序的最后一个②：然后倒着输出就是结果 也许这样说不容易理解，看了代码，就会立马明白。 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;#define MAX 50 int main(int argc, char *argv[])&#123; int a[MAX], b[MAX], count = 0; int n; cin&gt;&gt;n; for(int i = 0; i &lt; n; i++) cin&gt;&gt;a[i]; b[0] = a[n-1]; count++; int i, j; for (i = n-2; i &gt;= 0; i--) &#123; // 倒着去除重复元素 for (j = 0; j &lt; count; j++) &#123; if(a[i] == b[j]) break; &#125; if (j == count) &#123; b[count++] = a[i]; &#125; &#125; for (int i = count-1; i &gt;= 0; i--) &#123;// 倒着输出 if(i == count-1) cout&lt;&lt;b[i]; else cout&lt;&lt;&apos; &apos;&lt;&lt;b[i]; &#125; cout&lt;&lt;endl; return 0;&#125;","tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"},{"name":"网易","slug":"网易","permalink":"http://yoursite.com/tags/网易/"},{"name":"去除重复","slug":"去除重复","permalink":"http://yoursite.com/tags/去除重复/"}]},{"title":"调整队形","date":"2017-06-28T14:29:00.000Z","path":"2017/06/28/adjustOrder /","text":"题目链接：网易2017春招笔试真题编程题集合第三题 12时间限制：1秒空间限制：32768K 在幼儿园有n个小朋友排列为一个队伍，从左到右一个挨着一个编号为(0~n-1)。其中有一些是男生，有一些是女生，男生用’B’表示，女生用’G’表示。小朋友们都很顽皮，当一个男生挨着的是女生的时候就会发生矛盾。作为幼儿园的老师，你需要让男生挨着女生或者女生挨着男生的情况最少。你只能在原队形上进行调整，每次调整只能让相邻的两个小朋友交换位置，现在需要尽快完成队伍调整，你需要计算出最少需要调整多少次可以让上述情况最少。例如：GGBBG -&gt; GGBGB -&gt; GGGBB这样就使之前的两处男女相邻变为一处相邻，需要调整队形2次 输入描述: 输入数据包括一个长度为n且只包含G和B的字符串.n不超过50. 输出描述: 输出一个整数，表示最少需要的调整队伍的次数 输出例子: 2 我的思路：①：如果G的个数大于B的个数，那么移动G；否则移动B②：满足①后，如果左边的个数大于右边的个数，则把G或B移动到左边；否则则把G或B移动到右边 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149我的代码：#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;using namespace std;#define MAX 50 int main(int argc, char *argv[])&#123; char arr[MAX]; void shift(char arr[], int m, int n);// 交换位置 bool judge(char arr[], int n);// 判断是否符合要求（男生和女生分开） cin&gt;&gt;arr; int n = strlen(arr), middle, sum = 0; if (judge(arr, n))&#123; cout&lt;&lt;0&lt;&lt;endl; return 0; &#125; int leftG, leftB, rightG, rightB; leftG = leftB = rightG = rightB = 0; if (n % 2 == 0) // 规定中间点 middle = n / 2 - 1; else middle = n / 2; int i,j; for(i = 0; i &lt;= middle; i++) &#123; // 计算左边的G和B的个数 if (arr[i] == &apos;G&apos;) leftG++; else if (arr[i] == &apos;B&apos;) leftB++; &#125; for(j = middle + 1; j &lt; n; j++) &#123; // 计算左边的G和B的个数 if (arr[j] == &apos;G&apos;) rightG++; else if (arr[j] == &apos;B&apos;) rightB++; &#125; if((leftG + rightG) &gt; (leftB + leftB)) &#123; // 如果G的个数大于B的个数 if(leftG &gt; rightG) &#123; // 如果左边G的个数大于右边G的个数 for (i = 0; i &lt; n; i++) &#123; // 把所有的G移动到左边 // 逐个寻找右边的G，把它移到左边B的位置 if (judge(arr, n))&#123; cout&lt;&lt;sum&lt;&lt;endl; break; &#125; if(arr[i] == &apos;B&apos;) &#123; // 找到B的位置 for (j = i + 1; j &lt; n; j++)&#123;// 找到G的位置 if (arr[j] == &apos;G&apos;) &#123; shift(arr, i, j);// 把G移动到左边 sum += abs(i - j);// 累加交换次数 break; &#125; &#125; &#125; &#125; &#125; else &#123;// 如果左边G的个数小于右边G的个数 for (i = n-1; i &gt;= 0; i--) &#123;// 把所有的G移动到右边 // 逐个寻找左边的G，把它移到右边B的位置 if (judge(arr, n))&#123;// 首先判断是否符合队列要求 cout&lt;&lt;sum&lt;&lt;endl; break; &#125; if(arr[i] == &apos;B&apos;) &#123;// 找到B的位置 for (j = i - 1; j &gt;= 0; j--)&#123; if (arr[j] == &apos;G&apos;) &#123; //找到G的位置 shift(arr, i, j);// 把G移动到右边 sum += abs(i - j);// 累加交换次数 break; &#125; &#125; &#125; &#125; &#125; &#125; else &#123;// 如果B的个数大于G的个数，和上面类似的道理。 if(leftB &gt; rightB) &#123; for (i = 0; i &lt; n; i++) &#123; if (judge(arr, n))&#123; cout&lt;&lt;sum&lt;&lt;endl; break; &#125; if(arr[i] == &apos;G&apos;) &#123; for (j = i + 1; j &lt; n; j++)&#123; if (arr[j] == &apos;B&apos;) &#123; shift(arr, i, j); sum += abs(i - j); break; &#125; &#125; &#125; &#125; &#125; else &#123; for (i = n-1; i &gt;= 0; i--) &#123; if (judge(arr, n))&#123; cout&lt;&lt;sum&lt;&lt;endl; break; &#125; if(arr[i] == &apos;G&apos;) &#123; for (j = i - 1; j &gt;= 0; j--)&#123; if (arr[j] == &apos;B&apos;) &#123; shift(arr, i, j); sum += abs(i - j); break; &#125; &#125; &#125; &#125; &#125; &#125; return 0;&#125;void shift(char arr[], int m, int n) &#123; if (m &lt; n) &#123; char c = arr[n]; for (int i = n; i &gt; m; i--) arr[i] = arr[i-1]; arr[m] = c; &#125; else &#123; char c = arr[n]; for (int i = n; i &lt; m; i++) arr[i] = arr[i+1]; arr[m] = c; &#125; &#125;bool judge(char arr[], int n) &#123; int i, j; for(i = 0; i &lt; n-1 &amp;&amp; arr[i]==arr[i+1]; i++); if(i == n-1) return true; for(j = i+1; j &lt; n-1 &amp;&amp; arr[j]==arr[j+1]; j++); if(j == n-1) return true; else return false;&#125; 1结果虽然对了，但是我内心是崩溃的，有这么麻烦吗？算了，还是看看大神们是怎么做的。 大神操作： 大神说： 最终目标是将男孩移到最左边，或者将女孩移到最左边。 如果有B个男孩，则移到最左边的index分别为：0,1,2…B-1,所以所有index的和为（B-1）*B/2。一次遍历，计算目前男孩所在的index的和为sumB，则sumB减去上面的和就是所求的结果。 因此只要一次遍历，计算男孩所在的男孩的个数和男孩所在的index的和，求之差就行了。女孩同理。 最后求最小值。 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main(int argc, char *argv[])&#123; string s; cin&gt;&gt;s; int n = s.size(); int gNum, bNum, gSum, bSum; gNum = bNum = gSum = bSum = 0; for (int i = 0; i &lt; n; i ++) &#123; if (s[i] == &apos;G&apos;)&#123; gNum++; gSum += i; &#125; else &#123; bNum++; bSum += i; &#125; &#125; int ret1 = bSum - (bNum - 1) * bNum / 2; int ret2 = gSum - (gNum - 1) * gNum / 2; cout&lt;&lt;min(ret1, ret2)&lt;&lt;endl; return 0;&#125;","tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"},{"name":"网易","slug":"网易","permalink":"http://yoursite.com/tags/网易/"}]},{"title":"赶去公司","date":"2017-06-27T11:15:00.000Z","path":"2017/06/27/goToCompany/","text":"题目链接：网易2017春招笔试真题编程题集合第二题 12时间限制：1秒空间限制：32768K 终于到周末啦！小易走在市区的街道上准备找朋友聚会，突然服务器发来警报,小易需要立即回公司修复这个紧急bug。假设市区是一个无限大的区域，每条街道假设坐标是(X，Y)，小易当前在(0，0)街道，办公室在(gx,gy)街道上。小易周围有多个出租车打车点，小易赶去办公室有两种选择，一种就是走路去公司，另外一种就是走到一个出租车打车点，然后从打车点的位置坐出租车去公司。每次移动到相邻的街道(横向或者纵向)走路将会花费walkTime时间，打车将花费taxiTime时间。小易需要尽快赶到公司去，现在小易想知道他最快需要花费多少时间去公司。 输入描述： 输入数据包括五行: 第一行为周围出租车打车点的个数n(1 ≤ n ≤ 50) 第二行为每个出租车打车点的横坐标tX[i] (-10000 ≤ tX[i] ≤ 10000) 第三行为每个出租车打车点的纵坐标tY[i] (-10000 ≤ tY[i] ≤ 10000) 第四行为办公室坐标gx,gy(-10000 ≤ gx,gy ≤ 10000),以空格分隔 第五行为走路时间walkTime(1 ≤ walkTime ≤ 1000)和taxiTime(1 ≤ taxiTime ≤ 1000),以空格分隔 输出描述： 输出一个整数表示，小易最快能赶到办公室的时间 输入例子: 2-2 -20 -2-4 -215 3 输出例子: 42 我的思路:根据输入的例子画了一个坐标。①：起点到终点的距离是一定的，出租车花的时间比走路时间少，找出离起点最近的出租车坐标不就得了。1结论：walkTime有可能小于taxiTime的 ②：既然这样的话，分两种情况呗，walkTime &lt; taxiTime, 找出离起点最远的出租车坐标；walkTime &gt; taxiTime,找出离起点最近的出租车坐标；1结论：我是真蠢，当walkTime &lt; taxiTime时，直接走路就可以了，打的干嘛。 ③：那就这样分情况，walkTime &lt; taxiTime, 直接走路；walkTime &gt; taxiTime,找出离起点最近的出租车坐标；1结论：即使walkTime &gt; taxiTime, 如果出租车离起点很远的话，那也是不合算的。所以说走路到公司这种情况是一定要算的，那出租车那种情况怎么得到呢？ ④：起点和终点会构成一个长方形，出租车可能会在这个长方形，也有可能不在这个长方形中。要不分两种情况，一种是在长方形的出租车，另一种是长方形外的出租车。如果存在长方形内的出租车，那找长方形内最近的出租车一定是花时间最少的；如果不存在，那就找长方形外的出租车的最近点，然后在和走路的比较。123456789结论：卧槽，好麻烦。这样做应该可以做出来，但是也太绕了吧。后来我没有忍住，看了一下别人提交的代码，发现好少，但是具体思路没有看到。我就在想，是不是有别的思路呢？后来又仔细审了一下题目：一种就是走路去公司，另外一种就是走到一个出租车打车点，然后从打车点的位置坐出租车去公司。我想到了，这不就是两种情况吗？第一种是走路，第二种是找出租车然后再到公司。把第二种所有的情况的时间都算出来，不用纠结找最远的出租车还是最近的出租车，把起点到出租车再到公司的总时间算出来即可，然后找出最优解。第二种最优解再和第一种比较，最终得到结果。 反思：其实题目已经告诉了你解决方案，而我一直在纠结去哪里找出离起点最近的出租车坐标，关注的点歪了，而且歪的很离谱。 核心:这道题其实就是找出最小值而已。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354我的代码：#include &lt;iostream&gt;using namespace std;#include&lt;math.h&gt;#include&lt;limits.h&gt;#define taxiNumber 50int minvalue = INT_MAX;int main(int argc, char *argv[])&#123; int n, t[taxiNumber][taxiNumber]; int startPoint[1][2] = &#123;0,0&#125;, endPoint[1][2]; int walkTime, taxiTime; cin&gt;&gt;n; for(int i = 0; i &lt; n; i++) &#123; int tX; cin&gt;&gt;tX; t[0][i] = tX; &#125; for(int i = 0; i &lt; n; i++) &#123; int tY; cin&gt;&gt;tY; t[1][i] = tY; &#125; cin&gt;&gt;endPoint[0][0]&gt;&gt;endPoint[0][1]; cin&gt;&gt;walkTime&gt;&gt;taxiTime; int xDistance = abs(endPoint[0][0] - startPoint[0][0]); int yDistance = abs(endPoint[0][1] - startPoint[0][1]); int pureWalkTime = (xDistance + yDistance) * walkTime; for(int i = 0; i &lt; n; i++) &#123; xDistance = abs(t[0][i] - startPoint[0][0]); yDistance = abs(t[1][i] - startPoint[0][1]); int walk = (xDistance + yDistance) * walkTime; xDistance = abs(endPoint[0][0] - t[0][i]); yDistance = abs(endPoint[0][1] - t[1][i]); int taxi = (xDistance + yDistance) * taxiTime; int time = walk + taxi; if(time &lt; minvalue) minvalue = time; &#125; if(minvalue &lt; pureWalkTime) cout&lt;&lt;minvalue&lt;&lt;endl; else cout&lt;&lt;pureWalkTime&lt;&lt;endl; return 0;&#125; 1234567891011121314151617181920212223优秀代码：#include&lt;iostream&gt;#include&lt;cmath&gt; using namespace std; int n,tx[55],ty[55],gx,gy,walkTime,taxiTime;int main()&#123; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) cin&gt;&gt;tx[i]; for(int i=0;i&lt;n;i++) cin&gt;&gt;ty[i]; cin&gt;&gt;gx&gt;&gt;gy; cin&gt;&gt;walkTime&gt;&gt;taxiTime; int ans=(abs(gx-0)+abs(gy-0))*walkTime; for(int i=0;i&lt;n;i++)&#123; int res=(abs(tx[i]-0)+abs(ty[i]-0))*walkTime; res+=(abs(tx[i]-gx)+abs(ty[i]-gy))*taxiTime; ans=min(ans,res); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;","tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"},{"name":"网易","slug":"网易","permalink":"http://yoursite.com/tags/网易/"},{"name":"最小值","slug":"最小值","permalink":"http://yoursite.com/tags/最小值/"}]},{"title":"双核处理","date":"2017-06-26T07:07:00.000Z","path":"2017/06/26/dualCore/","text":"题目链接：网易2017春招笔试真题编程题集合第一题121. 时间限制：1秒2. 空间限制：32768K 一种双核CPU的两个核能够同时的处理任务，现在有n个已知数据量的任务需要交给CPU处理，假设已知CPU的每个核1秒可以处理1kb，每个核同时只能处理一项任务。n个任务可以按照任意顺序放入CPU进行处理，现在需要设计一个方案让CPU处理完这批任务所需的时间最少，求这个最小的时间。 输入描述: 输入包括两行：第一行为整数n(1 ≤ n ≤ 50)第二行为n个整数lengthi，表示每个任务的长度为length[i]kb，每个数均为1024的倍数。 输出描述: 输出一个整数，表示最少需要处理的时间 输入例子: 5 3072 3072 7168 3072 1024 输出例子: 9216 参考内容： 动态规划解决01背包问题 “詆調壹點”的回答下面的“HelloHello233”的回答 我的思路：把这些任务分成两组，然后选择两组时间差最小的那一次分组，然后再取时间比较大的一组。 怎么才能把所有的分组找出来呢？头脑中就想出了“全排列”的概念。好像只是有点点联系，没有必要的联系。 于是我开始思考所有的分组，假如有5个任务，那么只考虑一组的任务分配，另一组就是剩下的任务数。所以第一组的分配为：1，2，第一组如果分配3和4的话，就重复了，再者说，$ C_5^1=C_5^4，C_5^2=C_5^3 $，所以第二组的分配对应为：4，3。假如一共有6个任务，那么第一组的分配为：1,2,3，第二组的分配为：5,4,3。所以我想到了以前做的概率题，经常用到的一个公式就是：$ C_m^n $。 假如有5个任务，那么所有的分配情况就是：$ C_5^1 和 C_5^2$。假如有6个任务，那么所有的分配情况就是：$ C_6^1、 C_6^2 和 C_6^3 $。所以就发现了规律了，假如有n个任务，那么所有的分组情况就是$C_n^1 C_n^2 C_n^3\\ldots C_n^\\frac n2$。 想了想，好想运算量非常非常大。算了，不管了，先把它搞出来吧。 组合部分：关于$ C_m^n $，我应该怎么把所有的情况找出来呢？我就想起来以前做的8皇后问题，用的回溯法，然后就开始试着写代码了。 假如组合为：$ C_6^3 $，结果是：123 124 125 126 134 135 136 145 146 156234 235 236 245 246 256345 346 356456 第一个数字的范围为：1~m-n+1，第二个数字的范围为：2~m-n+2，$ \\ldots$，第n-1个数字的范围为：n-1~m-1，第n个数字的范围为：n~m。 在排列组合的时候，第n个数字的最小值永远比前一个数字大1 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include&lt;limits.h&gt;using namespace std;#define MAX 51int combinArr[MAX];int main(int argc, char *argv[])&#123; void combine(int n, int m, int num); combinArr[0] = 0; combine(2,5,1); return 0;&#125;void combine(int n, int m, int num)&#123; if(num == n+1) &#123; for(int i = 1; i &lt;= n; i++) cout&lt;&lt;combinArr[i]; cout&lt;&lt;endl; &#125;else &#123; for(int i = combinArr[num-1]+1; i &lt;= (m-n+num); i++) &#123; combinArr[num] = i; combine(n, m, num+1); &#125; &#125;&#125; 双核处理 - 我的思路所有的排列组合都找出来了，找出一次组合之后，比如对于$ C_6^3 $，找出123之后，把123所对应的任务数相加，然后再让总任务数减去组合里面的任务数，然后就可以得出两者的差距，然后找出最小的差距即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include&lt;limits.h&gt;#include&lt;math.h&gt;using namespace std;#define MAX 51int a[MAX], b[MAX];// a用来记录组合的数组; b用来记录输入的任务数 int minvalue = INT_MAX;// 两组任务的差距 int out, sum=0;// out用来记录结果; sum用来记录任务的综合 int main(int argc, char *argv[])&#123; void pai(int n, int m, int num);// 组合部分;m和n分别为组合的上下角码;num为1 void compare(int a[], int n, int b[]);//找出差距最小的那一次组合;a为组合;n为a的个数;b为任务数据 a[0] = 0;//a[0]为1主要为了组合部分的第一个数字 int n ; cin&gt;&gt;n; for(int i = 1; i &lt;= n; i++)&#123; //录入任务数 并求出sum int sc; cin&gt;&gt;sc; b[i] = sc; sum += b[i]; &#125; for(int i =1; i &lt;= n/2; i++) // 根据任务的个数，来进行所需要的组合 pai(i, n, 1); cout&lt;&lt;out&lt;&lt;endl;// 输出结果 return 0;&#125;void pai(int n, int m, int num)&#123; void compare(int a[], int m, int b[]); if(num == n+1) &#123; compare(a,n,b); //每一次的组合就要进行一次比较 &#125;else &#123; for(int i = a[num-1]+1; i &lt;= (m-n+num); i++) &#123; a[num] = i; pai(n, m, num+1); &#125; &#125;&#125;void compare(int a[], int n, int b[])&#123; int i, j, num1=0, num2=0; for(i = 1; i&lt;= n; i++) //找出其中一组的任务数 num1 += b[a[i]]; num2 = sum - num1;//另一组的任务数 if(abs(num1-num2) &lt; minvalue)&#123; //更改最小的差距 minvalue = abs(num1-num2); if(num1 &gt; num2) //找出最终结果 out = num1; else out = num2; &#125; &#125; 1结果为：运行超时 01背包问题由于运行超时，然后看了别人的答案，就开始探索01背包问题。其实之前上课的时候学过这个内，当时可能在睡觉，或者在做别的事情，结果现在只是记住了这个标题。 问题描述： 有n 个物品，它们有各自的重量和价值，现有给定容量的背包，如何让背包里装入的物品具有最大的价值总和？ 核心概述： 设$V[i,j]$为前$i$个物品放到背包容量为$j$的背包中为最优解，设$v_i$为第$i$个物品的价值，$w_j$为第$i$个物品的重量。对于$V[i,j]$。(1) 第$i$个物品放不到背包里，则最优解为$V[i-1,j]$(2) 第$i$个物品可以放进背包里，则最优解为前$i-1$个物品的最优解$V[i-1,j-w_i]$与第$i$个物品价值的和，或者就是前$i-1$个物品的最优解，这里取两个中的最大值，即$V[i,j]=Max{V[i-1,j-w_i]+v_i,V[i-1,j]}$ 核心公式： $V[i,j] = V[i-1,j], w_i &gt; j $$V[i,j] = Max(V[i-1,j-w_i]+v_i,V[i-1,j]), w_i &lt;= j$当$j&gt;=0$时,$V[0,j]=0$;当$i&gt;=0$时，$V[i,0]$=0 情景再现： 背包容量：5 物品序号 重量 价值 1 2 12￥ 2 1 10￥ 3 3 20￥ 4 2 15￥ 自己根据公式推导一下，就会得出以下的表格。 $i/j$ 0 1 2 3 4 5 0 0 0 0 0 0 0 1 0 0 12 12 12 12 2 0 10 12 22 22 22 3 0 10 12 22 30 32 4 0 10 15 25 30 37 1234567优化前伪代码：for i=1...number for j=1...weight w[i] &gt; j v[i][j] = v[i-1][j] w[i] &lt;= j v[i][j] = max&#123; v[i-1, j-w[i]] + v[i], v[i-1,j] &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;using namespace std;#define weight 5 //背包容量 #define goodsNum 4 //物品个数 int main(int argc, char *argv[])&#123; int goods[goodsNum][2] = &#123;&#123;2, 12&#125;, &#123;1, 10&#125;, &#123;3, 20&#125;, &#123;2, 15&#125;&#125;;//物品的重量和价值 int a[goodsNum+1][weight+1];//记录V[i,j] for(int i=0;i&lt;=weight;i++) //当i&gt;=0时,V[0,i]=0; a[0][i]=0; for(int i=0;i&lt;=goodsNum;i++) //当i&gt;=0时,V[i,0]=0; a[i][0]=0; for(int i = 1;i &lt;= goodsNum; i++)&#123; for(int j = 1; j &lt;= weight; j++)&#123; int goodWeight = goods[i-1][0]; int goodValue = goods[i-1][1]; if(goodWeight &gt; j) &#123; a[i][j] = a[i-1][j]; &#125; else &#123; int putin = a[i-1][j-goodWeight] + goodValue; if(a[i-1][j] &lt; putin) a[i][j] = putin; else a[i][j] = a[i-1][j]; &#125; &#125; &#125; //输出V[i,j] for(int i =0;i&lt;=goodsNum;i++)&#123; for(int j=0; j&lt;=weight; j++) cout&lt;&lt;a[i][j]&lt;&lt;&apos; &apos;; cout&lt;&lt;endl; &#125; //找到背包里包含的物品 int find = weight; int hang = goodsNum; while(find &gt; 0)&#123; for(int i=hang;i&gt;=1;i--)&#123; if(a[i][find] != a[i-1][find])&#123; cout&lt;&lt;i&lt;&lt;&apos; &apos;; hang = i-1; find = find - goods[i-1][0]; break; &#125; &#125; &#125; cout&lt;&lt;endl;&#125; 背包优化： 其实，计算第$i$行的最优值时，只会用到第$i-1$行的数据，用不到$i-2$行的数据，所以可以把二维数组缩减为以为一维数组。但是这样的话，就找不到背包里所包含的物品。 核心公式： 为了混淆，这里用$B$代表一维数组，$B[j]$ 是容量为$j$的最优值，$w_i$代表第$i$个物品的容量，$v_i$代表第$i$个物品的价值。最优值$B[j]=Max(B[j-w_i]+v_i,B[j])$ &nbsp;&nbsp;&nbsp;&nbsp;仅当$w_i &lt;= j$ 12345伪代码：for i=1...number for j=weitht...1 w[i] &lt;= j B[j] = max&#123; B[j-w[i]] + v[i], B[j] &#125; 1234注意：j是递减的，为什么呢？如果j是递增的话，会重复的放入某一件物品。自己写写一位数组的变化就知道了。 一维数组的变化( j递减 )： i B[5] B[4] B[3] B[2] B[1] B[0] i=1 12 12 12 12 0 0 i=2 22 22 22 12 10 0 i=3 32 30 22 12 10 0 i=4 37 30 25 15 10 0 有没有发现这个一维数组的每一行和二维数组的每一行是一样的。 一维数组的变化( j递增 )： i B[0] B[1] B[2] B[3] B[4] B[5] i=1 0 0 12 12 24 24 i=2 0 10 20 30 40 50 i=3 0 10 20 30 40 50 i=4 0 10 20 30 40 50 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;#define weight 5#define goodsNum 4int main(int argc, char *argv[])&#123; int goods[goodsNum][2] = &#123;&#123;2, 12&#125;, &#123;1, 10&#125;, &#123;3, 20&#125;, &#123;2, 15&#125;&#125;; int a[weight+1]; for(int i=0;i&lt;=weight;i++) a[i]=0; for(int i =0;i&lt;goodsNum;i++)&#123; for(int j=weight; j&gt;=1; j--)&#123; int goodWeight = goods[i][0]; int goodValue = goods[i][1]; int input = goodValue+a[j-goodWeight]; if(goodWeight &lt;= j &amp;&amp; input &gt; a[j]) a[j] = input; &#125; for(int i=weight;i&gt;=0;i--) cout&lt;&lt;a[i]&lt;&lt;&apos; &apos;; cout&lt;&lt;endl; &#125;&#125; 双核处理 - 01背包那人说，总任务数除以2就是背包的容量，然后每个任务数就是每个物品的容量。 一开始，我在疑惑：01背包问题是背包的容量大于装入物品的容量，但是这个双核处理问题是计算大于背包容量的最小容量，我一直在纠结这个问题，这个应该怎么转化为背包问题呢？ 后来，我想通了。任务分成两组，背包的容量是总任务除以2，其中一组大于背包容量，另外一组是小于背包容量，也有可能两组相等。我们求的是大于或等于背包容量的那一组。你只需要把其中一组计算出来，然后用总数一减不就得出来了。所以你计算小于背包容量的那一组，这样就可以转化为01背包问题了。 123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;#define MAX 102400#define NUM 50int main(int argc, char *argv[])&#123; int n, task[NUM], sum = 0; cin&gt;&gt;n; for(int i = 0; i &lt; n; i++) &#123; cin&gt;&gt;task[i]; task[i] /= 1024; sum += task[i]; &#125; int packWeight = sum / 2; int arr[MAX] = &#123;0&#125;; for(int i = 0; i &lt; n; i++) &#123; for (int j = packWeight; j &gt;= 1; j--) &#123; int taskWeight = task[i]; int input = taskWeight + arr[j-taskWeight]; if(taskWeight &lt;= j &amp;&amp; input &gt; arr[j]) arr[j] = input; &#125; &#125; int maxTaskTime = (sum - arr[packWeight]) * 1024; cout&lt;&lt;maxTaskTime&lt;&lt;endl; return 0;&#125;","tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"},{"name":"网易","slug":"网易","permalink":"http://yoursite.com/tags/网易/"},{"name":"01背包","slug":"01背包","permalink":"http://yoursite.com/tags/01背包/"}]},{"title":"周杰伦音乐专辑封面","date":"2016-08-07T05:36:00.000Z","path":"2016/08/07/jay/","text":"周杰伦（Jay Chou），1979年1月18日出生于台湾省新北市，中国台湾流行乐男歌手、音乐人、演员、导演、编剧、监制、商人。 12342000年《Jay》;2001年《范特西》;2002年《八度空间》;2003年《叶惠美》;2004年《七里香》;2005年《十一月的肖邦》;2006年《依然范特西》;2007年《我很忙》;2008年《魔杰座》;2010年《跨时代》;2011年《惊叹号》;2012年《十二新作》;2014年《哎呦，不错哦》;2016年《周杰伦的床边故事》 《Jay》发行日期：2000-11-13 1234567891011专辑曲目： 1.可爱女人 2.完美主义 3.星晴 4.娘子 5.斗牛 6.黑色幽默 7.伊斯坦堡 8.印第安老斑鸠 9.龙卷风 10.反方向的钟 《范特西》，发行日期：2001-09-20 1234567891011专辑曲目： 1.爱在西元前 2.爸我回来了 3.简单爱 4.忍者 5.开不了口 6.上海一九四三 7.对不起 8.威廉古堡 9.双截棍 10.安静 《八度空间》，发行日期：2002-07-18 1234567891011专辑曲目： 1.半兽人 2.半岛铁盒 3.暗号 4.龙拳 5.火车叨位去（台） 6.分裂 7.爷爷泡的茶 8.回家过去 9.米兰的小铁匠 10.最后的战役 《叶惠美》，发行日期：2003-07-31 123456789101112专辑曲目： 1.以父之名 2.懦夫 3.晴天 4.三年二班 5.东风破 6.你听得到 7.同一种调调 8.她的睫毛 9.爱情悬崖 10.梯田 11.双刀 《七里香》，发行日期：2004-08-03 1234567891011专辑曲目： 1.我的地盘 2.七里香 3.借口 4.外婆 5.将军 6.搁浅 7.乱舞春秋 8.困兽之斗 9.园游会 10.止战之殇 《11月的萧邦》，发行日期：2005-11-01 12345678910111213专辑曲目： 1.夜曲 2.蓝色风暴(百事可乐广告歌) 3.发如雪 4.黑色毛衣 5.四面楚歌 6.枫 7.浪漫手机 8.逆鳞 9.麦芽糖 10.珊瑚海 11.漂移 12.一路向北 《依然范特西》，发行日期：2006-09-01 1234567891011专辑曲目： 1.夜的第七章 2.听妈妈的话 3.千里之外 4.本草纲目 5.退后 6.红模仿 7.心雨 8.白色风车 9.迷迭香 10.菊花台 《我很忙》，发行日期：2007-11-02 1234567891011专辑曲目： 1.牛仔很忙 2.彩虹 3.青花瓷 4.阳光宅男 5.蒲公英的约定 6.无双 7.我不配 8.扯 9.甜甜的 10.最长的电影 《魔杰座》，发行日期：2008-10-15 123456789101112专辑曲目： 1.龙战骑士 2.给我一首歌的时间 3.蛇舞 4.花海 5.魔术先生 6.说好的幸福呢 7.兰亭序 8.流浪诗人 9.时光机 10.乔克叔叔 11.稻香 《跨时代》，发行日期：2010-05-18 123456789101112专辑曲目： 1.跨时代 2.说了再见 3.烟花易冷 4.免费教学录影带 5.好久不见 6.雨下一整晚 7.嘻哈空姐 8.我落泪，情绪零碎 9.爱的等飞行日记 10.自导自演 11.超人不会飞 《惊叹号》，发行日期：2011-11-11 123456789101112专辑曲目： 1.惊叹号 2.皮影戏 3.Mine Mine 4.你好吗 5.迷魂曲 6.超跑女神 7.世界未末日 8.水手怕水 9.琴伤 10.公主病 11.疗伤烧肉粽 《12新作》，发行日期：2012-12-28 12345678910111213专辑曲目： 1.四季列车 2.手语 3.公公偏头痛 4.明明就 5.傻笑 6.比较大的大提琴 7.爱你没差 8.红尘客栈 9.梦想启动 10.大笨钟 11.哪里都是你 12.乌克丽丽 《哎呦，不错哦》，发行日期：2014-12-26 12345678910111213专辑曲目： 1.阳明山 2.窃爱 3.算什么男人 4.天涯过客 5.怎么了 6.一口气全念对 7.我要夏天 8.手写的从前 9.鞋子特大号 10.听爸爸的话 11.美人鱼 12.听见下雨的声音 《周杰伦的床边故事》，发行日期：2016-06-24 1234567891011专辑曲目： 1.床边故事2.说走就走3.一点点4.前世情人5.英雄6.不该7.土耳其冰淇淋8.告白气球9.Now You See Me10.爱情废柴","tags":[{"name":"周杰伦","slug":"周杰伦","permalink":"http://yoursite.com/tags/周杰伦/"},{"name":"专辑封面","slug":"专辑封面","permalink":"http://yoursite.com/tags/专辑封面/"}]}]